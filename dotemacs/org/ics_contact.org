#+TITLE:     ICS Contact
#+AUTHOR:    wei.sun
#+EMAIL:     wei.sun@spreadtrum.com
#+DATE:      2012-05-30 Wed
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:

* ICS Contact
** Key ideas
- Account
- Separate data and view
- use FSA (Finite State Automaton) to keep track of SIM importing
- Multiple Selection
- Expandability
** Account (& Sync)
- Account (帐户)的概念是从 android 2.0 开始被加入到 android 中的, 并且一般和
  Sync (同步) 配合工作, 因此一般合称为 Account&Sync
*** 出发点
android 与 "移动互联网","社交网络","云"...似乎一开始就是紧密结合在一起的, 每天大
量的信息交互, 纷繁复杂的社交网络, 对各类信息实时性的要求, 多个设备间信息的同步的
需求...促使人们这样使用 android 来访问移动互联网:
- 安装各种各样的客户端: twitter, facebook, blog, Email....
- 这些客户端一般都可以将网络上的信息与本地的信息自动进行同步, 例如 twitter 可以
  自动同步 tweet. 据说有些人没有及时收到 tweet 时会表现出忧虑...
- 这些客户端一般还会与 android 自身一些本地应用进行整合, 例如 facebook 客户端可
  以把 facebook 的好友同步到本地联系人应用中

自动同步和深度整合, 是 Andorid Account&Sync 的一大特色
*** 实现
如何使用 Account&Sync 实现一个X客户端
1. 实现一个 account authenticator, 例如 XAccountAuthenticator, 这个
   authenticator 主要做两件事:
   - 提供一个 xml 配置文件, 通过 PackageManager 通知系统: "现在我们支持 X 帐户了"
   - 提供一个 addAccount 函数, 当系统要添加 X 帐户时, 会调用这个函数, 这个函数会
     与 X 的服务器交互, 主要是进行鉴权
2. 在 manifest.xml 写明该帐户支持哪些 SyncAdapter, 每个 SyncAdapter 有一个对应
   的 xml 配置文件, 说明:
   - 该 SyncAdapter 是用来同步哪个 content provider
   - 该 SyncAdapter 属于哪个帐户类型

3. 实现之前声明的 SyncAdapter
   每个 SyncAdapter 都要提供一个 performSync 函数, 该系统要同步该帐户的某一类数
   据时 (例如 contact, calendar...), 会调用相应 SyncAdapter 的 performSync 函数,
   这个函数会负责把网络上的数据与本地数据库进行同步.
*** Contact 对 Account 的支持
Contact 中已经存在大量的关于 Account 的代码. 若一个 account 包含一个 sync
adapter, 且这个 SyncAdapter 要同步的数据库是 contact provider, 则 contact 就会
认为这个 account 是和 contact 应用相关的.


Contact 对 Account 的支持主要体现在:
- 显示选项
  可以只显示属于某个帐户的联系人
- 联系人分组
  android 4.0 本身就支持联系人分组, 但分组是和帐户相关的, 即 要建立一个分组, 必
  须要说明它属于哪一个帐户.
- 上面提到各种社交网络客户端可以和 Contact 深度整合, 主要信赖于 contact 应用和
  contact provider 针对这种需求进行了很好的设计.

**** 显示选项
在 contact provider 的 raw\_contact.tlb 中两个字段和 account 相关:
- account\_name
- account\_type

当 SyncAdapter 从网络上向本地同步联系人时, 先建的联系人的这两个字段会被设置为
SyncAdapter 对应的帐户的 account name 和 account type, 以表明这个联系人属于该帐
户.

显示选项里会自动列出所有和 contact 相关的帐户, 当用户选择只显示某一个帐户的联系
人, contact 会通知 loader 只加载 raw\_contact 表中 account\_name 和 account\_type
字段为该帐户的联系人.
**** 联系人分组
在 contact provider 中, groups.tbl 每一条记录都表示一个分组, 与 raw\_contact 记录
类似, 其中中 account\_name, account\_type 表示这个分组是属于哪个 account

实际上在 android 2.x 时, groups.tbl 在 contact provider 中就存在了, 但 contact
应用并没有使用这张表, 所以那时的 contact 应用还不支持分组.

有些厂商在 android 2.x 加了分组的支持时, 普遍的都没有使用自带的 groups.tbl, 而是
自己建立一张新的表, 并且在 raw\_contact 中增加一个字段指明该联系人属于哪个分组,
这种做法并没有把分组与帐户关联起来, 导致的问题是: 在选择联系人时, 分组与帐户变成
同级的概念, 看起来不对称,且容易使人混淆.
**** 深度整合
不同的帐户建立的联系人可能有不同的字段, 例如有的帐户的联系人不支持电话, 而有的则
支持一种新的类型的数据,  例如 twitter 客户端可能在同步联系人会将联系人最近的一条
tweet 做为一种新的类型的数据写入到 contact 数据库中, 或者 twitter 客户端可以通过
编辑一个帐户 owner 对应的本地联系人的该新型的数据向 twitter 发送一条新的 tweet.

tweet 被抽象为本地联系人数据库的一条数据, contact 如何编辑和显示这种数据?

实际上, contact 的编辑和显示界面完全是 account 通过"数据驱动"画出来的, account
通过 xml 配置文件告诉 contact 如下信息:
- 帐户支持哪些字段: 名字, 电话, email, ...
- 每种字段最多支持几个输入框 : 最多几个电话, 几个 email ...
- 每种字段支持哪些类型: 如电话的"家用", "手机", "传真" ...
- 每种字段的输入框的类型: text, number, email, password ...
- 每个输入框与 contact provider 的 data 表的哪一个字段对应, 这样 contact 就知道
  如何从 contact provider 中读取和写入这些数据.
- ...

contact 通过 account 提供的这些信息就能完整的画出 contact 的编辑和显示界面.

*** 同步: 分离界面与数据
一般情况下, account 通过 SyncAdapter 与网络上的数据交互, 而不是在 contact 应用中
直接与网络数据交互. 例如: facebook 客户端修改了本地一个 facebook 联系人的资料并同
步到网络上的过程如下:
1. 本地对 facebook 联系人的修改与修改一个手机本地的联系人没有任何区别, 都是直接
   读写 contact 数据库, 但值得注意的是, 数据库中对应的 raw\_contact 的 is\_dirty
   会被置位.
2. facebook account 的 SyncAdapter 的 performSync 在某个时候被调用 (用户手动要
   求同步或自动同步)时, performSync 函数会扫描 contact 数据库中 account 为
   facebook 且 is\_dirty 被置位的联系人, 然后把这些联系人的所有数据同步到 facebook
   服务器.
3. facebook SyncAdapter 会负责将 本次同步的联系人的 is\_dirty 复位

可见, 通过 account 的同步机制,  contact 应用部分的代码大大简化.

SIM 卡抽象为 account 后, contact 应用仍然采用这种机制来简化 contact 应用对 SIM卡
的处理,即 contact 应用不会直接操作 SIM 卡, 而是依赖于 ContactProvider 与 SIM 卡
的同步. 但由于 SyncAdapter 机制本身的一个限制以及 SIM 卡区别于一般帐户的特殊性,
我们采用了另一个方式来进行同步.

** Contact 与 SIM 卡解耦合
类似的需求, 决定了把 SIM 卡抽象为 Account 也就算水到渠成:
- SIM 卡联系人与手机联系人需要分类显示
- USIM 卡需要分组
- 编辑和查看 SIM 卡联系人时需要使用不同于手机联系人的界面 (SIM 卡只支持一个电话,
  USIM 卡支持多个电话, 多个 email ...)
- SIM 卡中的联系人和手机存在 "sync" 的需求: 即 SIM 卡中的联系人需
  要同步到手机, 手机对 SIM 卡联系人的修改需要同步到 SIM 卡上.
*** 实现
- 由于 SIM 卡与 USIM 卡支持的字段差别较大, 所以把 SIM 和 USIM 抽象为两种帐户类型
- 分别实现 SimAccountAuthenticator, UsimAccountAuthenticator, 由于 SIM/USIM 帐户
  并不需要真正在像社交客户端一样在添加帐户时向服务器鉴权, 所以 addAccount 的实现
  为空
- 分别实现 SimSyncAdapter, USimSyncAdapter, 注意的是, 虽然 SIM 卡需要与手机进行
  同步, 但我们并没有依赖 SyncAdapter 的 performSync 函数, 所以该函数也为空 (原
  因在后面描述)

** ContactProvider 与 SIM 卡解耦合
ContactProvider 的主要作用是将 ContactProvider 中 SIM 卡的改动同步到 SIM 卡中,
本来使用 SyncAdapter 是一个很好的选择, 但出于以下考虑, 我们只能放弃 SyncAdapter
这种方法:
- 由于系统中所有的 SyncAdapter 都是串行执行的, 若一个 SyncAdapter 发起的同步迟迟
  没有结束, 则 SIM 卡的 SyncAdapter 永远都无法进行同步
- 用户写 SIM 卡时, 通常都希望能马上看到操作的结果

因此, 我们采用了在 ContactProvider 中插入 SIM 卡操作相关的 hook 的方法来同步, 大
致过程如下:

#+begin_src ditaa :file hook.png

                                                    ------\
                                              Account     |    SIM
Contact               Provider                            |
+----------+          +-----------+-------+               |
| Name: {d}|     +--->| update() { {s}    |               |             SIM
|  xxx     |     |    |   ..              |        +------+------+      +--------+
| Phone:   |     |    |  SimProxy.update  +------->| SimProxy{io}+----->|     {s}|
|  123     |     |    | }                 |        +------+------+      +--------+
|     SAVE +-----+    +-------------------+               |
+----------+                                              |
                                                    ------/

#+end_src

可见, ContactProvider 的主要改动是在 update(), insert(), delete() 等处插入对
SimProxy 的调用, SimProxy 使用 IccProvider 直接操作 SIM 卡.
*** ContactProvider Hook
*** SimProxy
SimProxy 通过 IccProvider 直接操作 SIM 卡, 它是 Account 与 SIM 卡之间的桥梁
*** Account userData
** SIM 卡联系人导入
SIM 卡联系人需要在开机时从 SIM 卡导入到手机中, 然后 Contact 应用才能显示和处理
SIM 卡中的联系人. 

导入到手机中的 SIM 卡联系人和普通手机联系人都保存到 ContactProvider 中, 主要的不
同是:
- SIM 卡联系人的 accountType 和 accountName 字段为 SimAccount 或 UsimAccount, 而
  手机联系人的 account 为 PhoneAccount
- SIM 卡联系人的 SYNC1 和 SYNC2 字段分别是用来保存 SIM卡 相关信息, 比如 该联系人
  在卡上的位置 (index), 有了这些 SIM 卡额外信息, ContactProvider 才知道如何中将
  对这些联系人的操作反映到对应的 SIM 卡上. 

导入 SIM 联系人的过程其实就是从 SIM 卡中读出联系人的名字,号码,邮件等, 然后将这些
联系人信息以及卡的信息保存到 ContactProvider 中.

由于每一个 SIM 卡帐户对应着一张 SIM 卡, 刚第二次开机时, SIM 卡的安装情况可能会变
化, 所以简单起见, 开机直接删除所有 SIM 卡帐户以及 SIM 卡联系人, 然后重新根据 SIM
卡的安装情况建立对应的 SIM 卡帐户并重新导入 SIM 卡联系人.

开机导入 SIM 卡联系人的过程:

# state: init->boot_completed->remove_account->purge_contact->add_account->import_contact
#+begin_src dot :file fsa.png
  
  digraph G {
   subgraph cluster1 {
      label="Account State"
      INIT->BOOT_COMPLETED[label="onEvent(BOOT_COMPLETED)"]
      BOOT_COMPLETED->ACCOUNT_REMOVED [label="onAction(REMOVE_ACCOUNT)"]
      ACCOUNT_REMOVED->CONTACT_PURGED [label="onAction(PURGE_CONTACT)"]
      isIccLoaded [shape=diamond label="if ICC State == ICC_LOADED"]
      isIccLoaded->CONTACT_PURGED [label="No"]
      isIccLoaded->ACCOUNT_ADDED [label="Yes"]
      CONTACT_PURGED->isIccLoaded [label="onAction(ADD_ACCOUNT)"] 
      CONTACT_PURGED->isIccLoaded [label="onEvent(ICC_LOADED)"] 
      ACCOUNT_ADDED->CONTACT_IMPORTED [label="onAction(IMPORT_CONTACT)"]
   }
  
   subgraph cluster2 {
       label="ICC State"
       ICC_LOADED -> ICC_LOADED [label="onEvent(ICC_LOADED)"]
   }
   ICC_LOADED -> isIccLoaded [style=dashed]
  
  }
#+end_src

开机导入 SIM 卡联系人的过程被划分为6个状态:
- INIT
- BOOT\_COMPLETED
- ACCOUNT\_REMOVED
- CONTACT\_PURGED
- ACCOUNT\_ADDED
- CONTACT\_IMPORTED

这样做的主要目的是为了处理在导入过程中可能出现的各种异常情况,例如:
- 由于 framework 的 bug 或限制, BOOT\_COMPLETE, ICC\_LOADED 等 broadcast 反复触发
  通过状态的控制,可以限制某些 broadcast 只能在 Account State 处于某些特定状态时
  才被处理
- 导入过程中发生飞行模式切换, 禁卡, 或进程异常终止, 甚至以后可能支持的一些新
  feature, 如 SIM 热插拔等
  
  以 SIM 卡热插拔为例, 当程序检测到某张 SIM 卡被拔出时, 无论现在 Account State
  处理哪个状态, 我们需要做的只有两步:
  1. 将状态置为 BOOT_COMPLETED
  2. 调用 onAction(REMOVE_ACCOUNT) 从 BOOT_COMPLETED 状态开始重新进行导入动作.

  
总之, 使用状态机来控制 SIM 卡联系人导入的过程主要是为了提高系统的容错性, 一旦发
生错误或某些异常状态, 可以切换到某个状态重新开始. 

** 联系人多选
Contact 提供了一个 ContactSelectionActivity 来对外提供各种各样的选择联系人的服务,
如选择联系人, 选择电话号码, 选择电子邮件等, 但所有这些都只是提供了单选的功能, 没
有多选, 而在 Contact 中有多处需要用到多选的情况, 例如:
- 批量删除联系人
- 批量导入导出联系人
- 通过彩信, 蓝牙等分享多个联系人
- SMS 一次选择多个联系人号码或电子邮件发送短信或彩信
- ...

4.0 的多选功能是直接到最底层的 ContactEntryLisFragment 及 ContactEntryListAdater
上扩展的, 这样做主要有两个好处:
1. 单选与多选在界面上是一致的
2. 单选界面原来的一些功能, 如: 
   - 查找联系人
   - 根据帐户及分组过滤显示
   - 帐户有变化时自动刷新界面
   - ...
   等可以直接使用. 

** 可扩展性
*** 支持一种新的 SIM 卡
目前我们支持 SIM 和 USIM 两种 SIM 卡, 分别对应两种不同的帐户, 之所以 SIM 和 USIM
要区分, 主要是因为 SIM 卡和 USIM 支持的字段不同, 例如 USIM 支持电子邮件而 SIM 就
不支持. 因为联系人的编辑界面完全是由帐户的属性定义的, 所以对于 SIM 和 USIM, 我们
定义了两种帐户. 

由于 SIM 卡联系人的编辑界面完全由 Contact 根据帐户的属性显示出来, 所以说如果我们
要支持一个新的 SIM 卡, 只需要:
1. 定义一种新的帐户类型, 并在代码中指明它支持的字段
2. 在导入 SIM 卡联系人时导入这些字段到 ContactProvider
3. 在编辑或新建 SIM 卡联系人时, ContactProvider 保存这些字段到 SIM 卡

*** 支持 3/4/N 卡
对于我们已经支持的 SIM 卡类型, N 张卡只是对应着 N 个该种 SIM 卡帐户类型的多个帐
户, Contact 会在开机时根据卡槽的情况自动添加 SIM 卡帐户, 所以无需针对 N 卡的需求
修改.

*** 支持 SIM 卡热插拔
如 [[ SIM 卡联系人导入]] 所述, 导入联系人使用 FSA 可以支持 SIM 卡热插拔.

** 待改进
*** 删除 AccountRestrictionUtil 类
Contact 对 SIM 卡联系人的修改是通过 ContactProvider 中设置的 HOOK 来直接操作 SIM
卡的, 而 SIM 卡操作时会发生许多异常情况, 例如:
- SIM 卡已满
- 某个字段超出 SIM 卡支持的最大长度
- 某个字段的值有问题, SIM 卡无法处理
- ...

理论上, 这些异常情况应该由 SIM 卡返回给 ContactProvider, 然后再返回给 Contact 应
用, 以便 Contact 应用可以将这些 SIM 卡的异常反馈给用户, 但是, 由于 Contact 和
ContactProvider 之间, 以及 ContactProvider 与 SIM 卡 (即 IccProvider) 之间都是通
过 ContentProvider 进行沟通的, 而 ContentProvider 本身难以将异常情况的详细信息返
回给调用者, 导致 Contact 中增加了一个非常丑陋的 AccountRestrictionUtil 类...

这个类的主要作用是:
- 在 Contact 编辑联系人并尝试保存时, 会先调用 AccountRestrictionUtil 的方法去检查
  此次更改有没有可能因为`帐户限制`而失败.
- `帐户限制`其实就是 SIM 卡里那些限制, 只不过被封装在帐户中, 而不是直接调用 SIM
  卡的相关函数去获得这个限制信息.

这个 AccountRestrictionUtil 与 SIM 卡紧紧耦合在一起, 并且使界面与数据也耦合在一
起.

虽然 ContentProvider 难以通过函数返回值返回详细的错误信息, 但我们其实可以通过重
写 Binder 调用的 proxy 及 stub 部分代码使其通过`跨进程异常`返回详细的错误信息,
到时就可以删除 AccountRestrictionUtil 类了.  



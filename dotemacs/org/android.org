* Android
#+CATEGORY:android
** ActivityManagerService
   :PROPERTIES:
   :ID:       ams
   :END:
*** Intent and IntentFilter					     :intent:
**** Intent.setPackage(pkg)
     only match Activities in this `pkg`
**** Intent.component
**** IntentFilter.priority
     candidates ARE sorted by IntentFilter.priority when resolving intent, but
     - when resolve activity, ResolveActivity will reorder candidates in alphabet order....so nothing
     - when resolve service, only candidate with the highest priority are selected
     - when resolve broadcast, candidate priority are considered for OrderedBroadcast
**** DONE [#A] IntentFilter matching
     CLOSED: [2011-01-19 Wed 16:07]
     - State "DONE"       [2011-01-19 Wed 16:07]
     how startActivity(or startService, sendBrocast) use Intent.{category,action,data} to find the correct intent receiver?
     AMS use [[PackageManager][PackageManager]] to resolve intent to get intent's component
***** startActivity
#+BEGIN_EXAMPLE lang:c
      AMS:startActivity()
          AMS:startActivityMayWait()
	      PM:resolveIntent()
	          PM:queryIntentActivities()
		      // explicit intent
		      if (intent.getCommponent())
		          return the component
		      // implicit intent
		      if (intent.getPackage()==null)
		          PM:mActivities.queryIntent()
			      foreach activity:
			       	buildResolveList()
			           foreach IntentFilter:
                                     filter.match()
                                     make sure filter has DEFAULT category
		      else
		          PM:mActivities.queryIntentForPackage()
                            foreach activity:
			       	buildResolveList()
			           foreach IntentFilter:
                                     filter.match()
                                     make sure filter has DEFAULT category
		  PM:chooseBestActivity()
		      // candidates here are sorted by [[IntentFilter.priority][IntentFilter.priority]]
                      if (candidates.size() == 1)
		          return it;
		      if we have saved a preference for a preferred activity
		          return findPreferredActivity()
		      else
                          return ResolverActivity // although candidates are sorted by IntentFilter.priority, ResolverActivity will
			                          // reorder them in alphabet order...weired~~
	      Intent.setComponent()
	      AMS:startActivityLocked()
	        checkComponentPermission();
	      ...
#+END_EXAMPLE
      - PM:resolveIntent
       	when PackagetManager need to detect whether there are activities in a certain package matching the Intent, it will resolve the inent as:
       	1) PM calls queryIntentForPackage, which will take a List of activities in the package as param
       	2) for every activity, call buildResolveList, which take a List of all IntentFilters of the activity as param
       	3) for every IntentFilter, call filter.match( intent.getAction(), resolvedType, scheme, intent.getData(), categories, TAG); to determine whether
	   the IntentFilter matches the Intent, if so, add the activity to the candidates.  Note that categories is a list of Category in the intent, since
	   intent can call addCategory() to add serveral categories requirement
       	4) filter.match() will check
	   1) action
	      intent action mustn't be null and must be in the IntentFilter's actions list
	   2) data
	      data must be a subset of IntentFilter's data list
	   3) category
	      if intent's categories is a subset of filter's categories, or intent's category is null , return ok
       	5) if filter.match() match, there is still one last check:
	   1) if the defaultOnly flag is set (in fact, startActivity will always set the flag when resolveIntent), and the candidate intentFilter also
	      has the DEFAULT category, returns ok.  this is just as if the Intent has added the DEFAULT category by default. BUT, since it is restriction
	      imposed by AMS, we can't override the behaviour by calling intent.removeCategory(DEFAULT)
	   2) note: the DEFAULT_ONLY flag and intentFilter's default category is mainly used by startActivity, use PM standalone (e.g. resolveActivity) doesn't
	      impose this restriction.
      - PM:chooseBestActivity
       	after PM:resolveIntent, a list of candidates are available, PM will choose the best activity
       	1) if there is only ONE candidates, return it
       	2) else, call findPreferredActivity to find if we have saved a preference for a preferred activity for this intent
       	3) else, return a ResolverActivity, which will show a ResolverActivity and promp user for the prefered activity. ResolverActivity will sort candidates
	   in alphabet order, regardless of IntentFilter's priority.
      - At last, if PM returns a ResolverActivity, AMS will actually start ResolverActivity, ResolverActivity's onClick will call startActivity() to start the real user prefered activity.

***** startService
#+BEGIN_EXAMPLE
      AMS:startServiceLocked()
        AMS:retrieveServiceLocked()
	    if ret=mServicesByIntent.get(intent)
	        return ret; //      * All currently running services indexed by the Intent used to start them.
	    else
                PM:resolveService()  // just like resolveActivity
		    PM:queryIntentServices()
		        if intent.getComponent()
			    use it;
			else
			    PM:queryIntent() // return a list of candidates, note that the list is sorted according to [[IntentFilter.priority][IntentFilter.priority]]
		    if candidates>1      // more than ONE candidate
		        use candidate.get(0)  // pick the first one. because the candidates are sorted according
			                         // to IntentFilter.priority, so the candidate with the highest priority is selected.
            checkComponentPermission()
#+END_EXAMPLE

***** sendBroadcast
      just as startService, priority are considered, and a list of all candidates are return to support OrderedBroadcast
*** Activity                                                     :activity:
**** AMS side
***** finishedActivityLocked
      finishCurrentActivity eventually will not stop and destroy activity at once, it will pose it in an array, when idle, it will call activityIdle to purge the activities.
      When is idle? There are 2 scen:
      1) thread.scheduleResumeActivity will pose one 'Idler' in the msg queue after onResume is finished. Idler will invoke AMS.activityIdle
	 2)AMS is smart enough to pose on one delayed IDLE_TIMEOUT_MSG to the handler in case there is no Idler since onResume hangs. The delayed timeout is 10s.

	 That is, onStop and onDestroy may be delayed for 10s after another activity's onResume is called.
	 11/23/10 11:40 am
	 finishActivityLocked
	 startPausing

	 ...

	 activityPaused
	 finishCurrentActivity --> mark the activity for destroy
	 resumeTopActivity
	 ...
	 activity resumed --> pose idler timer to destroy activity marked befored

	 11/17/10 6:46 pm
	 assume that when A is finished and B will be resumed: first, A is paused, then B is resumed, and A is stopped and destroyed at last


	 11/17/10 6:37 pm
	 To prevent if activity.onPause doesn't return in a period of time(500ms), AMS will call sendMessageDelayed() in startPausingLocked() to send itself one PAUSE_TIMEOUT msg to force itself call activityPaused().

	 That is, although activity.onPause() may block, AMS is assured to resume	next activity in 500ms.

	 11/17/10 5:47 pm
      1. activity.finish() will call AMS's finishActivity() through AIDL, providing activity's IBinder as parameter so that AMS can recognize the corresponding HistoryRecord in AMS.

      2. AMS calls
	 finishActivityLocked()
	 startPausingLocked()
	 thread.schedulePauseActivity()

      3. thread.schedulePauseActivity() will call activity.onPause(), then notify AMS that activity is paused through AMS.activityPaused()

      4. activityPaused()
	 completePauseActivity()
	 mark activity for stop when idle
	 resumeTopActivity()
***** attachApplication

attachApplication is the 3rd step to start a new activity. (1. startPausing, 2. activityPaused.)
When one new activityThread is created, after calling onCreate, activityThread will invoke AMS.attachApplication to notify AMS that process is OK, then AMS can call realStartActivity to launch the activity.

***** activityPaused
activityPaused is called by ActivityThread to notity AMS that the mResumed activity is paused(or onPause is timeout)
after that, if prev should be finished (when finish activity), it will call finishCurrentActivity to finish prev activity. Then resumeTopActivity will be called again to really resume another activity.

***** startActivityLocked

11/22/10 2:08 pm
AMS.startActivityLocked() is the very begining  entry to start activity.

Stack trace:
AMS side:
#+BEGIN_EXAMPLE
startActivity
  startActivityUnchecked
     moveTaskToFront
        finishTaskMoved
            resumeTopActivity
#+END_EXAMPLE

when resumeTopActivity, it will firstly call startPausing to pause mResumedActivity A.

after A's onPause return, ActivityThread will notify AMS through AMS.ActivityPaused, which will then call resumeTopActivity again to resume  activity.

When invoked for the 2nd time, it will try call r.app.thread.scheduleResumeActivity to resume our activity,  then return. but before calling onResume, AMS
will firstly invoke mWindowManager.setAppVisibility(next, true) if the activity is invisible, which will call onRestart and onStart before onResume.

If exception occurs, it means the activity is already finished, or it's process is not started at all, it will call
#+BEGIN_EXAMPLE
startSpecificActivityLocked,
  realStartActivityLocked
    thread.scheduleLaunchActivity

or
startSpecificActivityLocked,
  startProcessLocked
#+END_EXAMPLE

for the 2nd scenero, when activityThread is started in startProcessLocked, it will call AMS.attachApplication to notify AMS that the process is ready, attachApplication will then call realStartActivity again to real kaunch the activity.

***** resumeTopActivityLocked

11/22/10 6:38 pm
resumeTopActivity will firstly call startPausing to pause the mResumedActivity, then return directory.

When mResumedActivity is paused or timeout (500ms), AMS.activityPaused will be called, which will invoke resumeTopActivity again to finally resume(or launch) the activity.

***** Timeout
****** Pause timeout
****** Idle timeout
       11/23/10 3:49 pm
       idle timeout is the timeout to stop and destroy activity A after activity B is resumed.
       in the normal case, B's scheduleResumeActivity will pose an Idler after onResume to ensure that A will be finish via activityIdle.
       Howerer, if B's onResume hangs, a delay IDLE_TIMEOUT_MSG is a must for AMS to make sure A will be finished in 10s.

***** HistoryRecord
      HistoryRecord is used in two ways:
      - it is the shadow structure of `Activity` in AMS
      - it is used as a IBinder token by AMS, e.g. when AMS want to resume activity, it will send the activity's corresponding HistoryRecord as a token to
	ActivityThread, so that ActivityThread knows which activity to resume.
	- r.app.thread
	- r.resultRecord
	- r.sourceRecord
	- r.intent
****** AMS.mHistory stores all the HistoryRecord of AMS.
***** startPausingLocked
11/22/10 6:43 pm
startPausing is called in resumeTopActivity to pause the mResumed activity before resume or launch the target activity
***** startSpecificActivity
11/23/10 1:06 pm
it is called when resumeTopActivity (2nd time when prev is paused) to start (instead of resume) target activity.

It may call realStartActivity to start the activity or call startProcess to start a new process.
****** startProcess
****** realStartActiviry
11/23/10 1:10 pm
real start an activity instead of resume or start a new process.

This is called in 2 scen:
1) startSpecificActivity in resumeTopActivity
2) attachApplication, since when attachApplication, the process definitly exist and activity is surely not started yet. resumeTopActivity is redunctant, calling realStartActivity is enough.
**** ActivityThread side
***** ActivityRecord
      12/28/10 7:50 pm
      ActivityRecord will save the real Activity instance and some other info.  It corresponds to AMS::HistoryRecord.
      ActivityRecord use one Map<IBinder,ActivityRecord> to save process's all activities.
      Evey ActivityThread.scheduleXxx ()  takes  an 'Token' (an IBinder)  as para so that ActivityThread can get the corres ActivityRecord from the map.
***** IApplicationThread
****** schedulePausingActivity
       schedulePausingActivity will firstly call activity.onPaused, and wait for
       return, then it will notify AMS through AMS.activityPaused that the
       activity is paused.
****** scheduleResumeActivity
       it will call onResume, when onResume returns, it will add one Idler to
       AMS's queue, to make sure AMS will be norified when queue is idle to stop
       and destroy pending need-to-finish act ivies
****** scheduleLaunchActivity
       when called by AMS.realStartActivity, scheduleLaunchActivity will
       sequencially call onCreate, onStart,
       onRestoreInstanceState,onPostCreate,onResume.
**** Activity side
     - onStop, onRestart is only related to activity visibility. they are invoked by mWindowManager.setAppVisibility() due to visibility change.
     - onStart may be called due to visibility change or life cycle change.
     - onPause, onDestroy, onResume is the core concept related to activity life cycle, they are called only when life cycle is changed.
***** finish
***** onPause
      only when starting another *Activity*, will the former activity's  onPause be called;
      that is, Dialog, PopupWindow will not trigger activity's onPause
***** onStop
      may only be called after onPause
      if the paused activity is totally invisible to the user, onStop will be called
      that is, if the resumed activity is opaque, the paused activity's onStop would not be called

      resumeTopActivity will call mWindowManager.setAppVisibility(prev, false); // cause prev.onStop be called
      to stop prev activity

***** onDestroy
***** onResume
***** onRestart
      resumeTopActivity will cal  mWindowManager.setAppVisibility(next, true);  // cause next.onRestart and next.onStart be called
      to call onRestart and onStart
***** onStart
***** onCreate
**** Task stack
**** NativeActivity
**** Activity Result

**** PENDING Launcher
     see also [[Launcher & Task]]
**** Task
***** why relaunch an activity A from launcher will bring the task to foreground
       note that: startActivity from launcher will always use Intent flags of NEW_TASK

#+BEGIN_EXAMPLE
       startActivityUnchecked()
         if NEW_TASK && ((MULTIPLE_TASK not set)||...): // see MULTIPLE_TASK flag later, true
	   taskTop = findTaskLocked(intent, r.info)
	     // findTaskLocked will return the top activity in any existing task matching the given intent
	     // typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered
	     // How taskAffinity is null? if activity's taskAffinity property is set to "" (see [[Notification]]), then it's taskAffinity will be set to null

           if (taskTop != null): // there is already an existing task for the activity A, true
	     if (r.realActivity.equals(taskTop.task.realActivity)): // activity A is the same as the matching task's root activity, true
	       if FLAG_ACTIVITY_SINGLE_TOP is set:
	         deliverNewIntentLocked(taskTop, r.intent);  // onNewIntent is called
		 resumeTopActivityLocked(null);
		   mWindowManager.setAppVisibility(prev, false); // cause onStop be called
		   mWindowManager.setAppVisibility(next, true);  // cause onRestart and onStart be called
                 return START_DELIVERED_TO_TOP;
	       else if r.intent.filterEquals(taskTop.task.intent):  // if activity A's calling intent is equal with the intent used to start
	                                                            // the task's root activity, intent equality will consider intent action,category,
								    // data,type,component..., but *excluding any intent extra*, true
                 resumeTopActivity()
		   if resumedActivity == topRunningActivity:        // need not resume, in this case, resumedActivity is launcher, while topRunningActivity
		                                                    // is Activity A, false
		     return;
		   else:
		     pause resumeActivity and resume topRunningActivity  // true
		     mWindowManager.setAppVisibility(prev, false); // cause onStop be called
		     mWindowManager.setAppVisibility(next, true);  // cause onRestart and onStart be called

		 return START_TASK_TO_FRONT;                        // move the task to foreground
         else: // if NEW_TASK
	   if (top.realActivity.equals(r.realActivity)):
	     if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
               or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
               or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
	       resumeTopActivityLocked(null);
               deliverNewIntentLocked(top, r.intent);
               return START_DELIVERED_TO_TOP;
	   create or start the activity                           // false

#+END_EXAMPLE

      To summarize:
      when relaunching an activity from launcher, because the intent used to relaunch the activity is the same as the former task's root activity's intent
      (both are MAIN & LAUNCHER..), AMS will try to resume the activity instead of relaunching it.
      startActivity with *NEW\_TASK* and the *same* intent as the task's intent will bring the task to foreground (through resumeTopActivity) instead of
      launching it. this behavior is similar with that the task's top activity has the SINGLE\_TOP launchMode.

      Note about MULTIPLE\_TASK intent flag:
      Used in conjunction with FLAG\_ACTIVITY\_NEW_TASK to disable the behavior of bringing an existing task to the foreground.  When set,
      a new task is always started to host the Activity for the Intent, regardless of whether there is already an existing task running
      the same thing.

***** DONE [#A] startActivityUnchecked & affinity, launchMode, intentFlags
      SCHEDULED: <2011-05-13 Fri> CLOSED: [2011-05-13 Fri 15:05]
      - State "DONE"       [2011-05-13 Fri 15:05]
      *FLAG\_ACTIVITY\_NEW\_TASK* is defininitly the most important property related to android task management.
****** source code comment
#+BEGIN_EXAMPLE
     1	       private final int startActivityUncheckedLocked(HistoryRecord r,
     2	            HistoryRecord sourceRecord, Uri[] grantedUriPermissions,
     3	            int grantedMode, boolean onlyIfNeeded, boolean doResume) {
     4		Slog.e("sunway","flag");
     5	        final Intent intent = r.intent;
     6	        final int callingUid = r.launchedFromUid;
     7	        int launchFlags = intent.getFlags();
     8
     9	        // We'll invoke onUserLeaving before onPause only if the launching
    10	        // activity did not explicitly state that this is an automated launch.
    11	        mUserLeaving = (launchFlags&Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
    12	        if (DEBUG_USER_LEAVING) Slog.v(TAG,
    13	                "startActivity() => mUserLeaving=" + mUserLeaving);
    14
    15	        // If the caller has asked not to resume at this point, we make note
    16	        // of this in the record so that we can skip it when trying to find
    17	        // the top running activity.
    18	        if (!doResume) {
    19	            r.delayedResume = true;
    20	        }
    21
    22	        HistoryRecord notTop = (launchFlags&Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP)
    23	                != 0 ? r : null;
    24
    25	        // If the onlyIfNeeded flag is set, then we can do this if the activity
    26	        // being launched is the same as the one making the call...  or, as
    27	        // a special case, if we do not know the caller then we count the
    28	        // current top activity as the caller.
    29	        if (onlyIfNeeded) {
    30	            HistoryRecord checkedCaller = sourceRecord;
    31	            if (checkedCaller == null) {
    32	                checkedCaller = topRunningNonDelayedActivityLocked(notTop);
    33	            }
    34	            if (!checkedCaller.realActivity.equals(r.realActivity)) {
    35	                // Caller is not the same as launcher, so always needed.
    36	                onlyIfNeeded = false;
    37	            }
    38	        }
    39
    40	        if (grantedUriPermissions != null && callingUid > 0) {
    41	            for (int i=0; i<grantedUriPermissions.length; i++) {
    42	                grantUriPermissionLocked(callingUid, r.packageName,
    43	                        grantedUriPermissions[i], grantedMode, r);
    44	            }
    45	        }
    46
    47	        grantUriPermissionFromIntentLocked(callingUid, r.packageName,
    48	                intent, r);
    49
    50	        if (sourceRecord == null) {
    51	            // This activity is not being started from another...  in this
    52	            // case we -always- start a new task.
    53	            if ((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
    54	                Slog.w(TAG, "startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: "
    55	                      + intent);
    56	                launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    57	            }
    58	        } else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    59	            // The original activity who is starting us is running as a single
    60	            // instance...  this new activity it is starting must go on its
    61	            // own task.
    62	            launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    63	        } else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
    64	                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    65	            // The activity being started is a single instance...  it always
    66	            // gets launched into its own task.
    67	            launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    68	        }
    69
    70	        if (r.resultTo != null && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    71	            // For whatever reason this activity is being launched into a new
    72	            // task...  yet the caller has requested a result back.  Well, that
    73	            // is pretty messed up, so instead immediately send back a cancel
    74	            // and let the new task continue launched as normal without a
    75	            // dependency on its originator.
    76	            Slog.w(TAG, "Activity is launching as a new task, so cancelling activity result.");
    77	            sendActivityResultLocked(-1,
    78	                    r.resultTo, r.resultWho, r.requestCode,
    79	                Activity.RESULT_CANCELED, null);
    80	            r.resultTo = null;
    81	        }
    82
    83	        boolean addingToTask = false;
    84	        if (((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &&
    85	                (launchFlags&Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
    86	                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
    87	                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    88	            // If bring to front is requested, and no result is requested, and
    89	            // we can find a task that was started with this same
    90	            // component, then instead of launching bring that one to the front.
    91	            if (r.resultTo == null) {
    92	                // See if there is a task to bring to the front.  If this is
    93	                // a SINGLE_INSTANCE activity, there can be one and only one
    94	                // instance of it in the history, and it is always in its own
    95	                // unique task, so we do a special search.
    96
    97			// sunway:
    98			// 对于launchMode不为SINGLE_INSTANCE的情况, taskTop是根
    99			// 据affinity(或activity component)查找到的已存在的task的top activity; 对于
   100			// SINGLE_INSTANCE的情况, taskTop为该single activity
   101			// Q: 系统如何在NEW_TASK时查找是否已经存在一个`密切`的task?
   102
   103	                HistoryRecord taskTop = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE
   104	                        ? findTaskLocked(intent, r.info)
   105	                        : findActivityLocked(intent, r.info);
   106
   107			// sunway:
   108			// 对于NEW_TASK, 已经找到一个已经存在的TASK或single instance
   109			// activity
   110
   111	                if (taskTop != null) {
   112	                    if (taskTop.task.intent == null) {
   113	                        // This task was started because of movement of
   114	                        // the activity based on affinity...  now that we
   115	                        // are actually launching it, we can assign the
   116	                        // base intent.
   117	                        taskTop.task.setIntent(intent, r.info);
   118	                    }
   119	                    // If the target task is not in the front, then we need
   120	                    // to bring it to the front...  except...  well, with
   121	                    // SINGLE_TASK_LAUNCH it's not entirely clear.  We'd like
   122	                    // to have the same behavior as if a new instance was
   123	                    // being started, which means not bringing it to the front
   124	                    // if the caller is not itself in the front.
   125
   126
   127	                    HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);
   128
   129			    // sunway:
   130			    // our task or single_instance activity is in background,
   131			    // move it to front
   132
   133	                    if (curTop.task != taskTop.task) {
   134	                        r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
   135	                        boolean callerAtFront = sourceRecord == null
   136	                                || curTop.task == sourceRecord.task;
   137
   138				// sunway:
   139				// 如果: 1. new task 2. task在后台 3. caller在前台 (或
   140				// sourceRecord==null),则将task移到前台, 所以, 一个后台的
   141				// task里的一个thread无法通过 new_task &
   142				// activity.startActivity将task移动到前台
   143
   144	                        if (callerAtFront) {
   145	                            // We really do want to push this one into the
   146	                            // user's face, right now.
   147	                            moveTaskToFrontLocked(taskTop.task, r);
   148	                        }
   149	                    }
   150	                    // If the caller has requested that the target task be
   151	                    // reset, then do so.
   152	                    if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
   153				// sunway:
   154				// reset task ... take a deep breath;
   155	                        taskTop = resetTaskIfNeededLocked(taskTop, r);
   156	                    }
   157	                    if (onlyIfNeeded) {
   158	                        // We don't need to start a new activity, and
   159	                        // the client said not to do anything if that
   160	                        // is the case, so this is it!  And for paranoia, make
   161	                        // sure we have correctly resumed the top activity.
   162	                        if (doResume) {
   163	                            resumeTopActivityLocked(null);
   164	                        }
   165	                        return START_RETURN_INTENT_TO_CALLER;
   166	                    }
   167
   168	                    if ((launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
   169	                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
   170	                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
   171	                        // In this situation we want to remove all activities
   172	                        // from the task up to the one being started.  In most
   173	                        // cases this means we are resetting the task to its
   174	                        // initial state.
   175
   176				// sunway:
   177				// 在大多数情况下, task或single instance activity
   178				// 在此之前已经被移动到前台,performClearTaskLocked只会
   179				// finish该task中位于r之上的activity, 除非...移动到前台
   180				// 时失败(例如callerAtFront为假,这时会有意想不到的效
   181				// 果)
   182
   183				// sunway:
   184				// performClearTaskLocked会finish位于r,top之间的所有
   185				// activity,一般情况下不会finish `基准`activity (对于
   186				// CLEAR_TOP,即是r,对于SINGLE_TASK,SINGLE_INSTANCE,即是
   187				// task的root activity, 除非...基准activity是MULTIPLE
   188				// launch mode且其SINGLE_TOP为假
   189
   190				// 总结: 对于一般的startActivity(不包含
   191				// RESET_TASK_IF_NEEDED intent flag), CLEAR_TOP是可以
   192				// finish某些activity的机会,如果想让一个activity在每次
   193				// startActivity时finish掉之前的并create新的且只有一个实
   194				// 例 (例如某些通知功能的activity),可以:
   195				// 1. 使用NEW_TASK和CLEAR_TOP
   196				// 2. launchMode为MULTIPLE,且SINGLE_TOP为假
   197				// 3. 为防止CLEAR_TOP误杀同task的其他activity, 可以设其
   198				// affinity为其他唯一值或者直接使用空串, 确保task中只有
   199				// 它一个activity (类似于singleInstance)
   200
   201				// Q: 看起来start SINGLE_TASK 的 root activity 也会导致
   202				// performClearTask .... 并perforClearTask并不
   203				// 能保证developer中声称的SINGLE_TASK的属性:SINGLE_TASK必
   204				// 须是task的root activity; 实际上这段代码的效果是: 设
   205				// A,B的affinity相同, A启动B,其中B是
   206				// SINGLE_TASK,则结果是A,B; B再启动A,结果A,B,A; A再启动
   207				// B, 结果是A,B, 和CLEAR_TOP有啥区别?
   208				// 若想达到文档中声称的SINGLE_TASK效果,必须保证B一开始就
   209				// 是task的root activity.....那只能给它设一个唯一的
   210				// affinity(或affinity为null)才行
   211				// Q: 为什么会有这个问题?
   212				// A: 相比之下,SINGLE_INSTANCE的行为是正常的,根本原因是
   213				// 因为前面对taskTop的查找: 对于SINGLE_INSTANCE, 是从整
   214				// 个mHistory去找唯一的一个activity实例. 而对于
   215				// SINGLE_TASK, 则是从上到下根据affinity找\emph{第一个}
   216				// 匹配的task, 考虑这种情况:
   217				// 有A,B,C,D四个activity, 使用相同的affinity, 其中的A是
   218				// SINGLE_TASK, 设当前有两个task, 'A,C,D'和'B'. 然后另外
   219				// 某处startActivity(B), 假设系统找到第一个匹配的
   220				// task是'A,C,D'... 是否要为B生成一个new task?
   221				// 所以根本原因是task的管理还是过于简单, \emph{task的查找方法
   222				// 无法满足SINGLE_TASK语义}.
   223				// 做为workaround,可以通过确保SINGLE_TASK的activity为唯
   224				// 一的affinity来弥补task查找方法的不足.
   225
   226
   227	                        HistoryRecord top = performClearTaskLocked(
   228	                                taskTop.task.taskId, r, launchFlags, true);
   229
   230				// sunway:
   231				// 若top不为null, 说明CLEAR_TOP真的只是 `clear top`, 则需
   232				// 要调用top的onNewIntent
   233
   234
   235	                        if (top != null) {
   236	                            if (top.frontOfTask) {
   237	                                // Activity aliases may mean we use different
   238	                                // intents for the top activity, so make sure
   239	                                // the task now has the identity of the new
   240	                                // intent.
   241	                                top.task.setIntent(r.intent, r.info);
   242	                            }
   243	                            logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
   244	                            deliverNewIntentLocked(top, r.intent);
   245	                        } else {
   246				    // sunway:
   247				    // 若top为null,说明CLEAR_TOP把`基准`activity也clear掉
   248				    // 了...这种情况的发生只有一种可能:`基准`activity是
   249				    // MULTIPLE & SINGLE_TOP, `基准`activity被clear掉后,
   250				    // 需要通过addingToTask标记通知后续代码:该activity需
   251				    // 要重新添加一个新的实例到task中, addingToTask的意思
   252				    // 是:addNewInstanceToTask
   253
   254	                            // A special case: we need to
   255	                            // start the activity because it is not currently
   256	                            // running, and the caller has asked to clear the
   257	                            // current task to have this activity at the top.
   258	                            addingToTask = true;
   259	                            // Now pretend like this activity is being started
   260	                            // by the top of its task, so it is put in the
   261	                            // right place.
   262	                            sourceRecord = taskTop;
   263	                        }
   264	                    } else if (r.realActivity.equals(taskTop.task.realActivity)) {
   265				// sunway:
   266	                        // 我们想要start的是task的root activity, 若使用的intent
   267	                        // 也是相同的, 系统认为我们只是想moveTaskToFront, 所以不
   268	                        // 生新create一个activity,则只是resume这个task的top
   269	                        // activity.
   270				// 实际上,这段代码反映的是launcher的行为: laucher每次点
   271	                        // 击桌面图标时,对同一个图标,使用的intent是一样的,且要启
   272	                        // 动的activity也必然是task的root activity
   273				// 通过模拟launcher的这种行为,我们也可以只是将某个task移
   274	                        // 动到前台,而不做其他任何事
   275
   276
   277
   278	                        // In this case the top activity on the task is the
   279	                        // same as the one being launched, so we take that
   280	                        // as a request to bring the task to the foreground.
   281	                        // If the top activity in the task is the root
   282	                        // activity, deliver this new intent to it if it
   283	                        // desires.
   284	                        if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
   285	                                && taskTop.realActivity.equals(r.realActivity)) {
   286	                            logStartActivity(EventLogTags.AM_NEW_INTENT, r, taskTop.task);
   287	                            if (taskTop.frontOfTask) {
   288	                                taskTop.task.setIntent(r.intent, r.info);
   289	                            }
   290	                            deliverNewIntentLocked(taskTop, r.intent);
   291	                        } else if (!r.intent.filterEquals(taskTop.task.intent)) {
   292	                            // In this case we are launching the root activity
   293	                            // of the task, but with a different intent.  We
   294	                            // should start a new instance on top.
   295	                            addingToTask = true;
   296	                            sourceRecord = taskTop;
   297	                        }
   298	                    } else if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
   299				// sunway:
   300	                        // 这里基本上是NEW_TASK所判断的最后一个条件了: 若
   301	                        // RESET_TASK_IF_NEED设置, 则addingToTask为false,阻止了
   302	                        // 后续的处理. 效果和前面提到的launcher行为类似,但要启动
   303	                        // 的activity不必是root activity.
   304				// 一般情况下,只有launcher会使用这个标志
   305
   306
   307	                        // In this case an activity is being launched in to an
   308	                        // existing task, without resetting that task.  This
   309	                        // is typically the situation of launching an activity
   310	                        // from a notification or shortcut.  We want to place
   311	                        // the new activity on top of the current task.
   312	                        addingToTask = true;
   313	                        sourceRecord = taskTop;
   314	                    } else if (!taskTop.task.rootWasReset) {
   315	                        // In this case we are launching in to an existing task
   316	                        // that has not yet been started from its front door.
   317	                        // The current task has been brought to the front.
   318	                        // Ideally, we'd probably like to place this new task
   319	                        // at the bottom of its stack, but that's a little hard
   320	                        // to do with the current organization of the code so
   321	                        // for now we'll just drop it.
   322	                        taskTop.task.setIntent(r.intent, r.info);
   323	                    }
   324	                    if (!addingToTask) {
   325	                        // We didn't do anything...  but it was needed (a.k.a., client
   326	                        // don't use that intent!)  And for paranoia, make
   327	                        // sure we have correctly resumed the top activity.
   328	                        if (doResume) {
   329	                            resumeTopActivityLocked(null);
   330	                        }
   331	                        return START_TASK_TO_FRONT;
   332	                    }
   333	                }
   334	            }
   335	        }
   336
   337		// sunway:
   338	        // finally we are here....
   339	        // 在三种情况下代码会走到这里:
   340	        // case 1. NEW_TASK为真, 但taskTop为null...说明现在系统里找不到一个已经存在的
   341	        // `密切`的task, 真的需要`new`一个task了
   342	        // case 2. NEW_TASK==true, taskTop!=null, 但addingToTask为真, 即需要在taskTop
   343	        // 上 new activity instance
   344	        // case 3. 根本没有指定NEW_TASK标志,新的activity使用当前的task (使用当前的
   345	        // task并不意味着要直接new activity instance, 因为SINGLE_TOP,
   346	        // CLEAR_TOP...还要考虑)
   347		//
   348	        //
   349	        //
   350	        //String uri = r.intent.toURI();
   351	        //Intent intent2 = new Intent(uri);
   352	        //Slog.i(TAG, "Given intent: " + r.intent);
   353	        //Slog.i(TAG, "URI is: " + uri);
   354	        //Slog.i(TAG, "To intent: " + intent2);
   355	        if (r.packageName != null) {
   356	            // If the activity being launched is the same as the one currently
   357	            // at the top, then we need to check if it should only be launched
   358	            // once.
   359	            HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
   360	            if (top != null && r.resultTo == null) {
   361	                if (top.realActivity.equals(r.realActivity)) {
   362	                    if (top.app != null && top.app.thread != null) {
   363				// sunway:
   364				// case 2,3;
   365				// SINGLE_TOP并非NEW_TASK的专利
   366				// A,B,C (c single top)
   367	                        if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
   368	                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
   369	                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
   370	                            logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);
   371	                            // For paranoia, make sure we have correctly
   372	                            // resumed the top activity.
   373	                            if (doResume) {
   374	                                resumeTopActivityLocked(null);
   375	                            }
   376	                            if (onlyIfNeeded) {
   377	                                // We don't need to start a new activity, and
   378	                                // the client said not to do anything if that
   379	                                // is the case, so this is it!
   380	                                return START_RETURN_INTENT_TO_CALLER;
   381	                            }
   382	                            deliverNewIntentLocked(top, r.intent);
   383	                            return START_DELIVERED_TO_TOP;
   384	                        }
   385	                    }
   386	                }
   387	            }
   388
   389	        } else {
   390	            if (r.resultTo != null) {
   391	                sendActivityResultLocked(-1,
   392	                        r.resultTo, r.resultWho, r.requestCode,
   393	                    Activity.RESULT_CANCELED, null);
   394	            }
   395	            return START_CLASS_NOT_FOUND;
   396	        }
   397
   398	        boolean newTask = false;
   399
   400	        // Should this be considered a new task?
   401	        if (r.resultTo == null && !addingToTask
   402	                && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
   403		    // sunway:
   404		    // case 1, 新建一个task, NEW_TASK
   405
   406	            // todo: should do better management of integers.
   407	            mCurTask++;
   408	            if (mCurTask <= 0) {
   409	                mCurTask = 1;
   410	            }
   411	            r.task = new TaskRecord(mCurTask, r.info, intent,
   412	                    (r.info.flags&ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
   413	            if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
   414	                    + " in new task " + r.task);
   415	            newTask = true;
   416	            addRecentTaskLocked(r.task);
   417
   418	        } else if (sourceRecord != null) {
   419	            if (!addingToTask &&
   420	                    (launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
   421			// sunway
   422			// case 3;
   423			// CLEAR_TOP并非NEW_TASK的专利
   424			// 由于这里没有经过NEW_TASK的 moveToFront, 导致CLEAR_TOP更容易伤
   425			// 到其他task的activity
   426
   427	                // In this case, we are adding the activity to an existing
   428	                // task, but the caller has asked to clear that task if the
   429	                // activity is already running.
   430
   431	                HistoryRecord top = performClearTaskLocked(
   432	                        sourceRecord.task.taskId, r, launchFlags, true);
   433	                if (top != null) {
   434	                    logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
   435	                    deliverNewIntentLocked(top, r.intent);
   436	                    // For paranoia, make sure we have correctly
   437	                    // resumed the top activity.
   438	                    if (doResume) {
   439	                        resumeTopActivityLocked(null);
   440	                    }
   441	                    return START_DELIVERED_TO_TOP;
   442	                }
   443	            } else if (!addingToTask &&
   444	                    (launchFlags&Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
   445			// sunway:
   446
   447			// case 3;
   448			// REORDER_TO_FRONT是非NEW_TASK的专利
   449			// 若当前task的stack为A,B,C; C调用startActivity(B),则执行后的结
   450			// 果为A,C,B;
   451			// 即B会被reorder to front
   452			//
   453			// 到目前为止可以导致onNewIntent的标志:
   454			// 1. SINGLE_INSTANCE, SINGLE_TASK
   455			// 2. MULTIPLE & SINGLE_TOP
   456			// 3. REORDER_TO_FRONT
   457
   458
   459	                // In this case, we are launching an activity in our own task
   460	                // that may already be running somewhere in the history, and
   461	                // we want to shuffle it to the front of the stack if so.
   462	                int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
   463	                if (where >= 0) {
   464	                    HistoryRecord top = moveActivityToFrontLocked(where);
   465	                    logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
   466	                    deliverNewIntentLocked(top, r.intent);
   467	                    if (doResume) {
   468	                        resumeTopActivityLocked(null);
   469	                    }
   470	                    return START_DELIVERED_TO_TOP;
   471	                }
   472	            }
   473	            // An existing activity is starting this new activity, so we want
   474	            // to keep the new one in the same task as the one that is starting
   475	            // it.
   476	            r.task = sourceRecord.task;
   477	            if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
   478	                    + " in existing task " + r.task);
   479
   480	        } else {
   481	            // This not being started from an existing activity, and not part
   482	            // of a new task...  just put it in the top task, though these days
   483	            // this case should never happen.
   484	            final int N = mHistory.size();
   485	            HistoryRecord prev =
   486	                N > 0 ? (HistoryRecord)mHistory.get(N-1) : null;
   487	            r.task = prev != null
   488	                ? prev.task
   489	                : new TaskRecord(mCurTask, r.info, intent,
   490	                        (r.info.flags&ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
   491	            if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
   492	                    + " in new guessed " + r.task);
   493	        }
   494	        if (newTask) {
   495	            EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.task.taskId);
   496	        }
   497	        logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);
   498
   499		// sunway:
   500		//
   501		// 经过九九八十一难,到这里才真正调用onCreate;回想前面的种种, 有些
   502		// activity被kill掉了, 有些被移动到前台并被resume了, 能收到onNewIntent调
   503		// 用都算不错了; 能真正因为startActivity导致onCreate被调用的有多少?
   504
   505	        startActivityLocked(r, newTask, doResume);
   506	        return START_SUCCESS;
   507	    }
   508
   509
   510
   511
   512	private HistoryRecord findTaskLocked(Intent intent, ActivityInfo info) {
   513	        ComponentName cls = intent.getComponent();
   514	        if (info.targetActivity != null) {
   515	            cls = new ComponentName(info.packageName, info.targetActivity);
   516	        }
   517
   518	        TaskRecord cp = null;
   519
   520	        final int N = mHistory.size();
   521	        for (int i=(N-1); i>=0; i--) {
   522	            HistoryRecord r = (HistoryRecord)mHistory.get(i);
   523	            if (!r.finishing && r.task != cp
   524	                    && r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
   525
   526			// sunway:
   527			// launchMode!=SINGLE_INSTANCE这个条件可用避免这种情况:
   528			// 当前mHistory对于同一个affinity有多个task (只有一种可能:一个为正常的task,
   529			// 其他的均为SINGLE_INSTANCE); 通过这个条件判断,可以避免findTask
   530			// 时找到SINGLE_INSTANCE的task (这种task即使找到也不可能往上添加
   531			// 其他activity, 结果还是要新建一个task, 但实际上该
   532			// SINGLE_INSTANCE下面明明有一个可用的`正常`task...最后会导致task越
   533			// 来越多)
   534
   535	                cp = r.task;
   536	                //Slog.i(TAG, "Comparing existing cls=" + r.task.intent.getComponent().flattenToShortString()
   537	                //        + "/aff=" + r.task.affinity + " to new cls="
   538	                //        + intent.getComponent().flattenToShortString() + "/aff=" + taskAffinity);
   539	                if (r.task.affinity != null) {
   540	                    if (r.task.affinity.equals(info.taskAffinity)) {
   541	                        //Slog.i(TAG, "Found matching affinity!");
   542	                        return r;
   543	                    }
   544	                } else if (r.task.intent != null
   545	                        && r.task.intent.getComponent().equals(cls)) {
   546	                    //Slog.i(TAG, "Found matching class!");
   547	                    //dump();
   548	                    //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
   549	                    return r;
   550	                } else if (r.task.affinityIntent != null
   551	                        && r.task.affinityIntent.getComponent().equals(cls)) {
   552	                    //Slog.i(TAG, "Found matching class!");
   553	                    //dump();
   554	                    //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
   555	                    return r;
   556	                }
   557	            }
   558	        }
   559
   560	        return null;
   561	    }
   562
   563
   564	    private final HistoryRecord resetTaskIfNeededLocked(HistoryRecord taskTop,
   565	            HistoryRecord newActivity) {
   566		// sunway:
   567		// resetTaskIfNeeded, 是RESET_TASK_IF_NEED intent flag导致的调用
   568		// launcher在启动activity时会使用NEW_TASK & RESET_TASK_IF_NEED 标志
   569		// 所以该标志和launch有关, 实际上, activity的四个属性:
   570		// 1. CLEAR_TASK_ON_LAUNCH
   571		// 2. FINISH_ON_TASK_LAUNCH
   572		// 3. ALLOW_TASK_REPARENTING
   573		// 4. ALWAYS_RETAIN_TASK_STATE
   574		// 都只是和这个标志有关
   575		// 另外, CLEAR_WHEN_TASK_RESET intent flag 也只和这个标志有关.
   576		// Q: RESET_TASK是干什么?
   577		// Q: IF_NEEDED是什么意思?
   578
   579	        boolean forceReset = (newActivity.info.flags
   580	                &ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
   581
   582		// sunway:
   583		// ACTIVITY_INACTIVE_RESET_TIME 为 30 分钟
   584		// 当task.getInactiveDuration > 30 min时, 表示该task需要被forceReset了, 这也
   585		// 许就是IF_NEEDED的要表达的意思(之一)?
   586
   587
   588	        if (taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME) {
   589	            if ((newActivity.info.flags
   590	                    &ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0) {
   591			// sunway:
   592			// 若root activity设置了这个属性,可以避免空闲30分钟后整个task被
   593			// reset (reset case 1)
   594			// 但对case 2,3 无效
   595	                forceReset = true;
   596	            }
   597	        }
   598
   599		// sunway:
   600		// 所谓 reset task, 是指要从当前task中找出哪些activity需要被reset
   601		// (finish), 主要分为三种情况:
   602		// case 1. 整个task的所有activity被需要被reset
   603		// case 2. 某个或某些activity需要被reset
   604		// case 3. 还要考虑更复杂的ALLOW_TASK_REPARENTING属性
   605
   606	        final TaskRecord task = taskTop.task;
   607
   608	        // We are going to move through the history list so that we can look
   609	        // at each activity 'target' with 'below' either the interesting
   610	        // activity immediately below it in the stack or null.
   611	        HistoryRecord target = null;
   612	        int targetI = 0;
   613	        int taskTopI = -1;
   614	        int replyChainEnd = -1;
   615	        int lastReparentPos = -1;
   616
   617		// sunway:
   618		// 遍历mHistory的所有activity, top --> bottom
   619
   620	        for (int i=mHistory.size()-1; i>=-1; i--) {
   621	            HistoryRecord below = i >= 0 ? (HistoryRecord)mHistory.get(i) : null;
   622
   623	            if (below != null && below.finishing) {
   624	                continue;
   625	            }
   626	            if (target == null) {
   627	                target = below;
   628	                targetI = i;
   629	                // If we were in the middle of a reply chain before this
   630	                // task, it doesn't appear like the root of the chain wants
   631	                // anything interesting, so drop it.
   632	                replyChainEnd = -1;
   633	                continue;
   634	            }
   635
   636	            final int flags = target.info.flags;
   637
   638		    // sunway:
   639		    // 当前activity需要被finish on task launch?
   640		    // IF_NEEDED (之二)?
   641
   642	            final boolean finishOnTaskLaunch =
   643	                (flags&ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
   644	            final boolean allowTaskReparenting =
   645	                (flags&ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
   646
   647	            if (target.task == task) {
   648			// sunway:
   649			// 我们只能reset要reset的task, 其他的task不能碰
   650
   651	                // We are inside of the task being reset...  we'll either
   652	                // finish this activity, push it out for another task,
   653	                // or leave it as-is.  We only do this
   654	                // for activities that are not the root of the task (since
   655	                // if we finish the root, we may no longer have the task!).
   656	                if (taskTopI < 0) {
   657	                    taskTopI = targetI;
   658	                }
   659	                if (below != null && below.task == task) {
   660	                    final boolean clearWhenTaskReset =
   661	                            (target.intent.getFlags()
   662	                                    &Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
   663	                    if (!finishOnTaskLaunch && !clearWhenTaskReset && target.resultTo != null) {
   664	                        // If this activity is sending a reply to a previous
   665	                        // activity, we can't do anything with it now until
   666	                        // we reach the start of the reply chain.
   667	                        // XXX note that we are assuming the result is always
   668	                        // to the previous activity, which is almost always
   669	                        // the case but we really shouldn't count on.
   670	                        if (replyChainEnd < 0) {
   671	                            replyChainEnd = targetI;
   672	                        }
   673	                    } else if (!finishOnTaskLaunch && !clearWhenTaskReset && allowTaskReparenting
   674	                            && target.taskAffinity != null
   675	                            && !target.taskAffinity.equals(task.affinity)) {
   676
   677				// sunway:
   678	                        // 若当前处理的activity是从别的地方`收养`的
   679	                        // (allowTaskReparenting为真,且它的affinity和要reset的
   680	                        // task的affinity不同), 而且它不想死,那么放了它(从哪来的
   681	                        // 回哪去,或者自立门户)
   682	                        //
   683	                        //
   684	                        // If this activity has an affinity for another
   685	                        // task, then we need to move it out of here.  We will
   686	                        // move it as far out of the way as possible, to the
   687	                        // bottom of the activity stack.  This also keeps it
   688	                        // correctly ordered with any activities we previously
   689	                        // moved.
   690	                        HistoryRecord p = (HistoryRecord)mHistory.get(0);
   691	                        if (target.taskAffinity != null
   692	                                && target.taskAffinity.equals(p.task.affinity)) {
   693	                            // If the activity currently at the bottom has the
   694	                            // same task affinity as the one we are moving,
   695	                            // then merge it into the same task.
   696	                            target.task = p.task;
   697	                            if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
   698	                                    + " out to bottom task " + p.task);
   699	                        } else {
   700	                            mCurTask++;
   701	                            if (mCurTask <= 0) {
   702	                                mCurTask = 1;
   703	                            }
   704	                            target.task = new TaskRecord(mCurTask, target.info, null,
   705	                                    (target.info.flags&ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
   706	                            target.task.affinityIntent = target.intent;
   707	                            if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
   708	                                    + " out to new task " + target.task);
   709	                        }
   710	                        mWindowManager.setAppGroupId(target, task.taskId);
   711	                        if (replyChainEnd < 0) {
   712	                            replyChainEnd = targetI;
   713	                        }
   714	                        int dstPos = 0;
   715	                        for (int srcPos=targetI; srcPos<=replyChainEnd; srcPos++) {
   716	                            p = (HistoryRecord)mHistory.get(srcPos);
   717	                            if (p.finishing) {
   718	                                continue;
   719	                            }
   720	                            if (DEBUG_TASKS) Slog.v(TAG, "Pushing next activity " + p
   721	                                    + " out to target's task " + target.task);
   722	                            task.numActivities--;
   723	                            p.task = target.task;
   724	                            target.task.numActivities++;
   725	                            mHistory.remove(srcPos);
   726	                            mHistory.add(dstPos, p);
   727	                            mWindowManager.moveAppToken(dstPos, p);
   728	                            mWindowManager.setAppGroupId(p, p.task.taskId);
   729	                            dstPos++;
   730	                            if (VALIDATE_TOKENS) {
   731	                                mWindowManager.validateAppTokens(mHistory);
   732	                            }
   733	                            i++;
   734	                        }
   735	                        if (taskTop == p) {
   736	                            taskTop = below;
   737	                        }
   738	                        if (taskTopI == replyChainEnd) {
   739	                            taskTopI = -1;
   740	                        }
   741	                        replyChainEnd = -1;
   742	                        addRecentTaskLocked(target.task);
   743	                    } else if (forceReset || finishOnTaskLaunch
   744	                            || clearWhenTaskReset) {
   745
   746				// sunway:
   747	                        // 经过若干次循环后,确定了要reset的activity的范围,开始reset
   748	                        // 其中, CLEAR_WHEN_TASK_RESET和CLEAR_TOP行为相似,都使
   749	                        // 该activity以上被finish,但前者会限制上限为当前task
   750
   751	                        // If the activity should just be removed -- either
   752	                        // because it asks for it, or the task should be
   753	                        // cleared -- then finish it and anything that is
   754	                        // part of its reply chain.
   755	                        if (clearWhenTaskReset) {
   756	                            // In this case, we want to finish this activity
   757	                            // and everything above it, so be sneaky and pretend
   758	                            // like these are all in the reply chain.
   759	                            replyChainEnd = targetI+1;
   760	                            while (replyChainEnd < mHistory.size() &&
   761	                                    ((HistoryRecord)mHistory.get(
   762	                                                replyChainEnd)).task == task) {
   763	                                replyChainEnd++;
   764	                            }
   765	                            replyChainEnd--;
   766	                        } else if (replyChainEnd < 0) {
   767	                            replyChainEnd = targetI;
   768	                        }
   769	                        HistoryRecord p = null;
   770	                        for (int srcPos=targetI; srcPos<=replyChainEnd; srcPos++) {
   771	                            p = (HistoryRecord)mHistory.get(srcPos);
   772	                            if (p.finishing) {
   773	                                continue;
   774	                            }
   775	                            if (finishActivityLocked(p, srcPos,
   776	                                    Activity.RESULT_CANCELED, null, "reset")) {
   777	                                replyChainEnd--;
   778	                                srcPos--;
   779	                            }
   780	                        }
   781	                        if (taskTop == p) {
   782	                            taskTop = below;
   783	                        }
   784	                        if (taskTopI == replyChainEnd) {
   785	                            taskTopI = -1;
   786	                        }
   787	                        replyChainEnd = -1;
   788	                    } else {
   789	                        // If we were in the middle of a chain, well the
   790	                        // activity that started it all doesn't want anything
   791	                        // special, so leave it all as-is.
   792	                        replyChainEnd = -1;
   793	                    }
   794	                } else {
   795	                    // Reached the bottom of the task -- any reply chain
   796	                    // should be left as-is.
   797	                    replyChainEnd = -1;
   798	                }
   799
   800	            } else if (target.resultTo != null) {
   801	                // If this activity is sending a reply to a previous
   802	                // activity, we can't do anything with it now until
   803	                // we reach the start of the reply chain.
   804	                // XXX note that we are assuming the result is always
   805	                // to the previous activity, which is almost always
   806	                // the case but we really shouldn't count on.
   807	                if (replyChainEnd < 0) {
   808	                    replyChainEnd = targetI;
   809	                }
   810
   811	            } else if (taskTopI >= 0 && allowTaskReparenting
   812	                    && task.affinity != null
   813	                    && task.affinity.equals(target.taskAffinity)) {
   814			// sunway:
   815			// 如果其它task中有从当前task`过继`过去的activity, 那么也会reset
   816			// 它,或者会把它move回当前task (根据IF_NEEDED)
   817
   818	                // We are inside of another task...  if this activity has
   819	                // an affinity for our task, then either remove it if we are
   820	                // clearing or move it over to our task.  Note that
   821	                // we currently punt on the case where we are resetting a
   822	                // task that is not at the top but who has activities above
   823	                // with an affinity to it...  this is really not a normal
   824	                // case, and we will need to later pull that task to the front
   825	                // and usually at that point we will do the reset and pick
   826	                // up those remaining activities.  (This only happens if
   827	                // someone starts an activity in a new task from an activity
   828	                // in a task that is not currently on top.)
   829			Slog.e("sunway", "AMS:206");
   830	                if (forceReset || finishOnTaskLaunch) {
   831			    Slog.e("sunway", "AMS:208");
   832	                    if (replyChainEnd < 0) {
   833	                        replyChainEnd = targetI;
   834	                    }
   835	                    HistoryRecord p = null;
   836	                    for (int srcPos=targetI; srcPos<=replyChainEnd; srcPos++) {
   837	                        p = (HistoryRecord)mHistory.get(srcPos);
   838	                        if (p.finishing) {
   839	                            continue;
   840	                        }
   841				Slog.e("sunway", "AMS:218");
   842	                        if (finishActivityLocked(p, srcPos,
   843	                                Activity.RESULT_CANCELED, null, "reset")) {
   844	                            taskTopI--;
   845	                            lastReparentPos--;
   846	                            replyChainEnd--;
   847	                            srcPos--;
   848	                        }
   849	                    }
   850	                    replyChainEnd = -1;
   851	                } else {
   852			    Slog.e("sunway", "AMS:229");
   853	                    if (replyChainEnd < 0) {
   854	                        replyChainEnd = targetI;
   855	                    }
   856	                    for (int srcPos=replyChainEnd; srcPos>=targetI; srcPos--) {
   857	                        HistoryRecord p = (HistoryRecord)mHistory.get(srcPos);
   858	                        if (p.finishing) {
   859	                            continue;
   860	                        }
   861	                        if (lastReparentPos < 0) {
   862	                            lastReparentPos = taskTopI;
   863	                            taskTop = p;
   864	                        } else {
   865	                            lastReparentPos--;
   866	                        }
   867	                        mHistory.remove(srcPos);
   868	                        p.task.numActivities--;
   869	                        p.task = task;
   870	                        mHistory.add(lastReparentPos, p);
   871	                        if (DEBUG_TASKS) Slog.v(TAG, "Pulling activity " + p
   872	                                + " in to resetting task " + task);
   873	                        task.numActivities++;
   874	                        mWindowManager.moveAppToken(lastReparentPos, p);
   875	                        mWindowManager.setAppGroupId(p, p.task.taskId);
   876	                        if (VALIDATE_TOKENS) {
   877	                            mWindowManager.validateAppTokens(mHistory);
   878	                        }
   879	                    }
   880	                    replyChainEnd = -1;
   881
   882	                    // Now we've moved it in to place...  but what if this is
   883	                    // a singleTop activity and we have put it on top of another
   884	                    // instance of the same activity?  Then we drop the instance
   885	                    // below so it remains singleTop.
   886	                    if (target.info.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
   887	                        for (int j=lastReparentPos-1; j>=0; j--) {
   888	                            HistoryRecord p = (HistoryRecord)mHistory.get(j);
   889	                            if (p.finishing) {
   890	                                continue;
   891	                            }
   892	                            if (p.intent.getComponent().equals(target.intent.getComponent())) {
   893	                                if (finishActivityLocked(p, j,
   894	                                        Activity.RESULT_CANCELED, null, "replace")) {
   895	                                    taskTopI--;
   896	                                    lastReparentPos--;
   897	                                }
   898	                            }
   899	                        }
   900	                    }
   901	                }
   902	            }
   903
   904	            target = below;
   905	            targetI = i;
   906	        }
   907
   908	        return taskTop;
   909		// sunway:
   910		// 总结:
   911		// RESET_TASK是指有些activity会被finish,有些会被move (ALLOW_TASK_REPARENTING)
   912		// IF_NEEDED因为有三层含义:
   913		//   1. task inactive超过30 min后会被CLEAR_TASK_ON_LAUNCH
   914		//   2. 有些activity若设置了FINISH_ON_TASK_LAUNCH属性或有
   915		//      CLEAR_WHEN_TASK_RESET intent flag, 会被finish
   916		//   3. 有些activity若设置了ALLOW_TASK_REPARENTING, 会被moved, 或者被finish
   917		// 一般只有launcher会 reset task
   918	    }
#+END_EXAMPLE
****** analysis
#+BEGIN_EXAMPLE
      startActivityUnchecked(HistoryRecord r, HistoryRecord sourceRecord, ...)
      // r is the activity to be start; sourceRecord is the activity that issues the startActivity, for notification, service..., sourceRecord is null
        if (sourceRecord==null):
	// This activity is not being started from another...  in this case, always start new task
	  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
        else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
	// original Activity is SINGLE_INSTANCE launchMode
	  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
	else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
	         or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
	  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;

	if (r.resultTo != null && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
	  // NEW_TASK is set, but requires Activity result, so just cancel the result
          sendActivityResultLocked(-1,...)

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0 ...):
	  HistoryRecord taskTop=findTaskLocked(intent, r.info);
	     // find the target task complies with r, according to affinity, compnent, .... from mHistory, top --> bottom
	     // findTaskLocked will return the top activity in any existing task matching the given intent
	     // typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered
	     // How taskAffinity is null? if activity's taskAffinity property is set to "" (see `Notification`), then it's taskAffinity will be set to null
	  if (taskTop!=null):
	  // found an target task, may try to foreground the task
	  // else jump to endif of ..launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK..
	    HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);
	    // find the current top activity's task
	    if (curTop.task != taskTop.task):
	    // target task is in background, will try to foreground target task, unless ...
	      boolean callerAtFront = sourceRecord == null  || curTop.task == sourceRecord.task;
	      // whether the startActivity action is issued from an obscured activity
	      // we prefer that an obscured activity can't moveTaskToFront
	      if (callerAtFront):
	        moveTaskToFrontLocked(taskTop.task, r);
		// move all the activities belonging to target task to the top of mHistory
	      if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0):
	        // reset task if need, another dragon~
	        taskTop = resetTaskIfNeededLocked(taskTop, r);
            if ((launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
                 or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
                 or r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
	      HistoryRecord top = performClearTaskLocked(taskTop.task.taskId, r, launchFlags, true);
	      // clear the *mHistory* from top to the target *artivity*
	      // note that: if target is successfully moved to front beforehand,
	      // clearTask will actually only clear the target task, instead of the whole mHistory
	        // for each activity from mHistory.top downto target activity, finish it!
		// for the target activity, if it has the SINGLE_TOP flag, do nothing and return it, else finish it!
	      if (top!=null):
	        // target activity has the SINGLE_TOP flag, thus not finished
		deliverNewIntentLocked(top, r.intent);
	      else:
	        // target activity has been finished, place a new one on the task
		addingToTask = true;  // future actions will be taken if addingToTask is true, which means we need add the target activity to target task
		                      // addingToTask means `startNewActivity`
	    else if (r.realActivity.equals(taskTop.task.realActivity)): // else of clear_top
	      // In this case the top activity on the task is the
              // same as the one being launched, so we take that
              // as a request to bring the task to the foreground.
	      if (!r.intent.filterEquals(taskTop.task.intent)):
	      // we are trying to restart target task's root activity, but with a different intent, we should start a new instance on top
	      // else, do nothing (since the target task is already brought to front)
	        addingToTask = true;
            // if CLEAR_TOP ends here
	    if (!addingToTask):
	    // new instance should not be started, e.g. CLEAR_TOP will SINGLE_TOP; starting target task's root activity with the same intent
	      resumeTopActivity()
	      return;
	// if NEW_TASK end here

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// when we reach here:
	// 1. activity w/o NEW_TASK
	// 2. activity w/ NEW_TASK but doesn't found the target task

        HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
	if (top.realActivity.equals(r.realActivity)):
	  if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
	    or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
            or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
	      resumeTopActivityLocked(null);
	      deliverNewIntentLocked(top, r.intent);
	      return;
	if (!addingToTask  && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
	  // case 2.
          r.task = new TaskRecord(mCurTask, r.info, intent,...)
	else if (!addingToTask && (launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0):
	  // case 1.
	  HistoryRecord top = performClearTaskLocked(sourceRecord.task.taskId, r, launchFlags, true);
	  if (top != null):
	    deliverNewIntentLocked(top, r.intent);
	    return;
	else if (!addingToTask && (launchFlags&Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0):
	  // case 1.
	  // In this case, we are launching an activity in our own task
          // that may already be running somewhere in the history, and
          // we want to shuffle it to the front of the stack if so.
	  int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
	    // if sourceRecord.task is not the top task in mHistory, return -1, else return the index of r in mHistory
	  HistoryRecord top = moveActivityToFrontLocked(where);
          deliverNewIntentLocked(top, r.intent);
          resumeTopActivityLocked(null);
	  return;
        // if NEW_TASK ends here

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// all launchMode and flag is considered, if control flow still reach here ... startActivity!
	startActivityLocked(r, newTask, doResume);
	return;
#+END_EXAMPLE
      simplified procedure:

#+BEGIN_EXAMPLE
      if NEW_TASK:
        if found target task:
          moveTaskToFront()
	  clearTop
	  starting with the same intent with target task?
      single_top
      new task
      clear_top
      reorder_to_front
      startActivity
#+END_EXAMPLE

      To summarize:
      1. FLAG\_ACTIVITY\_NEW\_TASK may be set implicitly, e.g.
	 - starting activity from service, notification ..., where sourceRecord==null
	 - target activity is SINGLE\_INSTANCE, SINGLE\_TASK
	 - sourceRecord is in SINGLE\_INSTANCE
      2. FLAG\_ACTIVITY\_NEW\_TASK has two means:
	 1. if target task exists: `moveTaskToFront`
	 2. if not: start new task
      3. moveTaskToFront must meet 3 conditions:
	 1. NEW\_TASK
	 2. target task exists and is in background
	 3. sourceRecord is null or sourceRecord is the top activity,
	    that is, only notification, service and curTop activity can move a background task to front through NEW\_TASK
      4. CLEAR\_TOP
	 CLEAR\_TOP will clear all the activities in *mHistory* on top of target activity, so  CLEAR\_TOP should be used in two ways:
	 1. in most cases, CLEAR\_TOP should be used in conjunction with NEW\_TASK, so that, before clear top, the target task is moveTaskToFront,
	    thus the succeeding CLEAR\_TOP will be restrict to the target task
	 2. CLEAR\_TOP can be used w/o NEW\_TASK, but make sure the sourceRecord is the foreground task, or else all the activities on top of it will
	    be finished.
      5. REORDER\_TO\_FRONT
	 1. should *ONLY* be called by foreground task, or else the flag will not take effect
	 because CLEAR\_TOP condition is judged before REORDER\_TO\_FRONT, so if CLEAR\_TOP is set, REORDER\_TO\_FRONT is ignored
	 What's more: REORDER\_TO\_FRONT will only take effect if NEW\_TASK
      6. deliverNewIntent
	 deliverNewIntent will occurs in two cases:
	 1. SINGLE\_TOP, w/ or w/o NEW\_TASK
	 2. REORDER\_TO\_FRONT
***** Launcher & Task 
***** resetTaskIfNeededLocked
      FLAG\_ACTIVITY\_NEW\_TAKS && FLAG\_ACTIVITY\_RESET\_TASK\_IF\_NEEDED will trigger resetTaskIfNeededLocked

      Typically, only launcher will set those two flags to resetTaskIfNeededLocked, but we still can set those flags manually to
      trigger resetTaskIfNeededLocked

#+BEGIN_EXAMPLE
      resetTaskIfNeededLocked
        // whether the launching activity has the property `CLEAR_TASK_ON_LAUNCH`
        boolean forceReset = (newActivity.info.flags &ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
	// if the target task has been inactive for ACTIVITY_INACTIVE_RESET_TIME (30 min)
	// and the target's *root* activity doesn't have the ALWAYS_RETAIN_TASK_STATE property, also set forceReset to true
	// that is what the phrase `IfNeed` means
	if (taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME):
          if ((newActivity.info.flags &ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0):
            forceReset = true;
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	foreach HistoryRecord of the target task in mHistory (from top --> bottom):
	  // should the activity be finished on task launch?
	  boolean finishOnTaskLaunch = (flags&ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
	  // should the activity has ALLOW_TASK_REPARENTING property?
          boolean allowTaskReparenting = (flags&ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
	  // should the activity clear it's top when task reset?
          boolean clearWhenTaskReset = (target.intent.getFlags()&Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
	  if (!finishOnTaskLaunch && !clearWhenTaskReset && allowTaskReparenting
	      && !target.taskAffinity.equals(task.affinity)):
	    // if the activity is ALLOW_TASK_REPARENTING and it's affinity is different with target task ...
	    // that is , the activity is reparent from somewhere else ... , so detach it, instead of kill it.
	    // however, ALLOW_TASK_REPARENTING can only overide forceReset: finishOnTaskLaunch and clearWhenTaskReset can still kill it.
	    // ALLOW_TASK_REPARENTING is flexible: it can be attached/detached from a TO-BE-RESET task.
	  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	  if (forceReset || finishOnTaskLaunch || clearWhenTaskReset ):
	    if (clearWhenTaskReset):
	      // finish all the actvities of the target task above the launching activity.
	    finish current activity
	  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
          else if (taskTopI >= 0 && allowTaskReparenting && task.affinity.equals(target.taskAffinity)):
	    // We are inside of another task...  if this activity has an affinity for our task, then either remove it if we are
            // clearing or attach it to our task
#+END_EXAMPLE

      To summarize:
      - CLEAR\_TASK\_ON\_LAUNCH property will clear the task when re-launch the task from launcher, (only meaningful for root activity)
      - if task has been inactive for 30 min, it will also be CLEAR\_TASK\_ON\_LAUNCH, unless RETAIN\_TASK\_STATE property is set
	RETAIN\_TASK\_STATE is closely related to the 30 min thresh-hold, (only meaningful for root activity)
      - FINISH\_ON\_TASK\_LAUNCH property vs. CLEAR\_WHEN\_TASK\_RESET intent flag (not only meaningful for root activity)
      - ALLOW\_TASK\_REPARENTING is flexible: it can be detached/attached from a TO-BE-RESET task

***** affinity
      2010-11-15
      1. One task's affinity is the root activity's task affinity.
      2. activity's task affinity, if not specified in manifest, is set to the activity's package name, by default.
      3. activity's task affinity can be *null*:
	 if activity's taskAffinity property is set to "" (see [[Notification]]), then it's taskAffinity will be set to null
      4. Affinity will affect activity in two ways:
	 1. When activity A calls startActivity(B) to start B activity, B will be
	    put into the same task as A, but if the calling intent set the flag
	    FLAG_NEW_TASK
	    2. if there is already ONE task whose affinity is identical with B's
               affinity (including the origina task), B will be put into that
               task. so, if orig task's affinity is the same as B's affinity,B will still be placed into the orig task
	    3. if there is no task whose affinity is identical with B's
               affinity, B will be put into a new task. So the FLAG_NEW_TASK is
               a little ambiguous, maybe it should be named
               FLAG_NEW_OR_EXIST_TASK.
	 2. If A call startActivity(B) to start B activity, and the calling
	   task's affinity is same as B's affinity, and B has set the activity
	   property: AllowTaskReparenting, then B will be `reparented` to the
	   calling task.
***** launch mode
****** standard
****** singleTop
****** singleInstance
****** singleTask
***** Intent flag
****** FLAG_ACTIVITY_NEW_TASK
****** FLAG_ACTIVITY_CLEAR_TOP
****** FLAG_ACTIVITY_SINGLE_TOP
****** FLAG_ACTIVITY_REORDER_TO_FRONT
****** FLAG_ACTIVITY_RESET_TASK_IF_NEEDED [launch related]
****** FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET [launch related]
       stronger CLEAR_TOP?
****** FLAG_ACTIVITY_MULTIPLE_TASK
****** FLAG_ACTIVITY_FORWARD_RESULT
****** FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
***** Properties
****** FINISH_ON_TASK_LAUNCH  [launch related]
****** CLEAR_TASK_ON_LAUNCH  [launch related]
       activity must be taks's root activity
****** ALLOW_TASK_REPARENTING
****** ALWAYS_RETAIN_TASK_STATE
***** moveTaskToBack
***** isTaskRoot
*** Service							    :service:
**** startService
#+BEGIN_EXAMPLE
	startServiceLocked()
	   retrieveServiceLocked()
	     checkComponentPermission()
	   bringUpServiceLocked()
	      if serviceRecord.app and app.thread is not null,
	           sendServiceArgs()
	              thread.scheduleServiceArgs()
	                  service.onStartCommand()
	       else
	           getProcessRecord(appName)
	           if app or thread is not null (process is ready)
	               realStartService()
	                  thread.scheduleCreate..
	           else
	               startProcess()
	                  start ActivityThread
	               add service to mPendingSer..
#+END_EXAMPLE

#+BEGIN_EXAMPLE
	New process:
	  ActivityThread::attach()
	     AMS::attachApplication()
	        foreach mPendingServices:
	           realStartService()
	                thread.scheduleCreate..
#+END_EXAMPLE
**** bindService &  unbindService
***** ServiceConnection
      ServiceConnection itself is binder proxy, which only implement one method:
#+BEGIN_EXAMPLE
      void connected(ComponentName name, IBinder service) throws RemoteException;
#+END_EXAMPLE
      through ServiceConnection.connected(), service can notify the *client* about service bound/unbound.

      so the client must implement the ServiceConnection stub, actually, ActivityThread maintains one
#+BEGIN_EXAMPLE
      HashMap<Context, HashMap<ServiceConnection, ServiceDispatcher>> mServices
#+END_EXAMPLE
      while ServiceDispatcher maintains the ServiceConnection stub. AMS will notify the client directly through ServiceConnection stub in ActivityThread
      To summarize:
	 1. ServiceConnection is a stub implement in ActivityThread, AMS use it to notify client
	 2. ServiceConnection are maintained by ActivityThread, Activity.destroy will not affect the connection.
***** bindService
#+BEGIN_EXAMPLE
      int bindService(IServiceConnection connection,...);; connection is the binder proxy supplied by client
        mServiceConnections.put(binder, c); ;; AMS save the proxy for later use
         if ((flags&Context.BIND_AUTO_CREATE) != 0):  ;; if BIND_AUTO_CREATE flag is set, will bring up the service
           bringUpServiceLocked(s, service.getFlags(), false);
	     ;; may start process --> create service --> start service ...
           return 0;
         if (s.app != null && b.intent.received):
	   connection.connected(s.name, b.intent.binder); ;; notify client by onServiceConnected
#+END_EXAMPLE
***** unbindService
#+BEGIN_EXAMPLE
        mServiceConnections.remove(connection);
        s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());
	if ((c.flags&Context.BIND_AUTO_CREATE) != 0):
          bringDownServiceLocked(s, false);
	    if (!force && r.startRequested):  // startService will set r.startRequested to true, that why unbindService won't bring down service if it is
	                                      // started by startService
              return;
	    if (r.connections.size() > 0):
	      for each connection:
                if ((cr.flags&Context.BIND_AUTO_CREATE) != 0):  // if there is still any other connection that is BIND_AUTO_CREATE,
		                                                  // skip bring down the service
                  return;
	      for each connection:
                c.conn.connected(r.name, null);   // service is about to be brought down, notify all connections through onServiceDisconnected
	  r.app.thread.scheduleStopService(r);
#+END_EXAMPLE
	To summarize:
	  unbindService will normally stop service, unless:
	     1. the connection is not a BIND_AUTO_CREATE connection
	     2. service is started by startService
	     3. that are still other BIND_AUTO_CREATE connections bound to the service
**** ServiceRecor
d12/28/10 8:12 pm
similar with AMS::HistoryRecord. mainly save the r.ap and r.app.thread so as to interact with the service's process. .  But there is no correspondant like ActivityRecord in ActivityThread, since service needn't interqact with WMS, and it's life cycle is quite simple. (create, start, stop)
**** DONE STICKY service
     SCHEDULED: <2011-06-01 Wed> CLOSED: [2011-07-18 Mon 17:21]
     - State "DONE"       from "DOING"      [2011-07-18 Mon 17:21]
     STICKY mainly make sense when process has crashed due to uncaught exception.
     see also [[Android Process Crash and Restart]]
*** Broadcast							  :broadcast:
**** OrderedBroadcast
***** AbortBroadcast()
***** GetResult..()
***** priority
      broadcast receiver's intent filter's `priority` will be used to by the AMS to determine the order in which the broadcast is send to
***** SetResult..()
**** DONE [#C] <<<protected-broadcast>>>
     CLOSED: [2011-08-01 Mon 09:19]
     - State "DONE"       from "TODO"       [2011-08-01 Mon 09:19]
     PACKAGE_REMOVED/PACKAGE_ADDED/BOOT_COMPLETED are all protected-broadcasts, only the process with "system" uid can send the broadcast
#+BEGIN_EXAMPLE
     broadcastIntentLocked()
       if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) :
         // Always okay.
       else:
         if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) :
	   throw new SecurityException(msg);
#+END_EXAMPLE
     To summarize:
     `protected-broadcasts` means `those broadcasts can only be sent by SYSTEM,PHONE,SHELL or root`

**** DONE [#B] <<<SendBroadcast>>>
     CLOSED: [2011-02-15 Tue 19:37]
     - State "DONE"       [2011-02-15 Tue 19:37]
     12/28/10 8:11 pm
     every call to sendBroadcast will init a new receiver instance.
#+BEGIN_EXAMPLE lang:c
     AMS:broadcastIntentLocked()
       // find out who will recv this broadcast
       if intent.getComponent():
         receivers.add(r);
       else:
         if !Intent.FLAG_RECEIVER_REGISTERED_ONLY:
	   receivers=PM.queryIntentReceivers();
	 registeredReceivers = ReceiverResolver.queryIntent(); ;;ReceiverResolver is a in-memory storage that stores runtime-registered receivers
       // now, `receivers` stores receivers from PM, `registeredReceivers` stores receivers from ReceiverResolver
       if !ordered:
         BroadcastRecord r=new BroadcastRecord(registeredReceivers);
	 mParallelBroadcasts.add(r);
         add/update mStickyBroadcasts if the broadcast is STICKY 
         ;; note: mStickyBroadcasts is only re-broadcasted on registerReceiver()
	 scheduleBroadcastsLocked()
	   sendMessage(BROADCAST_INTENT_MSG);
	     processNextBroadcast();
	       foreach BroadcastRecord in mParallelBroadcasts:
	         foreach receiver in BroadcastRecord:
		   deliverToRegisteredReceiver();
		     ;; make sure receiver has the requiredPermission imposed by the sender,  e.g. PERMISSION_BOOT_COMPLETED, sender can imposed a
		     ;; requiredPermission through sendBroadcast(intent,requiredPermission)
		     if r.requiredPermission!=null:
		       checkComponentPermission(r.requiredPermission,filter.receiverList.pid, filter.receiverList.uid, -1);
		     ;; make sure the sender has the requiredPermission imposed by the receiver's filter
		     if filter.requiredPermission != null:
		       checkComponentPermission(filter.requiredPermission,r.callingPid, r.callingUid, -1);
		     performReceive();
		       if app.thread !=null:
		         app.thread.scheduleRegisteredReceiver();
			   ReceiverDispatcher.performReceive() ;; for registeredReceivers, receiver class are identified by ReceiverDispatcher (which is send to
			                                       ;; AMS during registerReceiver()
			     new Args() {
			       run():
			         receiver.onReceive();
			         if ordered:
			           AMS:finishReceiver(); ;; not called here
			     }
			     H.post(Args);
         registeredReceivers=null; ;; since registeredReceivers is broadcasted already as mParallelBroadcasts, it should not be merged with receivers
       ;; if  !ordered, registeredReceivers are broadcasted all at once, without TIMEOUT consideration! SO, registeredReceivers in non-ordered broadcast
       ;; will never cause ANR!
       ;; if ordered, both registeredReceivers and receivers are merged in a single list, so that both registeredReceivers and receivers are broadcasted in
       ;; order
       merge_into_one_receiver_list();
       scheduleBroadcastsLocked();
         sendMessage();
	   processNextBroadcast();
	     r=OrderedBroadcast.get(0);
	     if r.nextReceiver>r.receivers.size():
	       removeMessages(BROADCAST_TIMEOUT_MSG);
	     r.receiverTime=now();
	     if current receiver is the first one of r:
	       sendMessageAtTime(BROADCAST_TIMEOUT_MSG,r.receiverTime+BROADCAST_TIMEOUT);
	     if current receiver is a registeredReceivers:
	       scheduleBroadcastsLocked(get Current Receiver); ;; direct call
	     else:
	       if app!=null:
	         app.thread.scheduleReceiver();
		   handlerReceiver()
		     receiver = (BroadcastReceiver)cl.loadClass(component).newInstance(); ;; for static receivers, receivers are identified by component name
		     receiver.onReceive(context.getReceiverRestrictedContext(),...)
		     AMS:finishReceiver(); ;; notify AMS that it can process next broadcast.
	       else:
	         startProcess();
		 mPendingBroadcast=r; ;; mPendingBroadcast will broadcasted when process is ready and attached to AMS

        BROADCAST_TIMEOUT_MSG's handle Message() will check whether r.receiverTime is updated, if so, that means one of Ra's receiver has returned, so
	handler will not cause an ANR
#+END_EXAMPLE
   To summarize:
   1. dynamic registered receiver
      *the same BroadcastReceiver instance is used for Multi-broadcast*
      - in non-ordered broadcast
	1. doesn't cause ANR
	2. all dynamic receivers are invoked in parallel manner (by ActivityThread's handler), i.e. one receiver's onReceive() will not block another
	   receiver's correspondent.
      - in ordered broadcast
	ANR and parallel/serial manner is the same as static registered receivers

   2. static registered receiver
      *every time broadcast is received, a new static registered receiver instance is initiated*
      - always invoked in a serial manner, i.e. one static receiver's onReceive() will block other static receiver's correspondents, no matter
	whether it is ordered. (maybe because static receiver's process is not assumed to be running, AMS need a simplified way to start all the processes)
   3. for a certain broadcast, the ANR timing begins when the first receiver is about to be handled, and ends when the last receiver has been handled,
      and, what's most important: take one broadcast contains 10 static receivers for example, _the total ANR timing can be 10*10s at most_, instead of 10s.
      because although the BROADCAST_TIMEOUT is set to be 10s, every receiver will update r.receiverTime in AMS.finishReceiver(), and the timeout handler
      will issues an ANR only when *now-r.receiverTime > BROADCAST_TIMEOUT (10s)*

   4. sendBroadcast will make sure both the sender and the receiver has been granted the requiredPermission imposed by the counterpart.
      see also protected-broadcast for another sendBroadcast limitation.

   5. Intent.FLAG_RECEIVER_REGISTERED_ONLY
**** BroadcastRecord
**** Sticky
*** ProcessRecord
**** processName
*** DONE AppDeathRecipient
    CLOSED: [2011-08-02 Tue 13:39]
    - State "DONE"       from ""           [2011-08-02 Tue 13:39]
    see also [[binder's death]]
    see also [[Android Process Crash and Restart]]
*** ActivityThread
    :PROPERTIES:
    :CUSTOM_ID: @ActivityThread
    :END:
    ActivityThread stands for the client (contract to AMS) side *process*.
    Actually, the class itself is not a Thread at all. It is a normal java class, and has ONE main(), which act as the entry point of a java process.
    ActivityThread.main()
#+BEGIN_EXAMPLE
    Looper.prepare()
    ActivityThread thread = new ActivityThread();
    thread.attach(false);
    Looper.loop();
#+END_EXAMPLE
    that is ,
    - ActivityThread.main() will start loop in the main thread, the looper is the so-call `mainLooper`
    - thread.attach() will establish reverse connection (AMS --> ActivityThread) with AMS, (set IApplicationThread IBinder to AMS.app.thread),
      so that AMS can use the IApplicationThread to interact with ActivityThread, e.g. scheduleResumeaCtivity, scheduleLaunchActivity.
      AMS use [[@AppDeathRecipient]] to reset app.thread to null, which means the process has gone.
** Android coredump
** Android IMF
** DONE [#A] Android Testing
SCHEDULED: <2011-03-14 Mon>
- State "DONE"       [2011-03-13 Sun 18:01]
  see [[@Instrumentation]]
  there are 3 different testing in android
     - Testing using JUnit's Test{Runner,Suite,Case}
     - Testing using AndroidTest{Runner,Suite,Case}
     - Testing using InstrumentationTest{Runner,Suite,Case}
*** JUnit TestRunner
there are classes such as `TestSuite` and `TestCase`, but there is no `TestRunner` in android.
if u want to kick off a JUnit testing, there are 2 alternative ways:
 1. write some `TestCase` and run the application as `JUnit TestCase` in eclipse or using cmd like `java -cp jnit.jar com.sunway.test`,
    Note that: the testing will run in the PC side instead of android emulator or device.
 2. in the android application code, create a TestSuite instance manually, and add some TestCase to it, then invoke TestSuite.runTest() manually.
    (similar with AndroidTestRunner)
*** AndroidTestRunner
AndroidTestRunner, in contract with JUnit TestRunner, it maintain a Context instance (need to call AndroidTestRunner.setContext(context) to set it
manually, then any underlying AndroidTestCase can call `getContext()` to get the Context instance.

Q:how to kick off the testing?
A:manually...

if u use AndroidTestRunner, u must setup the testing manually, e.g. new AndroidTestRunner, new TestSuite, add AndroidTestCase to suite, and invoke
runner.runTest() at last.
*** InstrumentationTestRunner
InstrumentationTestRunner, in contract with AndroidTestRunner, it itself is a Instrumentation, and thus the Context is set automatically by
Instrumentation.init() when AMS calls bindApplication().
InstrumentationTestCase can call `getInstrumentation()` to get the Instrumentation instance.

InstrumentationTestRunner extends *Instrumentation*, thus the testing can be kick-off by Instrumentation.onCreate(), in fact:
#+BEGIN_EXAMPLE
    InstrumentationTestRunner.onCreate()
      mTestRunner = getAndroidTestRunner();
      mTestRunner.setContext(getTargetContext());
      mTestRunner.setInstrumentation(this);
      mTestRunner.setTest(testSuiteBuilder.build());       ;;testSuiteBuilder will scan all the testCase automatically
      mTestRunner.addTestListener();
      start(); ;; Instrumentation.start() will start another thread and call onStart()
        onStart();
	  mTestRunner.runTest();
#+END_EXAMPLE
that is , InstrumentationTestRunner actually is not a TestRunner, what it does is two things:
  1. reply on Instrumentation.onCreate() to kick of the testing
  2. reply on inner AndroidTestRunner to run all the test.

#+BEGIN_EXAMPLE
    AndroidTestRunner.runTest()						o
      for (TestCase testCase : mTestCases):
        setContextIfAndroidTestCase(testCase, mContext, testContext);
        setInstrumentationIfInstrumentationTestCase(testCase, mInstrumentation); ;; set mInstrumentation to InstrumentationTestCase so that they can make use
	                                                                         ;; of it.
        testCase.run(mTestResult);
#+END_EXAMPLE
*** class hierachy graph
#+BEGIN_EXAMPLE
     	            	       	       	       	      -+----------+
	     						       | TestCase |
                        				      -+-----+----+
	     						      	     |
     	     for unit test	     -+----------------------+---------------------+
 	       	    -+------------------------+--------------------+ 		       	   |
	     	     |		      -+------+--------+	   |   	      -+-----------+-----------+
	     	     |		       |AndroidTestCase|	   |	       |InstrumentationTestCase|
	     	     |		      -+------+--------+       	   |   	      -+-----------+-----------+
	     	     |		      	      |		       	   |	      		   |
	     	     |		   -+---------+---------+      	   |	      -+-----------+-----------+
	     	     |		    |	   		|      	   |	       |       	  	       |
	     	     |	 -+---------+------+  -+--------+------+   | -+--------+-------+       	     .....
	     	     |	  |ProviderTestCase|   |ServiceTestCase|   |  |ActivityTestCase|
	     	     |	 -+----------------+  -+---------------+   | -+--------+-------+
	     	     |			       	                   |           |
  	     | 	       	       	       	      -+-----------+-----------+----------------------+    for functional test
	     	     |			       	       |  	   |	       -+---------------------+---------------+
   	     | 	       	       	  -+-----------+---------+ |	       	| -+------------------+-------------+ |
	     	     |		           |ActivityUnitTestCase | |	       	|  | ActivityInstrumentationTestCase| |
	     	     |		       	  -+---------------------+ |	       	| -+--------------------------------+ |
		    -+---------------------------------------------+   	       -+-------------------------------------+
#+END_EXAMPLE

   - AndroidTestCase
     - AndroidTesCase.setContext()/getContext()
     - AndroidTestCase doesn't interact with AMS, e.g. ServiceTestCase has methods like startService(), but as against to
       Instrumentation.startActivitySync(), ServiceTestCase.startService() only call through to mService.start(), mContext is mainly used to access
       resource?
   - InstrumentationTestCase
     - InstrumentationTestCase can call getInstrumentation() and getContext() (mContext is set by AMS automatically)
     - ActivityInstrumentationTestCase is for functional testing: the activity under test will be create using the system infrastructure
       (by calling mInstrumentation.launchActivity) will call Instrumentation.startActivitySync to launch the activity, and perform functional testing
     - ActivityUnitTestCase  is for unit testing: the activity under test will be create with minimal connection to the system infrastructure, and you can
       invoke setActivityConetxt() to inject a mock context.
** Animation
*** TranslateAnimation
** DONE ANR
   CLOSED: [2011-06-13 Mon 10:52]
   - State "DONE"       [2011-06-13 Mon 10:52]
   see [[Strict Mode]]
*** DONE [#A] Broadcast ANR					  :broadcast:
    SCHEDULED: <2011-02-15 Tue> CLOSED: [2011-02-15 Tue 19:41]
    - State "DONE"       [2011-02-15 Tue 19:41]
    see SendBroadcast
*** [#B] KeyEvent ANR                                            :keyevent:
    key event is dispatched by AMS one by one, that is ,until prev key event is
    dispatched, AMS will wait to dispatching next key event, until ANR occurs.

    when key event is dispatched to ViewRoot, ViewRoot will
    diliverToViewHierachy, then notify WMS that key is dispatched.

    KeyWaiter says:
#+BEGIN_HTML
<pre lang="java" line="1">
    long keyDispatchingTimeout = 10 * 1000;
</pre>
#+END_HTML
*** DONE Service ANR						    :service:
    CLOSED: [2011-06-13 Mon 10:52]
    - State "DONE"       [2011-06-13 Mon 10:52]
AMS calls:
#+BEGIN_EXAMPLE
1. sendServiceArgs()
     bumpServiceExcuting
       sendMessageAtTime(SERVICE_TIMEOUT) (20s)
       after SERVICE_TIMEOUT (20s), appNotResponding() will be call, and ANR occurs
     app.thread.scheduleServiceArgs()
     activityThread will call service.onStart()
     activityThread calls mWindowSession.serviceDone() to tell AMS that onStart returns. then the SERVICE_TIMEOUT msg is removed

2. realStartService()
     bumpServiceExecuting()
	sendMessageAtTime(SERVICE_TIMEOUT) (20s)
     app.thread.scheduleCreateService()
     activityThread will call service.onCreate()
     activityThread calls mWindowSession.serviceDone()
#+END_EXAMPLE
** Ant & android
** ANT and android project
** Application
see also [[Context.getApplicationContext()]]
*** persistent application
see also [[Android Process Crash and Restart]]
1. An application is persistent only when it is [[system application]]; 3rd application will never be taken as persistent.
2. application with `manifest.xml/application/android:persistent=true' is
   considered to be persistent.
3. when the persistent application is killed (crash, killPid ...), AMS will always restart it.
4. persistent application will be launched during system boot, before the BOOT_COMPLETED is broadcasted
** AppWidget
** ASEC
   :PROPERTIES:
   :CUSTOM_ID: @ASEC
   :END:
   Android Security Executable Cache
*** dm_crypt
** Ashmem
** DONE AsyncQueryHandler && loader                                 :coding:
CLOSED: [2012-09-08 周六 16:12] SCHEDULED: <2012-09-03 Mon>

** Audio
*** AudioFlingerService
**** Track
**** PlaybackThread
**** MixerThread
*** AudioPolicyService
*** AudioTrack
*** MediaServer
*** Higher level
**** MediaPlayer
**** MediaRecorder
**** SoundPool
**** AudioService
**** AudioRecord
*** MediaPlayerService
** Bionic libc
*** Prelink
** ClassLoader
*** DexClassLoader
*** PathClassLoader
*** Context.getClassLoader
    see also [[Context.getClassLoader]]
** ContentObserver

** ContentProvider , ContentResover & SQLite
*** ContentProvider.openFile() & ContentProvider.openInputStream()
*** DONE `withYieldAllowed` how to work?                             :todo:
CLOSED: [2013-01-14 Mon 15:57]
- State "DONE"       from "TODO"       [2013-01-14 Mon 15:57]
[2013-01-14 Mon 11:57]
[[http://stackoverflow.com/questions/9599809/does-yieldifcontendedsafely-lose-the-benefits-of-a-transaction][Does yieldIfContendedSafely() lose the benefits of a transaction?]]

From stackoverflow:

Q:

I have a long-running operation which I perform in a background thread. As it is
important for the operation to either complete successfully or not at all, I am
wrapping the entire operation in a transaction.

Aspects of the UI need read-only access to the database during this time. To
avoid blocking the UI, I am experimenting with inserting calls to
db.yieldIfContendedSafely() in the main loop of the background operation.

This does what I want in that the UI is no longer blocked, but it's not
completely clear to me if this is risking a loss of data integrity.

The javadoc for yieldIfContendedSafely() says:

    Temporarily end the transaction to let other threads run.  The transaction
    is assumed to be successful so far. Do not call setTransactionSuccessful
    before calling this. When this returns a new transaction will have been
    created but not marked as successful. This assumes that there are no nested
    transactions (beginTransaction has only been called once) and will throw an
    exception if that is not the case.

Does this mean that my long-running operation is actually being committed to the
database in separate chunks, or is the overall transaction maintaining enough
state to commit the whole lot in one go at the end, thus preserving
data-integrity?

A:

    Does this mean that my long-running operation is actually being committed to
    the database in separate chunks

Yes. Within yieldIfContendedSafely(), Android calls setTransactionSuccessful(),
endTransaction(), and begins a new transaction -- committing your statements in
the process. There is no mechanism to rollback the "real" transaction after it
ends.

This behavior only occurs if there is another thread waiting on the database,
otherwise yieldIfContendedSafely() does nothing.

I checked this with the following scenario. I started two threads: one inserted
data into a table using a transaction, another read data out of the same
table. The transaction didn't call setTransactionSuccessful() so normally
everything is rolled back at the end, leaving the table empty. I added a call to
yieldIfContendedSafely(), and afterwards the table was not empty and had data
from the transaction.
** DONE [#A] Context
   SCHEDULED: <2011-06-02 Thu> CLOSED: [2011-06-13 Mon 16:57]
   - State "DONE"       [2011-06-13 Mon 16:57]
   Context can be used to:
   - Access application's resource and manipulate files in /data/data/xxx (through Context.mPackageInfo)
   - Context.mainThread (ActivityThread) is a interface exposed by ActivityThread to Android component, so that Context can interact with various
     system services on behalf of ActivityThread (permission checking, IApplicationThread, ...)
   - call through to many system services, e.g. AMS, PMS

   Context ( or ContextImpl ) is the facade of the running Context, it mainly represents:
     1. mPackageInfo -- the PackageInfo, represents the data, e.g. ApplicationInfo, ActivityInfo, data file (resource, asset, db ...), ClassLoader, ...
     2. mMainThread -- the ActivityThread, represents the process, e.g. looper, ApplicationThread

#+END_EXAMPLE
*** Context class hierachy
#+BEGIN_EXAMPLE
	     				           Context
 					       	      |
				   -+-----------------+---------------+
				    |	     			      |
				    |		       	       	      |
	    		     ContextWrapper    	                 ContextImpl
                              |		    		      ^    	       	       	       	    
	    -+------------------+---+---------+-		      |
	     |			| 	      |		 	      |
	     |			| 	      |		 	      | composition
  ContextThemeWrapper  Service     Application      	      |
 	    |	  |    	       	|      	      |		 	      |
	    |	 -+-------------+-------------+----------+------------+
  Activity

#+END_EXAMPLE
    Actually, Activity,Receiver,Service all use ContextImpl as the common implementation of the Context, but instead of inherit from ContextImpl,
    they implement from the ContextWrapper, whose `attachBaseContext()` will compose the ContextImpl as mBase, to which ContextWrapper will delegates
    all of the context functions.
*** How ContextImpl is initialized
    Take `startActivity` for example
#+BEGIN_EXAMPLE
     1	    AMS::startActivityMayWait()
     2	      ActivityInfo aInfo = ActivityThread.getPackageManager().resolveIntent().activityInfo;
     3	      startActivityLocked(...,aInfo,...)
     4	        HistoryRecord r=new HistoryRecord(...,aInfo,...)
     5		startActivityUncheckedLocked(r,...)
     6		  ...
     7		  app.thread.scheduleLaunchActivity(...,r.info,...)
     8		    // ActivityThread
     9		    ActivityRecord ar=new ActivityRecord();
    10		    ar.activityInfo=info;
    11		    performLaunchActivity(r,...)
    12		      ar.packageInfo=getPackageInfo(r.activityInfo)
    13		      // classLoader is obtained from packageInfo , or aInfo
    14		      Activity activity=mInstrumentation.newActivity(ar.packageInfo.getClassLoader(),intent.getComponent,...)
    15		      ContextImpl context=new ContextImpl(); // GOTCHA!
    16		      context.init(ar.packageInfo,r.token,this)
    17		        // mainThread=this
    18	  	        mPackageInfo = packageInfo;
    19			mResources = mPackageInfo.getResources(mainThread);
    20			mMainThread = mainThread;
    21		      activity.attach(context,...)
    22		        // call ContextWrapper.attachBaseContext() to compose the ContextImpl to mBase
    23		        attachBaseContext(context);
    24		      ....
    25		      call onCreate, onStart ...
#+END_EXAMPLE
*** Context.createPackageContext()
     Return a new Context object for the given application name.  This
     Context is the same as what the named application gets when it is
     launched, containing the same resources and class loader.  Each call to
     this method returns a new instance of a Context object; Context objects
     are not shared, however they share common state (Resources, ClassLoader,
     etc) so the Context instance itself is fairly lightweight.

     As mentioned before, Context represents both data and process. Can createPackageContext() create a Context object that we can use to run in
     other package's process? No!

#+BEGIN_EXAMPLE
     1	     createPackageContext():
     2	        ActivityThread.PackageInfo pi =  mMainThread.getPackageInfo(packageName, flags);
     3	        ContextImpl c = new ContextImpl();
     4		// notice `init` take mMainThread as the mMainThread of the created context, thus, the context still runs in the caller's process.
     5	        c.init(pi, null, mMainThread, mResources);
     6		return c;
#+END_EXAMPLE
*** Restricted Context
*** Context.getClassLoader()
*** Context.getApplicationContext()
    return an process global `Application` instance.
    - We can inherit the `Application` class and set it to the `Application` field in AndroidManifest.xml, so that getApplicationContext() can return our own `Application` instance.
    - since `Application` extends ContextWrapper and has been init with a ContextImpl, it is a context of the full functionality.
      You can use it as a `persistent` Context.
    
    *Note:*
    getApplicationContext() return a context:
    - with full functionality
    - with less data dependency than activty/service/receiver
    Thus it makes it meaningful for us to use application context instead of
    activty/service/receiver as the CONTEXT if we need to STORE the context to
    somewhere else, e.g. in a static place, since activty/service/receiver is
    volatile, and often has dependency with mass of data.

**** onCreate()
     Called when the application is stopping.  There are no more application
     objects running and the process will exit.  <em>Note: never depend on
     this method being called; in many cases an unneeded application process
     will simply be killed by the kernel without executing any application
     code.
     If you override this method, be sure to call super.onTerminate().
**** onTerminate()
**** onConfigurationChanged()
**** onLowMemory()
*** ContextImpl.getOuterContext()
    OuterContext means ContextImple's `outer` context, e.g. activity or service
** Dalvik
*** dalvik-cache
:PROPERTIES:
:CUSTOM_ID: @dalvik-cache
:END:
/data/dalvik-cache
** dbus
** Debug related
*** hprof & MAT
    - 在代码中生成
      Debug.dumpHprofData()
    - 使用信号on-demand生成
#+BEGIN_EXAMPLE
    $ chmod 777 /data/misc -R
    $ ps # 找到进程号
    $ kill -10 进程号 # 发送SIGQUIT信事信号给该进程，此时生成hprof信息
    $ ls /data/misc/*.hprof 
#+END_EXAMPLE
    - 为了能让MAT识别android的hprof格式,需要用hprof-conv转换一下
*** traceview
**** dmtracedump
     dmtracedump -g out.png -t 30% test.trace
*** hierachyviewer
*** Thread.dumpStack()
*** logcat
adb shell setprop log.tag.mytag verbose
*** adb am start
*** monkey
*** tombstone

** DONE [#C] FileObserver
   SCHEDULED: <2011-02-10 Thu> CLOSED: [2011-02-10 Thu 14:55]
   - State "DONE"       [2011-02-10 Thu 14:55]
     FileObserver relies on `inotify`
     it mainly use jni to call inotify_init() to init the inotify_fd,
     then call inotify_add_watch(path) to add watch a file path,
     and at last init one ObserverThread, and run

#+BEGIN_EXAMPLE
     while (true):
       read(inotify_fd);
       env->CallVoidMethod() ;; call ObserverThread.onEvent() to notify FileObserver
#+END_EXAMPLE

** HAL								    :ARCHIVE:
** important files
*** device
    1. data/system/packages.xml
    2. /mnt/secure/asec
    3. /mnt/asec
    4. /system/etc/permissions/platform.xml
    5. /system/etc/security/cacerts.bks
    6. /data/dalvik-cache
    7. /data/property
    8. /system/build.prop
    9. /data/system/registered_services/android.accounts.AccountAuthenticator.xml
    10. /data/system/registered_services/android.content.SyncAdapter.xml
*** src
    1. framework/base/core/res
    2. framework/base/core/jni
    3. system/core/init
    4. system/core/include/private/android_filesystem_config.h
    5. build/target/product/security/
** init
*** init.rc
*** DONE System init
    CLOSED: [2011-03-01 Tue 11:20]
    - State "DONE"       [2011-03-01 Tue 11:20]
    init will start some daemon, service_manager, media_service. Then call app_process to call zygoteInit.java to start zygote.
    ZygoteInit.java, first will fork and start system_server, then listen on one local socket through runSelectLoopMode().
    SystemServer.java's main() will firstly load 'android_server'.so and call
    it's init1() to start binderThreadPool and call SystemServer's init2(),
    which will init an ServerThread and start some java service like AMS, WMS.

    system_server is setuid to `system` uid.

    Note:
    zygote will keep running with `root` uid, so that zygote can setuid/gid/groups on newly forked progress, so that new java progress will run with
    proper uid/gid/groups
*** Zygote init
    app_process --> app_main.cpp: framework/base/cads/app_process
    ZygoteInit.java: framework/base/core/java/com/android/internal/os
#+BEGIN_EXAMPLE
    app_process::main()
      runtime.start("com.android.internal.os.ZygoteInit", startSystemServer);
       ZygoteInit.main()
         registerZygoteSocket();
	 startSystemServer();
	   pid = Zygote.forkSystemServer();
	   if (pid == 0):
             handleSystemServerProcess(parsedArgs);
	       closeServerSocket(); // for newly forked system_server process, close zygote socket inherited from parent
	       RuntimeInit.zygoteInit(parsedArgs.remainingArgs);
	         zygoteInitNative();
		   proc->startThreadPool();
		   invokeStaticMain(startClass, startArgs); // startClass is "com.android.server.SystemServer"
		     SystemServer.java:main()
		       System.loadLibrary("android_servers");
		       init1(args); // init1 is native method in android_servers.so
		         android_server_SystemServer_init1(JNIEnv* env, jobject clazz)
			   system_init();
			     runtime->callStatic("com/android/server/SystemServer", "init2");
			       SystemServer.java:init2()
			         Thread thr = new ServerThread();
				   // start any system service, e.g. ams, wms..
				   // prepare the looper and loop in it.
				   // the looper is TAKEN as the `main` looper  of the `system` process
				 thr.start();
			     ProcessState::self()->startThreadPool();
			     IPCThreadState::self()->joinThreadPool();
	 runSelectLoopMode();
#+END_EXAMPLE
    Q: Why SystemServer.java will call android_server.so:init1(), which will call SystemServer.java:init2()? instead of call init2() directly?
    A: android_server.so:init1() is needed because it will call `joinThreadPool` to put the process into ThreadPool. There is no java correspondent of
       joinThreadPool()

** Input Method Framework
** IntentSender
   :PROPERTIES:
   :CUSTOM_ID:       @IntentSender
   :ATTACH_DIR_INHERIT: t
   :END:
   see [[@PendingIntent]]
** Launcher							    :ARCHIVE:
** Looper & Message & Message Queue
   see [[@ActivityThread]]
**** Message Queue
****** DONE [#A] Idle Handler
       SCHEDULED: <2011-02-09 Wed> CLOSED: [2011-02-09 Wed 17:57]
       - State "DONE"       [2011-02-09 Wed 17:57]
#+BEGIN_EXAMPLE
       MessageQueue.next()
         while true:
	   msg=pullNextLocked(now)
	     foreach msg:
	       if now>msg.when:
	         return msg
	   if msg==null:
	     return msg
	   else:
	     idlers = mIdleHandlers.toArray();
	   foreach idler in idlers:
	     keep=idler.queueIdle();
	     if !keep:
               mIdleHandlers.remove(idler);
           if (mMessages != null):
             this.wait(mMessages.when-now); // if there is a message, but it's not up to date, wait until it is up to date
           else:
             this.wait();  // no message, wait until new message arrives
           // MessageQueue.enqueueMessage() will call this.notify()
#+END_EXAMPLE
******* <<<Idler>>>
	Idler class is used by ActivityThread when resumeActivity. when resumeActivity returns, ActivityThread will put one Idler in the MessageQueue,
	when the queue is idle (activity is ready), Idler.queueIdle() will be called, which will notify AMS to finish activities registered before.

**** DONE Message.obtain() & Message.recycle()
     SCHEDULED: <2011-05-28 Sat> CLOSED: [2011-05-27 Fri 14:55]
     - State "DONE"       [2011-05-27 Fri 14:55]
     - Message.obtain():
#+BEGIN_EXAMPLE
     synchronized (mPoolSync) {
         if (mPool != null) {
             Message m = mPool;
             mPool = m.next;
             m.next = null;
             return m;
         }
     }
     return new Message();
#+END_EXAMPLE
     - Message.recycle():
#+BEGIN_EXAMPLE
     synchronized (mPoolSync) {
         if (mPoolSize < MAX_POOL_SIZE) {
             clearForRecycle();
	       what = 0;
               obj = null;
               when = 0;
               target = null;
               callback = null;
	       ...
             next = mPool;
             mPool = this;
         }
     }
#+END_EXAMPLE
     - sendMessage():
#+BEGIN_EXAMPLE
       sendMessageDelayed(msg,delayMillis)
         sendMessageAtTime(msg, uptimeMillis)
	   queue.enqueueMessage(msg, uptimeMillis);
	     if (msg.when != 0):
               throw new AndroidRuntimeException(msg + " This message is already in use.");
	       msg.when = uptimeMillis;  // important
	       if (p == null || when == 0 || when < p.when): // reorder messages in queue according to msg.when
                 msg.next = p;
                 mMessages = msg;
                 this.notify(); // notify waiting
	       else:
                 Message prev = null;
                 while (p != null && p.when <= when) {
                   prev = p;
                   p = p.next;
                 }
                 msg.next = prev.next;
                 prev.next = msg;
                 this.notify();
#+END_EXAMPLE
     - Looper.loop():
#+BEGIN_EXAMPLE
       while true:
         Message msg=queue.next(); // might block
	 msg.target.dispatchMessage(msg);
	 msg.recycle()
#+END_EXAMPLE
       Note:
       Looper.loop() will recycle message automatically, thus *NEVER* invoke Message.recycle() manually!  Or else `message is already in use` exception
       will be thrown. Because: when u call recycle() manually, the message will finally be recycled twice, after the 2nd recycle(), the message list will
       have circular reference, and the succeeding obtainMessage() will definitly obtain the *same* message *again and again*

     To summarize:
     - Generally, message can't be re-used, except for the situation that `Message is firstly recycled by Message.recycle() and then reused by
       Message.obtain()`, or else any other form of Message re-use will cause exception.
     - Loop will invoke Message.recycle() automatically, thus never call it manually.
**** misc
***** Looper.setMessageLogging()
***** DONE <<<HandlerThread>>>
      CLOSED: [2011-02-24 Thu 15:00]
      - State "DONE"       [2011-02-24 Thu 15:00]
      Handy class that starting a thread with a looper, u can call HandlerThread.getLooper() to get the looper.
      note that getLooper() will block until the looper is ready.

***** Messenger
      see [[@Messenger]]
** LowMemoryKiller
*** oom adj
** misc
*** DONE [#A] bitmap recycle
    SCHEDULED: <2011-02-10 Thu> CLOSED: [2011-02-10 Thu 11:46]
    - State "DONE"       [2011-02-10 Thu 11:46]
    Bitmap.recycle() will call nativeRecycle() to release native memory used by Skia. But, we don't need call it directly, since Bitmap.finalize()
    will call it.
*** android 尺寸单位 (px,pt,dp,sp..)
** MountService
   :PROPERTIES:
   :CUSTOM_ID: @MountService
   :END:
   see [[@NativeDaemonConnector]]
   see [[@vold]]
#+BEGIN_EXAMPLE
		       -+------socket-------+
	   	        |	     	    |
	       	       	|    	     	    V
   MountService-----connector  	       	   vold <-----netlink-----> kernel
	   	       	^	     	    |
	   	       	|	     	    |
	       	       -+------binder-------+
#+END_EXAMPLE

** NativeDaemonConnector
   :PROPERTIES:
   :CUSTOM_ID: @NativeDaemonConnector
   :END:
   see [[@MountService]]
   android use NativeDaemonConnector to interactive native daemons, including
   - vold
   - netd
   - installd
** NDK								    :ARCHIVE:
** Notification
   :PROPERTIES:
   :CUSTOM_ID: Notification
   :END:
   Notification intent will use FLAG_NEW_TASK implicitly, and the target activity *should* use blank string ("") as affinity, to reduce the risk that
   startActivity from notification falls into an existing task;

*** "" as taskAffinity
    see `startActivityUnchecked`

    activity with "" as taskAffinity will have it taskAffinity set to null; So that `findTaskLocked` in `startActivityUnchecked` will not try to find
    any existing task according to taskAffinity, instead, it will try to find the target task by the condition

                        *the target task's starting intent must be identical with the calling intent*

    which impose a stronger restriction on the target task searing, and thus reduce conflict.

    Different activities with the same "" taskAffinity will not be placed in the same task when start activty with NEW_TASK, since their starting intent is
    different.

** DONE PendingIntent
   CLOSED: [2011-03-07 Mon 15:58]
   - State "DONE"       [2011-03-07 Mon 15:58]
   :PROPERTIES:
     :CUSTOM_ID: @PendingIntent
   :END:
   see [[PendingIntent @ Permission][Permission]]
   see [[@IntentSender]]
   A description of an Intent and target action to perform with
   it. Instances of this class are created with getActivity(Context, int,
   Intent, int), getBroadcast(Context, int, Intent, int), getService(Context,
   int, Intent, int); the returned object can be handed to other applications so
   that they can perform the action you described on your behalf at a later
   time.

   By giving a PendingIntent to another application, you are granting it the
   right to perform the operation you have specified as if the other application
   was yourself (with the same permissions and identity (*uid*) ). As such, you
   should be careful about how you build the PendingIntent: often, for example,
   the base Intent you supply will have the component name explicitly set to one
   of your own components, to ensure it is ultimately sent there and nowhere
   else.

   A PendingIntent itself is simply a reference to a token maintained by the
   system describing the original data used to retrieve it. This means that,
   even if its owning application's process is killed, the PendingIntent itself
   will remain usable from other processes that have been given it. If the
   creating application later re-retrieves *the same kind of PendingIntent* (same
   operation, same Intent action, data, categories, and components, and same
   flags), it will receive a PendingIntent representing the same token if that
   is still valid, and can thus call cancel() to remove it.

   *Note*:
   if u want to generate different PendingIntent for different intents, make
   sure the PendingIntent's request_code is different, or intents are different.

   Intent equality:
   That is, if intents' action, data, type, class, and categories are the same.
   This does *not* compare any extra data included in the intents.

** PowerManagment
*** WakeLock
** Preference
   - State "CANCELED"   from "DOING"      [2011-07-26 Tue 16:25]
*** PreferenceActivity
- PreferenceActivity extends ListActivity
- Basic usage:
  1. setContentView(resId)
	 optional, if called, resId must contain a ListView with id="@+android/List"
  2. PreferenceActivity.addPreferencesFromResource()
- Basically, PreferenceActivity is an Activity contains a ListView, and it delegate anything about the ListView to a inner member: PreferenceManager
*** PreferenceManager
    PreferenceManager is a utility functional object
    - PreferenceManager extends NULL
    - PreferenceManager mainly does two things:
      1. maintain the underlying SharedPreference
      2. maintain the PreferenceScreen (inflate PreferenceScreen from xml)
*** PreferenceScreen
    PreferenceScreen is one of the two core concepts of Preference  (another is Preference)
    *NOTE*: PreferenceScreen vs. ListAdapter

    - PreferenceScreen extends PreferenceGroup
    - it maintains a PreferenceGroupAdapter (extends ListAdapter), which is shown in the ListView
      The adapter will map the Preference to ListView item.
*** Preference
    *NOTE*: Preference vs. ListView item
    - when Preference is changed (through Preference.notifyChanged()), it will eventually
      invoke PreferenceScreen.PreferenceGroupAdapter.notifyDatasetChanged(), thus update the ListView.
    - when PreferenceGroupAdapter decides to getView(), it will eventually call through to Preference.getView()->Preference.onBindView()
    - Preference's builtin setTitle()/setSummary() will call notifyChanged() automatically, thus cause onBindView()
*** KeyEvent dispatch
#+BEGIN_EXAMPLE
    ListView.onItemClicked
      Preference.performClick
        Preference.mOnClickListener
	if not intercepted:
	  PreferenceActivity.OnPreferenceTreeClickListener
	if not intercepted && mIntent != null:
	  startActivity(mIntent)
#+END_EXAMPLE
*** To summurize:
    PreferenceScreen vs. ListAdapter
    Preference vs. ListItem
** ServiceManager
see also [[binder]]
** SharedPreference
** StatusBar & SystemUI
** DONE Strict Mode
SCHEDULED: <2011-06-13 Mon> CLOSED: [2011-06-13 Mon 15:24]
- State "DONE"       [2011-06-13 Mon 15:24]
  see [[ANR]]
- use BlockGuard (StrictMode) to detect possible ANR caused by file/network IO in mainThread
** Surfacing							    :ARCHIVE:
** System Property
1. android property is by no means related to java property.
2. android SDK doesn't provide public java API to access android property; However, internal java API is available
3. android SDK provide java API to manipulate java property.
*** android property
- adb shell getprop / adb shell setprop
- there is NO java api to set/get android property
- only root can set android property
**** internal
main() @ init.c  // in system/core/init
property_init()
property_set("ro.hardware", hardware);
property_set(...)
**** reference
#+BEGIN_QUOTE
Every property has a name and value. Both name and value are text
strings. Property is heavily used in Android to record system setting
or exchange information between processes. The property is globally
visible in the whole system. Every process can get/set a property. On
system initialization, Android will allocates a block of shared memory
for storing the properties. This is done in “init” daemon whose source
code is at: device/system/init. The “init” daemon will start a
Property Service. The Property Service is running in the process of
“init” daemon. Every client that wants to SET property needs to
connect to the Property Service and send message to Property
Service. Property Service will update/create the property in shared
memory. Any client that wants to GET property can read the property
from the shared memory directly. This promotes the read
performance. The client application can invoke the API function
exposed from libcutils to GET/SET a property. The source code of
libcutils locates at: device/libs/cutils.

The API function is:
int property_get(const char *key, char *value, const char *default_value);
int property_set(const char *key, const char *value);

The libcutils is in turn calling the __system_property_xxx function in
libc to get a property from the shared memory. The source code of libc
is at: device/system/bionic. The Property Service is also in turn
calling the __system_property_init function in libc to initiate the
shared memory for properties. When starting the Property Service will
load the default properties from below files:

/default.prop
/system/build.prop
/system/default.prop
/data/local.prop

The properties are loaded in the above order. Later loaded properties
will override the previous values. After those properties are loaded,
the last loaded is the persistent properties which is persisted in
/data/property. Special Properties

If a property’s name begins with “ro.”, then this property is treated
as a read-only property. Once set, the value of the property can’t be
changed.

If a property’s name begins with “persist.”, then when setting this
property, the value will be written to /data/property, too.

If a property’s name begins with “net.”, when when setting this
property, the “net.change” property will be set automatically to
contain the name of the last updated property. (It’s tricky. The
netresolve module uses this property to track if there is any change
on the net.* properties.)

The property “ctrl.start” and “ctrl.stop” is used to start and stop a
service. Every service must be defined in /init.rc. On system startup,
the init daemon will parse the init.rc and start the Property
Service. Once received a request to set the property of “ctrl.start”,
the Property Service will use the property value as the service name
to find the service and then start the service. The service starting
result is then put to the property “init.svc.<service name>”. The
client application can poll the value of that property to determine
the result. Android toolbox

The Android toolbox provides two applets: setprop and getprop to get
and set properties. The usage is:

getprop <property name>
setprop <property name> <property value> 

Java
The java application can use the System.getProperty() and System.setProperty() function to Get and Set the property.

Action

By default the set property will only cause "init" daemon to write to
shared memory, it won't execute any script or binary. But you can add
your actions to correspond to property change in init.rc. For example,
in the default init.rc, you can find.

# adbd on at boot in emulator
on property:ro.kernel.qemu=1

start adbd
on property:persist.service.adb.enable=1

start adbd
on property:persist.service.adb.enable=0

stop adbd

So if you set persist.service.adb.enable to 1, the "init" daemon knows
it has actions to do, then it will start adbd service.
#+END_QUOTE
*** java property
System.getProperty() / System.setProperty()
** system_server
*** ServerThread
** Toast
** Tools
*** aapt
*** adb
**** dumpsys
**** am
     am start
     am startservice
     am broadcast
     am instrument
     am monitor
**** pm
     pm list instrumentation
     pm setInstallLocation
     pm getInstallLocation
**** sendevent
*** aidl
**** in,out
     - void foo(in Foo foo,out Bar bar)
     - void foo(String s) // s is `in` implicitly, since String is immutable
     - void foo(Integer i) // i in `in` implicitly, since Integer is also immutable
     - void foo(Foo foo) // compile error, must specify in/out/inout for foo
**** oneway
     - oneway int foo();
*** android
*** ddms
*** decompile
**** dex2jar
**** jd-gui
**** apktool
*** hierachyviewer
*** layouopt
*** sign
**** jarsigner
**** signapk.jar
**** keytool
*** traceview
**** set traceview buffer size in ddms
     .android/ddms.cfg:
       profilerBufferSizeMb=100
** Uri
*** uri encoding
** DONE Util [4/4]                                                  :coding:
CLOSED: [2012-09-14 Fri 10:37]
- [X] LruCache
- [X] Pair
- [X] SparseArray
- [X] TimingLogger
** vold
   :PROPERTIES:
   :CUSTOM_ID: @vold
   :END:
   *android's alternative to linux udev*
   src location: /system/vold
** Widget
*** ActivityGroup
*** AdapterView
*** Layout
**** LinearLayout
**** FrameLayout
**** GridLayout
**** CANCELED RelativeLayout
     - State "CANCELED"   from "DOING"      [2011-07-18 Mon 17:43]
*** ListView
**** convertView
**** Adapter
***** getView
***** ViewBinder
***** ViewHolder
***** DONE [#A] NotifyDatasetChanged()
      CLOSED: [2011-02-24 Thu 13:33]
#+BEGIN_EXAMPLE
     1	      BaseAdapter.NotifyDatasetChanged()
     2	        AdapterView.AdapterDataSetObserver.onChanged()
     3		  mDataChanged=true;
     4		  AbsList.requestLayout()
     5		    if !mBlockLayoutRequests && !mInLayout: // mInLayout makes sure that NotifyDatasetChanged() in getView() will not cause infinite loop
     6		      super.requestLayout();
     7		      ...
     8		      ViewRoot.requestLayout()
     9		        ViewRoot.performTraversals()
    10			  deco.measure()
    11			  deco.layout()
    12	                    ListView.onLayout()
    13			      mInLayout=true;
    14			      ListView.layoutChildren()
    15			        remove_all_children
    16			        makeAndAddView()
    17			          if !mDataChanged:
    18				    reuse_previous_views
    19				  else:
    20				    obtainView()
    21				      Adapter.getView()
    22			        mDataChanged=false;
    23			  deco.draw();
#+END_EXAMPLE
**** cacheColorHint
**** FastScroller
**** DONE Android BUG: NotifyDatasetChanged() when scrolling
      CLOSED: [2011-06-13 Mon 17:16]
      - State "DONE"       [2011-06-13 Mon 17:16]
      - BUG表现: 在 getView() 中调用 NotifyDatasetChanged(), 当滑动 ListView 时, onItemClick 无法响应
      - 原因:
	1. NotifyDatasetChanged: see also  [[NotifyDatasetChanged]]
	   其中最重要的三点:
	   1. NotifyDatasetChanged 会在开始时将 mDataChanged 置位, 然后调用 AbsListView.requestLayout
	   2. AbsListView.requestLayout 在 *mBlockLayoutRequests* 时什么也不做! ( 重要 )
	   3. ListView layoutChildren 完成后会将 mDataChanged 复位
	2. AbsListView TouchEvent dispatch
	   当 mDataChanged 置位时, touch up 事件不会被处理, 因为 mDataChanged 置位, 表示 数据已改变, 而该 ListView 还没有被重新 layout, 这
	   时应该阻止 itemClick 事件, 因为用户点击时看到的数据很可能并不是真正的数据
	3. ListView scroll
	   上面提到的一重要的数据是 mBlockLayoutRequests, 这个值表示 ListView 当前禁止 requestLayout.
	   当发生 scroll 事件时, ListView 调用 trackMotionScroll(incrementalDeltaY, incrementalDeltaY); 处理滚动,
	   该函数大致是:
#+BEGIN_EXAMPLE
     1		   trackMotionScroll()
     2		     mRecycler.addScrapView(start,count); // cache 滑动出去的 view
     3		       mRecyclerListener.onMovedToScrapHeap(scrap);
     4	             detachViewsFromParent(start, count); // detach 滑动出去的 view from ViewGroup
     5		     mBlockLayoutRequests = true;
     6		       fillGap() --> makeAndAddView() --> obtainView() --> getView() 获得新的 view 以填充滑动时产生的 gap
     7		     mBlockLayoutRequests = false;
     8	             invokeOnItemScrollListener();
     9	             awakenScrollBars();
#+END_EXAMPLE
           最重要的一点是: 在 scroll 时, mBlockLayoutRequests 会被置位,以禁止 scroll 时 requestLayout

****** 在 Preference 中出现该 BUG
       Preference 作为 经过包装的 ListView ,相对来说比较容易出现该 BUG:
       see also [[Preference]]
       - Preference.onBindView() 实际是经过包装的 getView()
       - Preference 自带的 setTitle(), setSummary() 的写法:

#+BEGIN_EXAMPLE
     1		 Preference.setTitle(title):
     2		   if (title == null && mTitle != null || title != null && !title.equals(mTitle)):
     3		     mTitle = title;
     4		     notifyChanged();
#+END_EXAMPLE

     如果调用者在 onBinderView 中调用了 setXXX() 方法, 则会出现该 BUG.

*** view overlay
*** GestureOverlayView
*** SurfaceView
*** TabActivity
*** TabHost
*** ViewAnimator
*** WebView
**** [#C] Cookie
     see [[@HTTP_Cookie]]
***** CookieManager
***** CookieSyncManager
** WindowManager
*** addView
2010-11-16
window.addView() will firstly gen (viewRoot,view,layout_param) tuple, then call ViewRoot.setView() to ask WMS to add the view.
since ViewRoot has an IWindowSession, and it will send IWindow to WMS (as mClient), it can communicate with WMS back and forth.

2010-11-15
window.addView() will add [new viewroot,decorView] tuple to
WindowManagerImpl, when WMS want to dispatch event to window, e.g. key event, it will
call mClient.dispatchKey() to viewRoot, viewRoot, as a handler, will then dispatch key event to it's looper

Activity and Dialog will generate decorView automatically, then call
WM.addView(decorView) to window.  but PopupWindow will not generate
decorView since PopupWindow need not to be `decorated`.
*** Event dispatch
**** KeyEvent dispatch
     11/17/10 11:12 am WMS first found the focused WindowState, then dispatch
     event to WindowState.mClient (this is a IWindow), IWindow , as an AIDL
     register by viewRoot, will call viewRoot's dispatch() directory

     2010-11-14
#+BEGIN_EXAMPLE
     WMS get mClient, and call mClient.dispatch() through binder
       ViewRoot.dispatchKey()
         ViewRoot.sendEmptyMessage(DISPATCH_KEY)
	   message handler: ViewRoot.deliverKeyEvent()
	     ViewRoot.deliverKeyEventToViewHierarchy()
	       Decorview.dispatchKeyEvent() ;; mView is the decorView
	         if (is volume key)
		   adjust volume
		 if (has Window.Callback) ;; Activity, Dialog implents Window.Callback
		   callback.dispatchKeyEvent()
		     DecorView.superDispatchKeyEvent()
		       ViewGroup.dispatchKeyEvent() ;; dispatch key event to view hierachy
		         Travers the focus path, call every ViewGroup's dispatchKeyEvent, then finally,calls:
			 focusView.dispatchKeyEvent()
			   mOnKeyListener.onKey()
			   if (not handled)
			     event.dispatch(view) ;; view also implents Event.Callback
		     if (not handled)
		         event.dispatch(activity) ;; Activity implents Event.Callback, which implents onKeyUp, onKeyDown ...
		 else
		   super.dispatchKeyEvent() ;; view.dispatchKeyEvent, PopupWindow falls into this condition, since PopupWindow
		                            ;; does not implents Window.Callback
                 if (still not handled):
                   Window.onKeyDown() or onKeyUp()
                     // cope with MENU,CAMERA,VOLUME,MEDIA,CALL,SEARCH...
               if (not handled)
	         changeFocus()
		 if not (focus changed)
		   playSoundEffect
	       sWindowSession.finishKey(mWindow) to tell AMS that key
#+END_EXAMPLE

    note that:
    Activity and Dialog implements Window.Callback and KeyEvent.Callback, so you can override Activity or Dialog's dispatchKeyEvent (implemented in
    Window.Callback), and you can override onKeyUp, onKeyDown ...( implemented in KeyEvent.Callback)
    But PopupWindow implements neither Window.Callback nor KeyEvent.Callback.

**** DONE [#A] TouchEvent dispatch
     SCHEDULED: <2011-01-27 Thu> CLOSED: [2011-01-27 Thu 11:35]
     - State "DONE"       [2011-01-27 Thu 11:35]

#+BEGIN_EXAMPLE
     ViewRoot.dispatchPointer()
       decorView.dispatchTouchEvent() ;; mView is typically a DecorView
         if DecorView has callbacks like Activity or Dialog
	   activity.dispatchTouchEvent()
	     mDecor.superDispatchTouchEvent()
	     .... ;; same as the `else` branch
	     activity.onTouchEvent() if not handled before
	 else
	   mDecor.superDispatchTouchEvent()
	     ViewGroup.dispatchTouchEvent() ; DecorView is a FrameLayout
               if (action == MotionEvent.ACTION_DOWN):
                 if (disallowIntercept || !onInterceptTouchEvent(Ev)):
                   foreach mView of ViewGroup: ;; for each child of the ViewGroup whose rect contains pointer(x,y), note that view's rect is set during view.layout()
                     if (mView.dispatchTouchEvent()):
                       mMotionTarget=mView;
                       return true;
               if mMotionTarget==null: // DOWN is not handled by any child; or event is up/move, but there is no mMotionTarget,
                                       // which means last DOWN is handled by ourselves.
                 return super.dispatchTouchEvent()
	           mView.onTouchListener().on Touch()
	           mView.onTouchEvent() ;; if not handled before
	             mView.onClickListener()
               // ACTION is up/move, and mMotionTarget is not null, which means we should delegate the up/move to the mMotionTarget,
               // There is no need to go through child hierarchy to handle it.
               if (!disallowIntercept && onInterceptTouchEvent(ev)): // touchEvent is intercepted
                 ev.setAction(MotionEvent.ACTION_CANCEL);
                 mMotionTarget.dispatchTouchEvent(ev)
                 return true;
               // touchEvent is not intercepted
               return mMotionTarget.dispatchTouchEvent(ev);
#+END_EXAMPLE
     To summarize:
     1. TouchEvent dispatching 的过程和 KeyEvent *相反*:
	- KeyEvent: 先调用 ViewGroup.superDispatchKeyEvent(), 若没处理,再调用 mFocused.dispatchKeyEvent()
	- TouchEvent: 先调用 child.dispatchTouchEvent(),若没处理, 再调用 super.dispatchTouchEvent()
     2. dispatchTouchEvent -> onTouchListener -> onTouchEvent -> onClickListener
     3. onInterceptTouchEvent and mMotionTarget and requestDisallowInterceptTouchEvent
***** DONE ListView TouchEvent dispatch
      SCHEDULED: <2011-02-16 Wed> CLOSED: [2011-02-16 Wed 15:04]
      - State "DONE"       [2011-02-16 Wed 15:04]
      ListView 首先是一个 ViewGroup, 它使用了
#+BEGIN_EXAMPLE
	 ViewGroup.dispatchTouchEvent()
	   ask_child_to_handle_it()
	   if not handled:
	     super(view).dispatchTouchEvent()
	       AbsListView.onTouchEvent()
	         if child(list item).hasFocusable(): ;; if the liste_item have any view that is focusable
		   do_nothing;
		 else:
		   onItemClickedListener();
#+END_EXAMPLE

      To summarize:
      ListView is just like a common ViewGroup, but:
      1. ListView's onTouchEvent will not invoke `onClickListener`, but `onItemClickedListener`
      2. before invoke onItemClickedListener, onTouchEvent will make sure that child.hasFocusable() is false

***** DONE ViewGroup.onInterceptTouchEvent & mMotionTarget & requestDisallowInterceptTouchEvent
      SCHEDULED: <2011-07-19 Tue> CLOSED: [2011-07-19 Tue 16:55]
      - State "DONE"       from "DOING"      [2011-07-19 Tue 16:55]
*** View
**** View life cycle
***** DONE requestLayout
      SCHEDULED: <2011-01-27 Thu> CLOSED: [2011-01-26 Wed 17:22]
      - State "DONE"       [2011-01-26 Wed 17:22]
      :PROPERTIES:
	:CUSTOM_ID: @requestLayout
      :END:
      see [[@onMeasure]] [[@onLayout]]
      requestLayout() is actually implemented in ViewRoot
      View defined it's own requestLayout by:
#+BEGIN_EXAMPLE
      View.requestLayout()
        mParent.requestLayout() ;; for a view, mParent is the upper ViewGroup
	  mParent.requestLayout() ;; ViewGroup implements View, thus recursive again to the parent
	    ...
	      top_view.requestLayout()
	        ViewRoot.requestLayout() ;; top view's mParent is the ViewRoot
#+END_EXAMPLE

    Call stack:
#+BEGIN_EXAMPLE
    ViewRoot.requestLayout()
      ViewRoot.scheduleTraversals()
        ViewRoot.performTraversals() handles the msg
	  mView.dispatchAttachedToWindow() ;; mView is the ViewRoot's top view
	    ViewGroup.dispatchAttachedToWindow()
	      view.dispatchAttachedToWindow() for every child view of the ViewGroup
	        view.onAttachedToWindow() ;;  see [[onAttachedToWindow][onAttachedToWindow]]
	  mView.measure()
	    mView.onMeasure()
	      layout.onMeasure() ;; e.g. LinearLayout, FrameLayout
	        view.measure() ;; for every child view of the layout, including margin
		  view.onMeasure() ;; see [[onMeasure][onMeasure]]
	  mView.layout()
	    layout.layout() ;; e.g. LinearLayout
	      view.layout() ;; it seems that view.layout && view.onLayout doesn't do something meaningful?  it mainly stores the child's x,y,width,height
	                    ;; so that we can, when touch the screen, tell which view is touched
	        view.onLayout() ;; see [[onLayout][onLayout]],
#+END_EXAMPLE

***** addView
***** removeView
***** onAttachedToWindow
      see [[@requestLayout]]
***** onDetachedFromWindow
***** DONE onLayout
      CLOSED: [2011-03-15 Tue 16:50]
      - State "DONE"       [2011-03-15 Tue 16:50]
      :PROPERTIES:
      :CUSTOM_ID: @onLayout
      :END:
      see [[@requestLayout]]
****** android:layout_gravity & android:gravity
       during onMeasure, view's size is fixed, after-wards, ViewGroup.onLayout will re-position children views and invoke child.onLayout to notify children
       for their position.

       - similar with android:height, only a few views or ViewGroup has the android:gravity property.
	 e.g. TextView has the android:gravity property, so that the inner text can be positioned to top/bottom/left/right
	 LinearLayout also has the android:gravity, which control Linear Layout's children's gravity as a whole.
******* How does LinearLayout make use of gravity.
	- for *Vertical* LinearLayout with layout_height= *fill_parent* :
	  vertical LinearLayout can only set it's android:gravity to `top,bottom,center_vertical`, which can move the children as a whole in
	  vertical direction.
	  vertical LinearLayout's child can set their android:layout_gravity to `left,right,center_horizontal`,which can move a single child view
	  in the horizontal direction.

	  that is, if u want to position a view in vertical LinearLayout to right-bottom, u can:
	    - set LinearLayout.android:gravity to bottom
	    - set view.android:layout_gravity to right

#+BEGIN_EXAMPLE
	    vertical LinearLayout      	       	      set android:gravity to bottom   		& set view1.layout_gravity to right
	   -+-----------------------+                -+-----------------------+                -+--------------------------+
	    |-+-------------+	    |		      |			      |		       	|		 	   |
	    | |	 view1	    |	    |		      |			      |		       	|		 	   |
	    | |	      	    |	    |		      |			      |		       	|		 	   |
	    |-+-------------+	    |		      |			      |		       	|		 	   |
	    | |	 view2	    |	    |		      | 		      |		       	|		 	   |
	    | |		    |	    |		      | 		      |		       	|		 	   |
	    |-+-------------+	    |		      |-+--------------+      |		       	|  	    -+-----------+ |
	    |			    |		      |	|  view1       |      |		       	|  	     |	view1	 | |
	    |			    |		      |	|  	       |      |		       	|      	     | 	     	 | |
	    |			    |		      |-+--------------+      |		       	| -+---------+--+--------+ |
	    |			    |		      |	|  view2       |      |		       	|  |  view2    	|    	   |
	    |			    |		      |	|      	       |      |		       	|  |		|    	   |
	    |			    |		      |-+--------------+      |		       	| -+------------+  	   |
	   -+-----------------------+		     -+-----------------------+		       -+--------------------------+
#+END_EXAMPLE

	- for horizontal LinearLayout:
	  vice-versa

***** [#B] invalidate
**** view padding and margin
     padding = 内边距
     margin =  外边距
     内,外是相对于容器(盒子)的边界而言, 以Button为例,Button可以看作一个盒子,设置button.padding会影响Button里的文字或图片与Button边界的距离,例如:

     Button
#+BEGIN_EXAMPLE
       -+---------------+
       	|[padding] click|
       -+---------------+
#+END_EXAMPLE

     而button.margin会影响button与其更外层盒子(如layout)的边界

     LinearLayout
#+BEGIN_EXAMPLE
       -+-------------------+
       	| [top margin] 	    |
       	|+-------------+    |
       	|| button      |    |
       	|+-------------+    |
       -+-------------------+
#+END_EXAMPLE

   需要注意的一点是,android中view是没有margin属性的,只有 ViewGroup 才有margin属性, 所以,如果想达到上图的效果,不可能直接设置button的margin,而是需在将button
   放在一个 ViewGroup 中,然后设置该 ViewGroup 的margin.

**** DecorView
**** findViewById
**** Switch focus
     11/17/10 9:41 am
     Q:when press 'left' key, how the focus is changed?
     A:
     1. when viewRoot got the key event, it will firstly call 'dispatchKeyEventToViewHierachy' to dispatch the key event to it's correspondingg top level viw (i.e. DecorView)
     2. If the key event is not handled by the view hierachy, viewRoot will call 'findFocus' to find next focus in 'handleFinishedEvent'

     3. If the current focused view has set 'focus:right...' properties, viewRoot will call view.findViewById to find the next focus, or find the nearest focusable view in a specified rectangle area.

**** getDrawingCache
**** ViewGroup
*** ViewRoot, View (DecorView) and Window
    - 与WMS直接打交道的是ViewRoot,WMS能直接看到的只有ViewRoot (通过ViewRoot注册到WMS的IWindow mClient)

    - ViewRoot直接管理其顶层View (对于Actity,Dialog, 即DecorView. 对于

      PopupWindow及手动通过WindowManagerImpl.addView添加的view, 其顶层view只是普
      通的view), 所以一个进程可以有多个ViewRoot

    - Window是和DecorView一一对应的. 

      因为Activity, Dialog项层view是DecorView, 所以有window的概念, 可以通
      过Window来控制ContextMenu, 调用Window.Callback等;

    - Window与Activity,Dialog对应
    
      通过Window.Callback, 可以和Activity和Dialog联系起来,因为它们都实际了
      Window.Callback接口.而PopupWindow顶层只是普通view,所以没有Window的概念

      综上:
      - WMS<-->ViewRoot
      - ViewRoot<-->DecorView
      - DecorView<-->Window<-->Activity,Dialog
*** Window
对于ViewRoot来说,顶层的`Window`就是一个普通的View, 但有些和`Window`有关的操
作,如:
 - 如何处理一些通用的按键事件, 如Volume, ContextMenu,Camera,Call,Search...,
 - 如何在顶层View之上再显示一个ContextMenu
 - 从WMS来的一些事件如何通知给Activity,Dialog, 例如onBackPressed()
因为, 提供了一个Window类, 用来处理这些和`Window`有关的操作, 但从WMS及
ViewRoot的角度看,并没有`Window`的概念. 

只有DecorView能和Window关联,来处理`Window`相关操作 (因为DecorView是Window的
inner class), 所以只有Activity,Dialog有window的概念
**** PhoneWindow
*** ViewRoot
ViewRoot is the bridge between WMS and View, It is basically a handler of
activityThread's mainLooper.  So WMS can use this handler to dispatch event to
top view of the activity or dialog.  What more, viewRoot is also equiped with an
IWindowSession, through which can communicate with WMS, e.g, tell WMS to add
view in ViewRoot.setView()
**** IWindowSession: the sWindowSession
when viewRoot is constructred, it will open session to WMS (IWindowSession) to communicate with WMS (e.g. For add, remove view)
**** IWindow: the mWindow
when viewRoot is constructed, it will create IWindow, and register the AIDL
interface to WMS, WMS will save the IWindow as 'mClient' in WindowState arrays,
through which WMS can communite with ViewRoot for event
dispatching. IWindow.dispatch() will call viewRoot.dispatch() directly.
**** AttachInfo: the mAttachInfo
**** InputChannel: the mInputChannel
**** Rect: the mWinFrame
**** Rect: the mPendingContentInsets and mPendingVisibleInsets

*** WindowManagerImpl
*** WindowManagerPolicy
**** PhoneWindowManager
*** WindowManagerService
**** WindowState
***** mClient
IWindow as the mClient
**** WindowToken
**** AppWindowToken
*** Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析
#+BEGIN_QUOTE
Location: http://blog.csdn.net/luoshengyang/article/details/8479101

Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析

        在Android系统中，Activity窗口的大小是由WindowManagerService服务来计算的。WindowManagerService服务会根据屏幕及其
装饰区的大小来决定Activity窗口的大小。一个Activity窗口只有知道自己的大小之后，才能对它里面的UI元素进行测量、布局以及绘
制。本文将详细分析WindowManagerService服务计算Activity窗口大小的过程。

        一般来说，Activity窗口的大小等于整个屏幕的大小，但是它并不占据着整块屏幕。为了理解这一点，我们首先分析一下
Activity窗口的区域是如何划分的。

        我们知道，Activity窗口的上方一般会有一个状态栏，用来显示3G信号、电量使用等图标，如图1所示。

[1357577722_3792]                                                            

图1 Activity窗口的Content区域示意图

       从Activity窗口剔除掉状态栏所占用的区域之后，所得到的区域就称为内容区域（Content Region）。顾名思义，内容区域就是
用来显示Activity窗口的内容的。我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏的区域，那么将这些区域剔除之后，
得到中间的那一块区域就称为内容区域，而被剔除出来的区域所组成的区域就称为内容边衬区域（Content Insets）。Activity窗口的
内容边衬区域可以用一个四元组（content-left, content-top, content-right, content-bottom）来描述，其中，content-left、
content-right、content-top、content-bottom分别用来描述内容区域与窗口区域的左右上下边界距离。

       我们还知道，Activity窗口有时候需要显示输入法窗口，如图2所示。

[1357578477_7744]                                                            

图2 Activity窗口的Visible区域示意图

        这时候Activity窗口的内容区域的大小有可能没有发生变化，这取决于它的Soft Input Mode。我们假设Activity窗口的内容区
域没有发生变化，但是它在底部的一些区域被输入法窗口遮挡了，即它在底部的一些内容是不可见的。从Activity窗口剔除掉状态栏和
输入法窗口所占用的区域之后，所得到的区域就称为可见区域（Visible Region）。同样，我们再抽象一下，假设Activity窗口的四周
都有一块类似状态栏和输入法窗口的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为可见区域，而被剔除出来的区域所
组成的区域就称为可见边衬区域（Visible Insets）。Activity窗口的可见边衬区域可以用一个四元组（visible-left, visible-top, 
visible-right, visible-bottom）来描述，其中，visible-left、visible-right、visible-top、visible-bottom分别用来描述可见区
域与窗口区域的左右上下边界距离。

        在大多数情况下，Activity窗口的内容区域和可见区域的大小是一致的，而状态栏和输入法窗口所占用的区域又称为屏幕装饰
区。理解了这些概念之后，我们就可以推断，WindowManagerService服务实际上就是需要根据屏幕以及可能出现的状态栏和输入法窗口
的大小来计算出Activity窗口的整体大小及其内容区域边衬和可见区域边衬的大小。有了这三个数据之后，Activity窗口就可以对它里
面的UI元素进行测量、布局以及绘制等操作了。

        从前面Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析一文可以知道，应用程序进程是从ViewRoot
类的成员函数performTraversals开始，向WindowManagerService服务请求计算一个Activity窗口的大小的，因此，接下来我们就从
ViewRoot类的成员函数performTraversals开始分析一个Activity窗口大小的计算过程，如图3所示。

[1357660841_4551]                                                            

图3 Activity窗口大小的计算过程

         这个过程可以分为11个步骤，接下来我们就详细分析每一个步骤。

         Step 1. ViewRoot.performTraversals

         这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中，它的实现很复杂，一共有600-行，不过大
部分代码都是用来计算Activity窗口的大小的，我们分段来阅读：

public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......
     
    private void performTraversals() {
        ......

        final View host = mView;
        ......
 
        int desiredWindowWidth;
        int desiredWindowHeight;
        int childWidthMeasureSpec;
        int childHeightMeasureSpec;
        ......

        Rect frame = mWinFrame;
        if (mFirst) {
            ......
 
            DisplayMetrics packageMetrics =
                 mView.getContext().getResources().getDisplayMetrics();
            desiredWindowWidth = packageMetrics.widthPixels;
            desiredWindowHeight = packageMetrics.heightPixels;
        } else {
            desiredWindowWidth = frame.width();
            desiredWindowHeight = frame.height();
            if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
                ......
                windowResizesToFitContent = true;
            }
        }

        这段代码用来获得Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight。

        注意，Activity窗口当前的宽度和高度是保存ViewRoot类的成员变量mWinFrame中的。ViewRoot类的另外两个成员变量mWidth和
mHeight也是用来描述Activity窗口当前的宽度和高度的，但是它们的值是由应用程序进程上一次主动请求WindowManagerService服务计
算得到的，并且会一直保持不变到应用程序进程下一次再请求WindowManagerService服务来重新计算为止。Activity窗口的当前宽度和
高度有时候是被WindowManagerService服务主动请求应用程序进程修改的，修改后的值就会保存在ViewRoot类的成员变量mWinFrame中，
它们可能会与ViewRoot类的成员变量mWidth和mHeight的值不同。

        如果Activity窗口是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true，那么它的当前
宽度desiredWindowWidth和当前高度desiredWindowHeight就等于屏幕的宽度和高度，否则的话，它的当前宽度desiredWindowWidth和当
前高度desiredWindowHeight就等于保存在ViewRoot类的成员变量mWinFrame中的宽度和高度值。

        如果Activity窗口不是第一次被请求执行测量、布局和绘制操作，并且Activity窗口主动上一次请求WindowManagerService服
务计算得到的宽度mWidth和高度mHeight不等于Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight，那么就
说明Activity窗口的大小发生了变化，这时候变量windowResizesToFitContent的值就会被标记为true，以便接下来可以对Activity窗口
的大小变化进行处理。

        我们继续往下阅读代码：

        boolean insetsChanged = false;
 
        if (mLayoutRequested) {
            ......
 
            if (mFirst) {
                host.fitSystemWindows(mAttachInfo.mContentInsets);
                ......
            } else {
                if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
                    mAttachInfo.mContentInsets.set(mPendingContentInsets);
                    host.fitSystemWindows(mAttachInfo.mContentInsets);
                    insetsChanged = true;
                    ......
                }
                if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
                    ......
                }
                if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT
                        || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
                    windowResizesToFitContent = true;
 
                    DisplayMetrics packageMetrics =
                        mView.getContext().getResources().getDisplayMetrics();
                    desiredWindowWidth = packageMetrics.widthPixels;
                    desiredWindowHeight = packageMetrics.heightPixels;
                }
            }

            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); 
            ......

            host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
 
            ......
        }

        这段代码用来在Activity窗口主动请求WindowManagerService服务计算大小之前，对它的顶层视图进行一次测量操作。

        在分析这段代码之前，我们首先解释一下ViewRoot类的成员变量mAttachInfo和mPendingContentInsets、
mPendingVisibleInsets。ViewRoot类的成员变量mAttachInfo指向的一个AttachInfo对象，这个AttachInfo对象用来描述Activity窗口
的属性，例如，这个AttachInfo对象的成员变量mContentInsets和mVisibleInsets分别用来描述Activity窗口上一次主动请求
WindowManagerService服务计算得到的内容边衬大小和可见边衬大小，即Activity窗口的当前内容边衬大小和可见边衬大小。ViewRoot
类的成员变量mPendingContentInsets和mPendingVisibleInsets也是用来描述Activity窗口的内容边衬大小和可见边衬大小的，不过它
们是由WindowManagerService服务主动请求Activity窗口设置的，但是尚未生效。

        我们分两种情况来分析这段代码。

        第一种情况是Activity窗口是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true，那么
这段代码在测量Activity窗口的顶层视图host的大小之前，首先会调用这个顶层视图host的成员函数fitSystemWindows来设置它的四个
内边距（mPaddingLeft，mPaddingTop，mPaddingRight，mPaddingBottom）的大小设置为Activity窗口的初始化内容边衬大小。这样做
的目的是可以在Activity窗口的四周留下足够的区域来放置可能会出现的系统窗口，也就是状态栏和输入法窗口。

        第二种情况是Activity窗口不是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于false，那
么这段代码就会检查Activity窗口是否被WindowManagerService服务主动请求设置了一个新的内容边衬大小mPendingContentInsets和一
个新的可见边衬大小mPendingVisibleInsets。如果是的话，那么就会分别将它们保存在ViewRoot类的成员变量mAttachInfo所指向的一
个AttachInfo对象的成员变量mContentInsets和成员变量mVisibleInsets中。注意，如果Activity窗口被WindowManagerService服务主
动请求设置了一个新的内容边衬大小mPendingContentInsets，那么这段代码同时还需要同步调用Activity窗口的顶层视图host的成员函
数fitSystemWindows来将它的四个内边距（mPaddingLeft，mPaddingTop，mPaddingRight，mPaddingBottom）的大小设置为新的内容边
衬大小，并且将变量insetsChanged的值设置为true，表明Activity窗口的内容边衬大小发生了变化。

        在第二种情况下，如果Activity窗口的宽度被设置为ViewGroup.LayoutParams.WRAP_CONTENT或者高度被设置为
ViewGroup.LayoutParams.WRAP_CONTENT，那么就意味着Activity窗口的大小要等于内容区域的大小。但是由于Activity窗口的大小是需
要覆盖整个屏幕的，因此，这时候就会Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight设置为屏幕的宽度
和高度。也就是说，如果我们将Activity窗口的宽度和高度设置为ViewGroup.LayoutParams.WRAP_CONTENT，实际上就意味着它的宽度和
高度等于屏幕的宽度和高度。这种情况也意味着Acitivity窗口的大小发生了变化，因此，就将变量windowResizesToFitContent的值设
置为true。

        经过上面的一系列处理之后，这段代码就会调用ViewRoot类的成员函数getRootMeasureSpec来根据Activity窗口的当前宽度和
宽度测量规范以及高度和高度测量规范来计算得到它的顶层视图host的宽度测量规范childWidthMeasureSpec和高度测量规范
childHeightMeasureSpec。有了这两个规范之后，就可以调用Activity窗口的顶层视图host的成员函数measure来执行大小测量的工作了
。这个大小测量的过程可以参考前面Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析
一文。

       我们继续往下阅读代码：

        boolean windowShouldResize = mLayoutRequested && windowResizesToFitContent
            && ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight)
                || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &&
                        frame.width() < desiredWindowWidth && frame.width() != mWidth)
                || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &&
                        frame.height() < desiredWindowHeight && frame.height() != mHeight));

        final boolean computesInternalInsets =
                attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();

       这段代码主要是做两件事情。

       第一件事情是检查是否需要处理Activity窗口的大小变化事件。如果满足以下条件，那么就需要处理，即将变量
windowShouldResize的值设置为true：

       1. ViewRoot类的成员变量mLayoutRequest的值等于true，这说明应用程序进程正在请求对Activity窗口执行一次测量、布局和
绘制操作；

       2. 变量windowResizesToFitContent的值等于true，这说明前面检测到了Activity窗口的大小发生了变化；

       3. 前面我们已经Activity窗口的顶层视图host的大小重新进行了测量。如果测量出来的宽度host.mMeasuredWidth和高度
host.mMeasuredHeight和Activity窗口的当前宽度mWidth和高度mHeight一样，那么即使条件1和条件2能满足，那么也是可以认为是
Activity窗口的大小是没有发生变化的。换句话说，只有当测量出来的大小和当前大小不一致时，才认为Activity窗口大小发生了变化
。另一方面，如果测量出来的大小和当前大小一致，但是Activity窗口的大小被要求设置成WRAP_CONTENT，即设置成和屏幕的宽度
desiredWindowWidth和高度desiredWindowHeight一致，但是WindowManagerService服务请求Activity窗口设置的宽度frame.width()和
高度frame.height()与它们不一致，而且与Activity窗口上一次请求WindowManagerService服务计算的宽度mWidth和高度mHeight也不一
致，那么也是认为Activity窗口大小发生了变化的。

        第二件事情是检查Activity窗口是否需要指定有额外的内容边衬区域和可见边衬区域。如果有的话，那么变量attachInfo所指
向的一个AttachInfo对象的成员变量mTreeObserver所描述的一个TreeObserver对象的成员函数hasComputeInternalInsetsListerner的
返回值ComputeInternalInsets就会等于true。Activity窗口指定额外的内容边衬区域和可见边衬区域是为了放置一些额外的东西。

        我们继续往下阅读代码：

        if (mFirst || windowShouldResize || insetsChanged
                || viewVisibilityChanged || params != null) {

            if (viewVisibility == View.VISIBLE) {
                // If this window is giving internal insets to the window
                // manager, and it is being added or changing its visibility,
                // then we want to first give the window manager "fake"
                // insets to cause it to effectively ignore the content of
                // the window during layout.  This avoids it briefly causing
                // other windows to resize/move based on the raw frame of the
                // window, waiting until we can finish laying out this window
                // and get back to the window manager with the ultimately
                // computed insets.
                insetsPending = computesInternalInsets
                        && (mFirst || viewVisibilityChanged);

                ......
            }

        这段代码以及接下来的两段代码都是在满足下面的条件之一的情况下执行的：

        1. Activity窗口是第一次执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true。

        2. 前面得到的变量windowShouldResize的值等于true，即Activity窗口的大小的确是发生了变化。

        3. 前面得到的变量insetsChanged的值等于true，即Activity窗口的内容区域边衬发生了变化。

        4. Activity窗口的可见性发生了变化，即变量viewVisibilityChanged的值等于true。

        5. Activity窗口的属性发生了变化，即变量params指向了一个WindowManager.LayoutParams对象。

        在满足上述条件之一，并且Activity窗口处于可见状态，即变量viewVisibility的值等于View.VISIBLE，那么就需要检查接下
来请求WindowManagerService服务计算大小时，是否要告诉WindowManagerService服务它指定了额外的内容区域边衬和可见区域边衬，
但是这些额外的内容区域边衬和可见区域边衬又还有确定。这种情况发生在Activity窗口第一次执行测量、布局和绘制操作或者由不可
见变化可见时。因此，当前面得到的变量computesInternalInsets等于true时，即Activity窗口指定了额外的内容区域边衬和可见区域
边衬，那么就需要检查ViewRoot类的成员变量mFirst或者变量viewVisibilityChanged的值是否等于true。如果这些条件能满足，那么变
量insetsPending的值就会等于true，表示Activity窗口有额外的内容区域边衬和可见区域边衬等待指定。

        我们继续往下阅读代码：

            boolean contentInsetsChanged = false;
            boolean visibleInsetsChanged;
            ......
            try {
                ......
                relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);

                contentInsetsChanged = !mPendingContentInsets.equals(
                        mAttachInfo.mContentInsets);
                visibleInsetsChanged = !mPendingVisibleInsets.equals(
                        mAttachInfo.mVisibleInsets);
                if (contentInsetsChanged) {
                    mAttachInfo.mContentInsets.set(mPendingContentInsets);
                    host.fitSystemWindows(mAttachInfo.mContentInsets);
                    ......
                }
                if (visibleInsetsChanged) {
                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
                    ......
                }
                    
                ......
            } catch (RemoteException e) {
            }

            ......

            attachInfo.mWindowLeft = frame.left;
            attachInfo.mWindowTop = frame.top;

            // !!FIXME!! This next section handles the case where we did not get the
            // window size we asked for. We should avoid this by getting a maximum size from
            // the window session beforehand.
            mWidth = frame.width();
            mHeight = frame.height();

        这段代码主要就是调用ViewRoot类的另外一个成员函数relayoutWindow来请求WindowManagerService服务计算Activity窗口的
大小以及内容区域边衬大小和可见区域边衬大小。计算完毕之后，Activity窗口的大小就会保存在ViewRoot类的成员变量mWinFrame中，
而Activity窗口的内容区域边衬大小和可见区域边衬大小分别保存在ViewRoot类的成员变量mPendingContentInsets和
mPendingVisibleInsets中。

        如果这次计算得到的Activity窗口的内容区域边衬大小mPendingContentInsets和可见区域边衬大小mPendingVisibleInsets与
上一次计算得到的不一致，即与ViewRoot类的成员变量mAttachInfo所指向的一个AttachInfo对象的成员变量mContentInsets和
mVisibleInsets所描述的大小不一致，那么变量contentInsetsChanged和visibleInsetsChanged的值就会等于true，表示Activity窗口
的内容区域边衬大小和可见区域边衬大小发生了变化。

        由于变量frame和ViewRoot类的成员变量mWinFrame引用的是同一个Rect对象，因此，这时候变量frame描述的也是Activity窗口
请求WindowManagerService服务计算之后得到的大小。这段代码分别将计算得到的Activity窗口的左上角坐标保存在变量attachInfo所
指向的一个AttachInfo对象的成员变量mWindowLeft和mWindowTop中，并且将计算得到的Activity窗口的宽度和高度保存在ViewRoot类的
成员变量mWidth和mHeight中。

        我们继续往下阅读代码：

            boolean focusChangedDueToTouchMode = ensureTouchModeLocally(
                    (relayoutResult&WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
            if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth
                    || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
                childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
                childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
                ......

                // Ask host how big it wants to be
                host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        
                // Implementation of weights from WindowManager.LayoutParams
                // We just grow the dimensions as needed and re-measure if
                // needs be
                int width = host.mMeasuredWidth;
                int height = host.mMeasuredHeight;
                boolean measureAgain = false;

                if (lp.horizontalWeight > 0.0f) {
                    width += (int) ((mWidth - width) * lp.horizontalWeight);
                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,
                            MeasureSpec.EXACTLY);
                    measureAgain = true;
                }
                if (lp.verticalWeight > 0.0f) {
                    height += (int) ((mHeight - height) * lp.verticalWeight);
                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,
                            MeasureSpec.EXACTLY);
                    measureAgain = true;
                }

                if (measureAgain) {
                    ......
                    host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                }

                mLayoutRequested = true;
            }
        }

        这段代码用来检查是否需要重新测量Activity窗口的大小。如果满足以下条件之一，那么就需要重新测量：

        1. Activity窗口的触摸模式发生了变化，并且由此引发了Activity窗口当前获得焦点的控件发生了变化，即变量
focusChangedDueToTouchMode的值等于true。这个检查是通过调用ViewRoot类的成员函数ensureTouchModeLocally来实现的。

        2. Activity窗口前面测量出来的宽度host.mMeasuredWidth和高度host.mMeasuredHeight不等于WindowManagerService服务计
算出来的宽度mWidth和高度mHeight。

        3. Activity窗口的内容区域边衬大小和可见区域边衬大小发生了变化，即前面得到的变量contentInsetsChanged的值等于true
。

        重新计算了一次之后，如果Activity窗口的属性lp表明需要对测量出来的宽度width和高度height进行扩展，即变量lp所指向的
一个WindowManager.LayoutParams对象的成员变量horizontalWeight和verticalWeight的值大于0.0，那么就需要对Activity窗口的顶层
视图host的最大可用空间进行扩展后再进行一次测量工作。

        我们继续往下阅读最后一段代码：

        final boolean didLayout = mLayoutRequested;
        ......
        if (didLayout) {
            ......
            host.layout(0, 0, host.mMeasuredWidth, host.mMeasuredHeight);
            ......
        }

        if (computesInternalInsets) {
            ViewTreeObserver.InternalInsetsInfo insets = attachInfo.mGivenInternalInsets;
            final Rect givenContent = attachInfo.mGivenInternalInsets.contentInsets;
            final Rect givenVisible = attachInfo.mGivenInternalInsets.visibleInsets;
            givenContent.left = givenContent.top = givenContent.right
                    = givenContent.bottom = givenVisible.left = givenVisible.top
                    = givenVisible.right = givenVisible.bottom = 0;
            attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
            Rect contentInsets = insets.contentInsets;
            Rect visibleInsets = insets.visibleInsets;
            if (mTranslator != null) {
                contentInsets = mTranslator.getTranslatedContentInsets(contentInsets);
                visibleInsets = mTranslator.getTranslatedVisbileInsets(visibleInsets);
            }
            if (insetsPending || !mLastGivenInsets.equals(insets)) {
                mLastGivenInsets.set(insets);
                try {
                    sWindowSession.setInsets(mWindow, insets.mTouchableInsets,
                            contentInsets, visibleInsets);
                } catch (RemoteException e) {
                }
            }
        }
          
        ......
    }

    ......
}

        经过前面漫长的操作后，Activity窗口的大小测量工作终于尘埃落定，这时候就可以对Activity窗口的内容进行布局了，前提
是ViewRoot类的成员变量mLayoutRequest的值等于true。对Activity窗口的内容进行布局是通过调用它的顶层视图host的成员函数
layout来实现的，这个过程可以参考前面Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程
分析一文。

        从前面的描述可以知道，当变量computesInternalInsets的值等于true时，就表示Activity窗口指定有额外的内容区域边衬和
可见区域边衬，这时候就是时候把它们告诉给WindowManagerService服务了，以便WindowManagerService服务下次可以知道Activity窗
口的真实布局。Activity窗口额外指定的内容区域边衬大小和可见区域边衬大小是通过调用变量attachInfo所指向的一个AttachInfo对
象的成员变量mTreeObserver所描述的一个TreeObserver对象的成员函数dispatchOnComputeInternalInsets来计算的。计算完成之后，
就会保存在变量attachInfo所指向的一个AttachInfo对象的成员变量mGivenInternalInsets中，并且会通过ViewRoot类的静态成员变量
sWindowSession所指向一个Binder代理对象来设置到WindowManagerService服务中去。

        注意，如果ViewRoot类的成员变量mTranslator指向了一个Translator对象，那么就说明Activity窗口是运行兼容模式中，这时
候就需要将前面计算得到的内容区域边衬大小和可见区域边衬大小转化到兼容模式下，然后才可以保存在变量attachInfo所指向的一个
AttachInfo对象的成员变量mGivenInternalInsets中，以及设置到WindowManagerService服务中去。

        另外，只有前面得到的变量insetsPending的值等于true，即Activity窗口正在等待告诉WindowManagerService服务它有额外指
定的内容区域边衬和可见区域边衬，或者Activty窗口额外指定的内容区域边衬和可见区域边衬发生了变化，即Activty窗口上一次额外
指定的内容区域边衬和可见区域边衬mLastGivenInsets不等于当前这次指定的内容区域边衬和可见区域边衬insets，Activity窗口额外
指定的内容区域边衬和可见区域边衬才会被设置到WindowManagerService服务中去。

        ViewRoot类的成员函数再接下来的工作就是绘制Activity窗口的UI了，这个过程同样可以参考前面Android应用程序窗口（
Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析一文。

        接下来，我们继续分析ViewRoot类的成员函数relayoutWindow的实现，以便可以了解它是如何请求WindowManagerService服务
计算Activity窗口的大小的。

        Step 2. ViewRoot.relayoutWindow

public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......
     
    private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {

        float appScale = mAttachInfo.mApplicationScale;
        ......

        int relayoutResult = sWindowSession.relayout(
                mWindow, params,
                (int) (mView.mMeasuredWidth * appScale + 0.5f),
                (int) (mView.mMeasuredHeight * appScale + 0.5f),
                viewVisibility, insetsPending, mWinFrame,
                mPendingContentInsets, mPendingVisibleInsets,
                mPendingConfiguration, mSurface);
        ......
        
        if (mTranslator != null) {
            mTranslator.translateRectInScreenToAppWinFrame(mWinFrame);
            mTranslator.translateRectInScreenToAppWindow(mPendingContentInsets);
            mTranslator.translateRectInScreenToAppWindow(mPendingVisibleInsets);
        }
        return relayoutResult;
    }

    ......
}

       这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。

       从前面Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析一文可以知道，ViewRoot类的静态成员
变量sWindowSession是一个Binder代理对象，它引用了运行在WindowManagerService服务这一侧的一个Session对象，ViewRoot类的成员
函数relayoutWindow通过调用这个Session对象的成员函数relayout来请求WindowManagerService服务计算Activity窗口的大小，其中，
传递给WindowManagerService服务的参数包括：

       1. ViewRoot类的成员变量mWindow，用来标志要计算的是哪一个Activity窗口的大小。

       2. Activity窗口的顶层视图经过测量后得到的宽度和高度。注意，传递给WindowManagerService服务的宽度和高度是已经考虑
了Activity窗口所设置的缩放因子了的。

       3. Activity窗口的可见状态，即参数viewVisibility。

       4. Activity窗口是否有额外的内容区域边衬和可见区域边衬等待告诉给WindowManagerService服务，即参数insetsPending。

       5. ViewRoot类的成员变量mWinFrame，这是一个输出参数，用来保存WindowManagerService服务计算后得到的Activity窗口的大
小。

       6. ViewRoot类的成员变量mPendingContentInsets，这是一个输出参数，用来保存WindowManagerService服务计算后得到的
Activity窗口的内容区域边衬大小。

       7. ViewRoot类的成员变量mPendingVisibleInsets，这是一个输出参数，用来保存WindowManagerService服务计算后得到的
Activity窗口的可见区域边衬大小。

       8. ViewRoot类的成员变量mPendingConfiguration，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity
窗口的配置信息。

       9. ViewRoot类的成员变量mSurface，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的绘图表
面。

       得到了Activity窗口的大小以及内容区域边衬大小和可见区域边衬大小之后，如果Activity窗口是运行在兼容模式中，即
ViewRoot类的成员变量mTranslator指向了一个Translator对象，那么就需要调用它的成员函数translateRectInScreenToAppWindow来对
它们进行转换。

       接下来，我们继续分析Session类的成员函数relayout，以便可以了解WindowManagerService服务是如何计算一个Activity窗口
的大小的。

       Step 3. Session.relayout

public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class Session extends IWindowSession.Stub
            implements IBinder.DeathRecipient {
        ......

        public int relayout(IWindow window, WindowManager.LayoutParams attrs,
                int requestedWidth, int requestedHeight, int viewFlags,
                boolean insetsPending, Rect outFrame, Rect outContentInsets,
                Rect outVisibleInsets, Configuration outConfig, Surface outSurface) {
            //Log.d(TAG, ">>>>>> ENTERED relayout from " + Binder.getCallingPid());
            int res = relayoutWindow(this, window, attrs,
                    requestedWidth, requestedHeight, viewFlags, insetsPending,
                    outFrame, outContentInsets, outVisibleInsets, outConfig, outSurface);
            //Log.d(TAG, "<<<<<< EXITING relayout to " + Binder.getCallingPid());
            return res;
        }

        ......
    }

    ......
}

        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。

        Session类的成员函数relayout的实现很简单，它只是调用了WindowManagerService类的成员函数relayoutWindow来进一步计算
参数window所描述的一个Activity窗品的大小，接下来我们就继续分析WindowManagerService类的成员函数relayoutWindow的实现。

        Step 4. WindowManagerService.relayoutWindow

public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    public int relayoutWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int requestedWidth,
            int requestedHeight, int viewVisibility, boolean insetsPending,
            Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,
            Configuration outConfig, Surface outSurface) {
        ......
 
        synchronized(mWindowMap) {
            WindowState win = windowForClientLocked(session, client, false);
            ......

            win.mRequestedWidth = requestedWidth;
            win.mRequestedHeight = requestedHeight;
            ......

            final boolean scaledWindow =
                ((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);

            if (scaledWindow) {
                // requested{Width|Height} Surface's physical size
                // attrs.{width|height} Size on screen
                win.mHScale = (attrs.width  != requestedWidth)  ?
                        (attrs.width  / (float)requestedWidth) : 1.0f;
                win.mVScale = (attrs.height != requestedHeight) ?
                        (attrs.height / (float)requestedHeight) : 1.0f;
            } else {
                win.mHScale = win.mVScale = 1;
            }

            ......

            win.mGivenInsetsPending = insetsPending;

            ......

            performLayoutAndPlaceSurfacesLocked();

            ......

            outFrame.set(win.mFrame);
            outContentInsets.set(win.mContentInsets);
            outVisibleInsets.set(win.mVisibleInsets);
 
            ......
        }

        return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0)
                | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
    }

    ......
}

        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。

        参数client是一个Binder代理对象，它引用了运行在应用程序进程这一侧中的一个W对象，用来标志一个Activity窗口。从前面
Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析一文可以知道，在应用程序进程这一侧的每一个W对象
，在WindowManagerService服务这一侧都有一个对应的WindowState对象，用来描述一个Activity窗口的状态。因此，
WindowManagerService类的成员函数relayoutWindow首先通过调用另外一个成员函数windowForClientLocked来获得与参数client所对应
的一个WindowState对象win，以便接下来可以对它进行操作。

        本文我们只关注WindowManagerService类的成员函数relayoutWindow中与窗口大小计算有关的逻辑，计算过程如下所示：

        1. 参数requestedWidth和requestedHeight描述的是应用程序进程请求设置Activity窗口中的宽度和高度，它们会被记录在
WindowState对象win的成员变量mRequestedWidth和mRequestedHeight中。

        2. WindowState对象win的成员变量mAttr，它指向的是一个WindowManager.LayoutParams对象，用来描述Activity窗口的布局
参数。其中，这个WindowManager.LayoutParams对象的成员变量width和height是用来描述Activity窗口的宽度和高度的。当这个
WindowManager.LayoutParams对象的成员变量flags的WindowManager.LayoutParams.FLAG_SCALED位不等于0的时候，就说明需要给
Activity窗口的大小设置缩放因子。缩放因子分为两个维度，分别是宽度缩放因子和高度缩放因子，保存在WindowState对象win的成员
变量HScale和VScale中，计算方法分别是用应用程序进程请求设置Activity窗口中的宽度和高度除以Activity窗口在布局参数中所设置
的宽度和高度。

        3. 参数insetsPending用来描述Activity窗口是否有额外的内容区域边衬和可见区域边衬未设置，它被记录在WindowState对象
win的成员变量mGivenInsetsPending中。

        4. 调用WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked来计算Activity窗口的大小。计算完成之
后，参数client所描述的Activity窗口的大小、内容区域边衬大小和可见区域边边衬大小就会分别保存在WindowState对象win的成员变
量mFrame、mContentInsets和mVisibleInsets中。

        5. 将WindowState对象win的成员变量mFrame、mContentInsets和mVisibleInsets的值分别拷贝到参数出数outFrame、
outContentInsets和outVisibleInsets中，以便可以返回给应用程序进程。

        经过上述五个操作后，Activity窗口的大小计算过程就完成了，接下来我们继续分析WindowManagerService类的成员函数
performLayoutAndPlaceSurfacesLocked的实现，以便可以详细了解Activity窗口的大小计算过程。

        Step 5. WindowManagerService.performLayoutAndPlaceSurfacesLocked

public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final void performLayoutAndPlaceSurfacesLocked() {
        if (mInLayout) {
            ......
            return;
        }

        ......

        boolean recoveringMemory = false;
        if (mForceRemoves != null) {
            recoveringMemory = true;
            // Wait a little it for things to settle down, and off we go.
            for (int i=0; i<mForceRemoves.size(); i++) {
                WindowState ws = mForceRemoves.get(i);
                Slog.i(TAG, "Force removing: " + ws);
                removeWindowInnerLocked(ws.mSession, ws);
            }
            mForceRemoves = null;
            ......
        }

        mInLayout = true;
        try {
            performLayoutAndPlaceSurfacesLockedInner(recoveringMemory);

            int i = mPendingRemove.size()-1;
            if (i >= 0) {
                while (i >= 0) {
                    WindowState w = mPendingRemove.get(i);
                    removeWindowInnerLocked(w.mSession, w);
                    i--;
                }
                mPendingRemove.clear();

                mInLayout = false;
                assignLayersLocked();
                mLayoutNeeded = true;
                performLayoutAndPlaceSurfacesLocked();

            } else {
                mInLayout = false;
                ......
            }
            ......
        } catch (RuntimeException e) {
            mInLayout = false;
            ......
        }
    }

    ......
}

       这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。

       从WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked的名称可以推断出，它执行的操作绝非是计算窗
口大小这么简单。计算窗口大小只是其中的一个小小功能点，它主要的功能是用来刷新系统的UI。在我们这个情景中，为什么需要刷新
系统的UI呢？Activity窗口在其属性发生了变化，例如，可见性、大小发生了变化，又或者它新增、删除了子视图，都需要重新计算大
小，而这些变化都是要求WindowManagerService服务重新刷新系统的UI的。事实上，刷新系统的UI是WindowManagerService服务的主要
任务，在新增和删除了窗口、窗口动画显示过程、窗口切换过程中，WindowManagerService服务都需要不断地刷新系统的UI。

       WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked主要是通过调用另外一个成员函数
performLayoutAndPlaceSurfacesLockedInner来刷新系统的UI的，而在刷新的过程中，就会对系统中的各个窗口的大小进行计算。

       在调用成员函数performLayoutAndPlaceSurfacesLockedInner来刷新系统UI的前后，WindowManagerService类的成员函数
performLayoutAndPlaceSurfacesLocked还会执行以下两个操作：

       1. 调用前，检查系统中是否存在强制删除的窗口。有内存不足的情况下，有一些窗口就会被回收，即要从系统中删除，这些窗
口会保存在WindowManagerService类的成员变量mForceRemoves所描述的一个ArrayList中。如果存在这些窗口，那么
WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked就会调用另外一个成员函数removeWindowInnerLocked来删
除它们，以便可以回收它们所占用的内存。

       2. 调用后，检查系统中是否有窗口需要移除。如果有的话，那么WindowManagerService类的成员变量mPendingRemove所描述的
一个ArrayList的大小就会大于0。这种情况下，WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked就会调用另
外一个成员函数removeWindowInnerLocked来移除这些窗口。注意，WindowManagerService类的成员函数removeWindowInnerLocked只是
用来移除窗口，但是并没有回收这些窗口所占用的内存。等到合适的时候，例如，内存不足时，才会考虑回收这些窗口所占用的内存。
移除一个窗口的操作也是很复杂的，除了要将窗口从WindowManagerService类的相关成员变量中移除之外，还要考虑重新调整输入法窗
口和壁纸窗口，因为被移除的窗口可能要求显示壁纸和输入法窗口，当它被移除之后，就要将壁纸窗口和输入法窗口调整到合适的Z轴位
置上去，以便可以交给下一个需要显示壁纸和输入法窗口的窗口使用。此外，在移除了窗口之后，WindowManagerService服务还需要重
新计算现存的其它窗口的Z轴位置，以便可以正确地反映系统当前的UI状态，这是通过调用WindowManagerService类的成员函数
assignLayersLocked来实现的。重新计算了现存的其它窗口的Z轴位置之后，又需要再次刷新系统的UI，即要对WindowManagerService类
的成员函数performLayoutAndPlaceSurfacesLocked进行递归调用，并且在调用前，将WindowManagerService类的成员变量
mLayoutNeeded的值设置为true。由此就可见，系统UI的刷新过程是非常复杂的。

       注意，为了防止在刷新系统UI的过程中被重复调用，WindowManagerService类的成员函数
performLayoutAndPlaceSurfacesLocked在刷新系统UI之前，即调用成员函数performLayoutAndPlaceSurfacesLockedInner之前，会将
WindowManagerService类的成员变量mInLayout的值设置为true，并且在调用之后，重新将这个成员变量的值设置为false。这样，
WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked就可以在一开始的时候检查成员变量mInLayout的值是否等
于true，如果等于的话，那么就说明WindowManagerService服务正在刷新系统UI的过程中，于是就不用往下执行了。

       接下来，我们就继续分析WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLockedInner的实现，以便可以了
解Activity窗口的大小计算过程。

       Step 6. WindowManagerService.performLayoutAndPlaceSurfacesLockedInner

public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final void performLayoutAndPlaceSurfacesLockedInner(
            boolean recoveringMemory) {
        ......

        Surface.openTransaction();
        ......

        try {
            ......
            int repeats = 0;
            int changes = 0;
            
            do {
                repeats++;
                if (repeats > 6) {
                    ......
                    break;
                }

                // FIRST LOOP: Perform a layout, if needed.
                if (repeats < 4) {
                    changes = performLayoutLockedInner();
                    if (changes != 0) {
                        continue;
                    }
                } else {
                    Slog.w(TAG, "Layout repeat skipped after too many iterations");
                    changes = 0;
                }

                // SECOND LOOP: Execute animations and update visibility of windows.
                ......
                
            } while (changes != 0);

            // THIRD LOOP: Update the surfaces of all windows.
                
            ......
        } catch (RuntimeException e) {
            ......
        }

        ......

        Surface.closeTransaction();

        ......

        // Destroy the surface of any windows that are no longer visible.
        ......

        // Time to remove any exiting tokens?
        ......

        // Time to remove any exiting applications?
        ......
    }

    ......
}

        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。

        WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLockedInner是一个巨无霸的函数，它一共有1200+行代码
，承载了WindowManagerService服务的核心功能。对于这样一个巨无霸函数，要逐行地分析它的实现是很困难的，因为要理解各种上下
文信息，才可以清楚地知道它的执行过程。这里我们就大概地分析它的实现框架，以后再逐步地分析它的具体实现：

        1. 在一个最多执行7次的while循环中，做两件事情：第一件事情是计算各个窗品的大小，这是通过调用另外一个成员函数
performLayoutLockedInner来实现的；第二件事情是执行窗口的动画，主要是处理窗口的启动窗口显示动画和窗口切换过程中的动画，
以及更新各个窗口的可见性。注意，每一次while循环执行之后，如果发现系统中的各个窗口的相应布局属性不再发生变化，那么就不行
执行下一次的while循环了，即该while循环可能不用执行7次就结束了。窗口的动画显示过程和窗口的可见性更新过程是相当复杂的，它
们也是WindowManagerService服务最为核的地方，在后面的文章中，我们再详细分析。

        2. 经过第1点的操作之后，接下来就可以将各个窗口的属性，例如，大小、位置等属性，通知SurfaceFlinger服务了，也就是
让SurfaceFlinger服务更新它里面的各个Layer的属性值，以便可以对这些Layer执行可见性计算、合成等操作，最后渲染到硬件帧缓冲
区中去。SurfaceFlinger服务计算系统中各个窗口，即各个Layer的可见性，以便将它们合成、渲染到硬件帧缓冲区的过程可以参考前面
Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析一文。注意，各个窗口的属性更新操作是被包含在
SurfaceFlinger服务的一个事务中的，即一个Transaction中，这样做是为了避免每更新一个窗口的一个属性就触发SurfaceFlinger服务
重新计算各个Layer的可见性，以及对各个Layer进行合并和渲染的操作。启动SurfaceFlinger服务的一个事务可以通过调用Surface类的
静态成员函数openTransaction来实现，而关闭SurfaceFlinger服务的一个事务可以通过调用Surface类的静态成员函数
closeTransaction来实现。

       3. 经过第1点和第2点的操作之后，一次系统UI的刷新过程就完成了，这时候就会将系统中的那些不会再显示的窗口的绘图表面
销毁掉，并且将那些已经完成退出了的窗口令牌，即将我们在前面Android应用程序窗口（Activity）与WindowManagerService服务的连
接过程分析一文中所提到的WindowToken移除掉，以及将那些已经退出了的Activity窗口令牌，即将我们在前面Android应用程序窗口（
Activity）与WindowManagerService服务的连接过程分析一文中所提到的AppWindowToken也移除掉。这一步实际执行的是窗口清理操作
。

       上述三个操作是WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLockedInner的实现关键所在，理解了这三
个操作，基本也就可以理解WindowManagerService服务刷新系统UI的过程了。

       接下来，我们继续分析WindowManagerService类的成员函数performLayoutLockedInner的实现，以便可以继续了解Activity窗口
的大小计算过程。

       Step 7. WindowManagerService.performLayoutLockedInner

public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    final WindowManagerPolicy mPolicy = PolicyManager.makeNewWindowManager();
    ......

    /**
     * Z-ordered (bottom-most first) list of all Window objects.
     */
    final ArrayList<WindowState> mWindows = new ArrayList<WindowState>();
    ......

    private final int performLayoutLockedInner() {
        ......

        final int dw = mDisplay.getWidth();
        final int dh = mDisplay.getHeight();

        final int N = mWindows.size();
        int i;

        ......

        mPolicy.beginLayoutLw(dw, dh);

        int seq = mLayoutSeq+1;
        if (seq < 0) seq = 0;
        mLayoutSeq = seq;

        // First perform layout of any root windows (not attached
        // to another window).
        int topAttached = -1;
        for (i = N-1; i >= 0; i--) {
            WindowState win = mWindows.get(i);
            ......

            final AppWindowToken atoken = win.mAppToken;
            final boolean gone = win.mViewVisibility == View.GONE
                    || !win.mRelayoutCalled
                    || win.mRootToken.hidden
                    || (atoken != null && atoken.hiddenRequested)
                    || win.mAttachedHidden
                    || win.mExiting || win.mDestroying;
            ......

            if (!gone || !win.mHaveFrame) {
                if (!win.mLayoutAttached) {
                    mPolicy.layoutWindowLw(win, win.mAttrs, null);
                    win.mLayoutSeq = seq;
                    ......
                } else {
                    if (topAttached < 0) topAttached = i;
                }
            }
        }
        ......

        for (i = topAttached; i >= 0; i--) {
            WindowState win = mWindows.get(i);

            // If this view is GONE, then skip it -- keep the current
            // frame, and let the caller know so they can ignore it
            // if they want.  (We do the normal layout for INVISIBLE
            // windows, since that means "perform layout as normal,
            // just don't display").
            if (win.mLayoutAttached) {
                ......

                if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled)
                        || !win.mHaveFrame) {
                    mPolicy.layoutWindowLw(win, win.mAttrs, win.mAttachedWindow);
                    win.mLayoutSeq = seq;
                    ......
                }
            }
        }

        ......

        return mPolicy.finishLayoutLw();
    }

    ......
}

        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。

        在分析WindowManagerService类的成员函数performLayoutLockedInner的实现之前，我们首先介绍WindowManagerService类的
两个成员变量mPolicy和mWindows：

        1. mPolicy指向的是一个窗口管理策略类，它是通过调用PolicyManager类的静态成员函数makeNewWindowManager来初始化的，
在Phone平台中，它指向的是便是一个PhoneWindowManager对象，主要是用来制定窗口的大小计算策略。

        2. mWindows指向的是一个类型为WindowState的ArrayList，它里面保存的就是系统中的所有窗口，这些窗口是按照Z轴位置从
小到大的顺序保存在这个ArrayList中的，也就是说，第i个窗口位于第i-1个窗口的上面，其中，i > 0。

        理解了这两个成员变量的含义之后，我们就分析WindowManagerService类的成员函数performLayoutLockedInner的执行过程，
主要是分三个阶段：

        1. 准备阶段：调用PhoneWindowManager类的成员函数beginLayoutLw来设置屏幕的大小。屏幕的大小可以通过调用
WindowManagerService类的成员变量mDisplay所描述的一个Display对象的成员函数getWidth和getHeight来获得。

        2. 计算阶段：调用PhoneWindowManager类的成员函数layoutWindowLw来计算各个窗口的大小、内容区域边衬大小以及可见区域
边衬大小。

        3. 结束阶段：调用PhoneWindowManager类的成员函数finishLayoutLw来执行一些清理工作。

        按照父子关系来划分，系统中的窗口可以分为父窗口和子窗口两种。如果一个WindowState对象的成员变量mLayoutAttached的
值等于false，那么它所描述的窗口就可以作为一个父窗口，否则的话，它所描述的窗口就是一个子窗口。由于子窗口的大小计算是依赖
于其父窗口的，因此，在计算各个窗口的大小的过程中，即在上述的第2阶段中，按照以下方式来进行：

        1.  先计算父窗口的大小。一般来说，能够作为父窗口的，是那些Activity窗口。从前面Android应用程序窗口（Activity）与
WindowManagerService服务的连接过程分析一文可以知道，如果一个窗口是Activity窗口，那么用来描述它的一个WindowState对象的成
员变量mAppToken就不等于null，并且指向的是一个AppWindowToken对象。这个AppWindowToken对象主要是用来描述一个Activity，即与
ActivityManagerService服务中的一个ActivityRecord对象对应。一个Activity窗口只有在两种情况下才会被计算大小：第一种情况是
窗口不是处于不可见状态的；第二种情况是窗口从来还没有被计算过大小，即用来描述该Activity窗口的WindowState对象的成员变量
mHaveFrame的值等于false，这种情况一般发生在窗口刚刚被添加到WindowManagerService的过程中。一个Activity窗口的不可见状态由
它本身的状态、它所在的窗口结构树状态以及它所属的Activity的状态有关，也就是说，如果一个Activity窗口本身是可见的，但是由
于它的父窗口、它所在的窗口组的根窗口或者它所属的Activity是不可见的，那么该Activity窗口也是不可见的。一个Activity窗口的
不可见状态由以下因素决定：

        1). 它本身处于不可见状态，即对应的WindowState对象的成员变量mViewVisibility的值等于View.GONE；

        2). 它本身处于正在退出的状态，即对应的WindowState对象的成员变量mExiting的值等于true；

        3). 它本身处于正在销毁的状态，即对应的WindowState对象的成员变量mDestroying的值等于true；

        4). 它的父窗口处于不可见状态，即对应的WindowState对象的成员变量mAttachedHidden的值等于true；

        5). 它所在窗口结构树中的根窗口处于不可见状态，即对应的WindowState对象的成员变量mRootToken所描述的一个
WindowToken对象的成员变量hidden的值等于true；

        6). 它所属的Activity处于不可见状态，即对应的WindowState对象的成员变量mAppToken所描述的一个AppWindowToken对象的
成员变量hiddenRequested的值等于true。

        除了上述六个因素之外，如果一个Activity窗口没有被它所运行在的应用程序进程主动请求WindowManagerService服务对它进
行布局，即对应的WindowState对象的成员变量mRelayoutCalled的值等于false，那么此时也是不需要计算Activity窗口的大小的。

       一个Activity窗口的大小一旦确定是需要计算大小之后，PhoneWindowManager类的成员函数layoutWindowLw就被调用来计算它的
大小。

       2. 接着计算子窗口的大小。前面在计算父窗口的大小过程中，会记录位于系统最上面的一个子窗口在mWindows所描述的一个
ArrayList的位置topAttached，接下来就可以从这个位置开始向下计算每一个子窗口的大小。一个子窗口在以下两种情况下，才会被计
算大小：

       1). 它本身处于可见状态，即对应的WindowState对象的成员变量mViewVisibility的值不等于View.GONE，并且它所运行在的应
用程序进程主动请求WindowManagerService服务对它进行布局，即对应的WindowState对象的成员变量mRelayoutCalled的值等于true。

       2). 它从来还没有被计算过大小，即用来描述该子窗口的WindowState对象的成员变量mHaveFrame的值等于false，这种情况一般
发生在子窗口刚刚被添加到WindowManagerService的过程中。

       接下来，我们就分别分析PhoneWindowManager类的成员函数beginLayoutLw、layoutWindowLw和finishLayoutLw的实现，以便可
以了解Activity窗口的大小计算过程。

       Step 8. PhoneWindowManager.beginLayoutLw

public class PhoneWindowManager implements WindowManagerPolicy {
    ......

    WindowState mStatusBar = null;
    ......

    // The current size of the screen.
    int mW, mH;
    // During layout, the current screen borders with all outer decoration
    // (status bar, input method dock) accounted for.
    int mCurLeft, mCurTop, mCurRight, mCurBottom;
    // During layout, the frame in which content should be displayed
    // to the user, accounting for all screen decoration except for any
    // space they deem as available for other content.  This is usually
    // the same as mCur*, but may be larger if the screen decor has supplied
    // content insets.
    int mContentLeft, mContentTop, mContentRight, mContentBottom;
    // During layout, the current screen borders along with input method
    // windows are placed.
    int mDockLeft, mDockTop, mDockRight, mDockBottom;
    // During layout, the layer at which the doc window is placed.
    int mDockLayer;
    
    static final Rect mTmpParentFrame = new Rect();
    static final Rect mTmpDisplayFrame = new Rect();
    static final Rect mTmpContentFrame = new Rect();
    static final Rect mTmpVisibleFrame = new Rect();
    ......

    public void beginLayoutLw(int displayWidth, int displayHeight) {
        mW = displayWidth;
        mH = displayHeight;
        mDockLeft = mContentLeft = mCurLeft = 0;
        mDockTop = mContentTop = mCurTop = 0;
        mDockRight = mContentRight = mCurRight = displayWidth;
        mDockBottom = mContentBottom = mCurBottom = displayHeight;
        mDockLayer = 0x10000000;

        // decide where the status bar goes ahead of time
        if (mStatusBar != null) {
            final Rect pf = mTmpParentFrame;
            final Rect df = mTmpDisplayFrame;
            final Rect vf = mTmpVisibleFrame;
            pf.left = df.left = vf.left = 0;
            pf.top = df.top = vf.top = 0;
            pf.right = df.right = vf.right = displayWidth;
            pf.bottom = df.bottom = vf.bottom = displayHeight;

            mStatusBar.computeFrameLw(pf, df, vf, vf);
            if (mStatusBar.isVisibleLw()) {
                // If the status bar is hidden, we don't want to cause
                // windows behind it to scroll.
                mDockTop = mContentTop = mCurTop = mStatusBar.getFrameLw().bottom;
                ......
            }
        }
    }
 
    ......
}

        这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中。

        在分析PhoneWindowManager类的成员函数beginLayoutLw的实现之前，我们首先介绍PhoneWindowManager类的五组成员变量。

        第一组成员变量是mW和mH，它们分别用来描述当前这轮窗口大小计算过程的屏幕宽度和高度。

        第二组成员变量是mCurLeft、mCurTop、mCurRight和mCurBottom，它们组成一个四元组（mCurLeft, mCurTop, mCurRight,
mCurBottom），用来描述当前这轮窗口大小计算过程的屏幕装饰区，它对应于前面所提到的Activity窗口的可见区域边衬。

        第三组成员变量是mContentLeft、mContentTop、mContentRight和mContentBottom，它们组成一个四元组（mContentLeft,
mContentTop, mContentRight, mContentBottom），也是用来描述当前这轮窗口大小计算过程的屏幕装饰区，不过它对应的是前面所提
到的Activity窗口的内容区域边衬。

        第四组成员变量是mDockLeft、mDockTop、mDockRight、mDockBottom和mDockLayer，其中，前四个成员变量组成一个四元组（
mDockLeft, mDockTop, mDockRight, mDockBottom），用来描述当前这轮窗口大小计算过程中的输入法窗口所占据的位置，后一个成员
变量mDockLayer用来描述输入法窗品的Z轴位置。

        第五组成员变量是mTmpParentFrame、mTmpDisplayFrame、mTmpContentFrame和mTmpVisibleFrame，它们是一组临时Rect区域，
用来作为参数传递给具体的窗口计算大小的，避免每次都创建一组新的Rect区域来作来参数传递窗口。

        除了这五组成员变量之外，PhoneWindowManager类还有一个成员变量mStatusBar，它的类型为WindowState，用来描述系统的状
态栏。

        理解了这些成员变量的含义之后，PhoneWindowManager类的成员函数beginLayoutLw的实现就容易理解了，它主要做了以下两件
事情：

        1. 初始化前面所提到的四组成员变量，其中，mW和mH设置为参数displayWidth和displayHeight所指定的屏幕宽度和高度，并
且使得（mCurLeft, mCurTop, mCurRight, mCurBottom）、（mContentLeft, mContentTop, mContentRight, mContentBottom）和（
mDockLeft, mDockTop, mDockRight, mDockBottom）这三个区域的大小等于屏幕的大小。

        2. 计算状态栏的大小。状态栏的大小一经确定，并且它是可见的，那么就会修改成员变量mCurLeft、mContentLeft和
mDockLeft的值为状态栏的所占据的区域的下边界位置，这样就可以将（mCurLeft, mCurTop, mCurRight, mCurBottom）、（
mContentLeft, mContentTop, mContentRight, mContentBottom）和（mDockLeft, mDockTop, mDockRight, mDockBottom）这三个区域
限制为剔除状态栏区域之后所得到的屏幕区域。

        还有另外一个地方需要注意的是，输入法窗口的Z轴被初始化为0x10000000，这个值是相当大的了，可以保证输入法窗口作为顶
层窗口出现。

        这一步执行完成之后，返回到前面的Step 7中，即WindowManagerService类的成员函数performLayoutLockedInner，接下来就
会调用PhoneWindowManager类的成员函数layoutWindowLw来计算系统中各个可见窗口的大小。

        Step 9. PhoneWindowManager.layoutWindowLw

public class PhoneWindowManager implements WindowManagerPolicy {
    ......

    public void layoutWindowLw(WindowState win, WindowManager.LayoutParams attrs,
            WindowState attached) {
        // we've already done the status bar
        if (win == mStatusBar) {
            return;
        }
        ......

        final int fl = attrs.flags;
        final int sim = attrs.softInputMode;

        final Rect pf = mTmpParentFrame;
        final Rect df = mTmpDisplayFrame;
        final Rect cf = mTmpContentFrame;
        final Rect vf = mTmpVisibleFrame;

        if (attrs.type == TYPE_INPUT_METHOD) {
            pf.left = df.left = cf.left = vf.left = mDockLeft;
            pf.top = df.top = cf.top = vf.top = mDockTop;
            pf.right = df.right = cf.right = vf.right = mDockRight;
            pf.bottom = df.bottom = cf.bottom = vf.bottom = mDockBottom;
            // IM dock windows always go to the bottom of the screen.
            attrs.gravity = Gravity.BOTTOM;
            mDockLayer = win.getSurfaceLayer();
        } else {
            if ((fl &
                    (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR))
                    == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
                // This is the case for a normal activity window: we want it
                // to cover all of the screen space, and it can take care of
                // moving its contents to account for screen decorations that
                // intrude into that space.
                if (attached != null) {
                    // If this window is attached to another, our display
                    // frame is the same as the one we are attached to.
                    setAttachedWindowFrames(win, fl, sim, attached, true, pf, df, cf, vf);
                } else {
                    pf.left = df.left = 0;
                    pf.top = df.top = 0;
                    pf.right = df.right = mW;
                    pf.bottom = df.bottom = mH;
                    if ((sim & SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
                        cf.left = mDockLeft;
                        cf.top = mDockTop;
                        cf.right = mDockRight;
                        cf.bottom = mDockBottom;
                    } else {
                        cf.left = mContentLeft;
                        cf.top = mContentTop;
                        cf.right = mContentRight;
                        cf.bottom = mContentBottom;
                    }
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                }
            }

            ......
        }

        win.computeFrameLw(pf, df, cf, vf);

        // Dock windows carve out the bottom of the screen, so normal windows
        // can't appear underneath them.
        if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
            int top = win.getContentFrameLw().top;
            top += win.getGivenContentInsetsLw().top;
            if (mContentBottom > top) {
                mContentBottom = top;
            }
            top = win.getVisibleFrameLw().top;
            top += win.getGivenVisibleInsetsLw().top;
            if (mCurBottom > top) {
                mCurBottom = top;
            }
            ......
        }
    }

    ......
}

        这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中。

        第一个参数win描述的是当前要计算大小的窗口，第二个参数attrs描述的是窗口win的布局参数，第三个参数attached描述的是
窗口win的父窗口，如果它的值等于null，就表示窗口win没有父窗口。

        PhoneWindowManager类的成员函数layoutWindowLw会根据窗口win的是子窗口还是全屏窗口及其软键盘显示模式来决定它的大小
如何计算。这里我们只关注输入法窗口和非全屏的Activity窗口的大小计算方式，其它类型的窗口大小计算方式是差不多的。

        从前面的Step 8可以知道，系统的状态栏大小已经计算过了，因此，PhoneWindowManager类的成员函数layoutWindowLw如果发
现参数win描述的正好是状态栏的话，它就什么也不做就返回了。

        在计算一个窗口的大小的时候，我们需要四个参数。第一个参数是父窗口的大小pf，第二个参数是屏幕的大小df，第三个参数
是内容区域边衬大小cf，第四个参数是可见区域边衬大小vf。 

        如果参数win描述的是输入法窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于
TYPE_INPUT_METHOD，那么上述四个用来计算窗口大小的区域pf、df、cf和vf就等于PhoneWindowManager类的成员变量mDockLeft、
mDockTop、mDockRight和mDockBottom所组成的区域的大小。

        如果参数win描述的是一个非全屏的Activity窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量
flags的FLAG_LAYOUT_IN_SCREEN位和FLAG_LAYOUT_INSET_DECOR位等于1，那么PhoneWindowManager类的成员函数layoutWindowLw就会继
续检查参数attached的值是否不等于null。如果不等于null的话，那么就说明参数win所描述的一个非全屏的Activity窗口附加在其它窗
口上，即它具有一个父窗口，这时候就会调用另外一个成员函数setAttachedWindowFrames来计算它的大小。 

        接下来我们就只关注参数win描述的是一个非全屏的、并且没有附加到其它窗口的Activity窗口的大小计算过程。

        首先，父窗口大小pf和屏幕大小df都会被设置为整个屏幕区域的大小。

        其次，可见区域边衬大小vf被设置为PhoneWindowManager类的成员变量mCurLeft、mCurTop、mCurRight和mCurBottom所组成的
区域的大小。

        第三，内容区域边衬大小cf的计算相对复杂一些，需要考虑窗口win的软键盘显示模式sim的值。如果变量sim的
SOFT_INPUT_ADJUST_RESIZE位等于1，那么就意味着窗口win在出向输入法窗口的时候，它的内容要重新进行排布，避免被输入法窗口挡
住，因此，这时候窗口win的内容区域大小就会等于PhoneWindowManager类的成员变量mContentLeft、mContentTop、mContentRight和
mContentBottom所组成的区域的大小。另一方面，如果变量sim的SOFT_INPUT_ADJUST_RESIZE位等于0，那么就意味着窗口win在出向输入
法窗口的时候，它的内容不需要重新进行排布，这时候它的内容区域大小就会等于PhoneWindowManager类的成员变量mDockLeft、
mDockTop、mDockRight和mDockBottom所组成的区域的大小。注意，PhoneWindowManager类的成员变量mDockLeft、mDockTop、
mDockRight和mDockBottom所组成的区域的大小并不是等于输入法窗口的大小的，而是包含了输入法窗口所占据的区域的大小，这就意味
着输入法窗口与窗口win会有重叠的部分，或者说输入法窗口覆盖了窗口win的一部分。

        得到了用来计算窗口win四个参数pf、 df、cf和vf之后，就可以调用参数win所描述的一个WindowState对象的成员函数
computeFrameLw来计算窗口win的具体大小了。计算的结果便得到了窗口win的大小，以及它的内容区域边衬大小和可见区域边衬大小。
注意，窗口经过计算后得到的内容区域边衬大小和可见区域边衬大小并不一定是等于参数cf和vf所指定的大小的。

        计算完成窗口win的大小之后，PhoneWindowManager类的成员函数layoutWindowLw还会检查窗口win是否是一个输入法窗口，并
且它是否指定了额外的内容区域边衬和可见区域边衬。如果这两个条件都成立的话，那么就需要相应地调整PhoneWindowManager类的成
员变量mContentBottom和mCurBottom的值，以便使得PhoneWindowManager类的成员变量是mContentLeft、mContentTop、mContentRight
和mContentBottom所围成的内容区域和成员变量mCurLeft、mCurTop、mCurRight和mCurBottom所围成的可见区域不会覆盖到输入法窗口
额外指定的内容区域边衬和可见区域边衬。

        接下来，我们就继续分析WindowState类的成员函数computeFrameLw的实现，以便可以了解Activity窗口的大小计算的具体过程
。

        Step 10. WindowState.computeFrameLw

public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class WindowState implements WindowManagerPolicy.WindowState {
        ......

        boolean mHaveFrame;
        ......

        // "Real" frame that the application sees.
        final Rect mFrame = new Rect();
        ......

        final Rect mContainingFrame = new Rect();
        final Rect mDisplayFrame = new Rect();
        final Rect mContentFrame = new Rect();
        final Rect mVisibleFrame = new Rect();

        public void computeFrameLw(Rect pf, Rect df, Rect cf, Rect vf) {
            mHaveFrame = true;

            final Rect container = mContainingFrame;
            container.set(pf);

            final Rect display = mDisplayFrame;
            display.set(df);

            if ((mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                container.intersect(mCompatibleScreenFrame);
                if ((mAttrs.flags & FLAG_LAYOUT_NO_LIMITS) == 0) {
                    display.intersect(mCompatibleScreenFrame);
                }
            }

            final int pw = container.right - container.left;
            final int ph = container.bottom - container.top;

            int w,h;
            if ((mAttrs.flags & mAttrs.FLAG_SCALED) != 0) {
                w = mAttrs.width < 0 ? pw : mAttrs.width;
                h = mAttrs.height< 0 ? ph : mAttrs.height;
            } else {
                w = mAttrs.width == mAttrs.MATCH_PARENT ? pw : mRequestedWidth;
                h = mAttrs.height== mAttrs.MATCH_PARENT ? ph : mRequestedHeight;
            }

            final Rect content = mContentFrame;
            content.set(cf);

            final Rect visible = mVisibleFrame;
            visible.set(vf);

            final Rect frame = mFrame;
            final int fw = frame.width();
            final int fh = frame.height();

            ......

            Gravity.apply(mAttrs.gravity, w, h, container,
                    (int) (mAttrs.x + mAttrs.horizontalMargin * pw),
                    (int) (mAttrs.y + mAttrs.verticalMargin * ph), frame);

            ......

            // Now make sure the window fits in the overall display.
            Gravity.applyDisplay(mAttrs.gravity, df, frame);

            // Make sure the content and visible frames are inside of the
            // final window frame.
            if (content.left < frame.left) content.left = frame.left;
            if (content.top < frame.top) content.top = frame.top;
            if (content.right > frame.right) content.right = frame.right;
            if (content.bottom > frame.bottom) content.bottom = frame.bottom;
            if (visible.left < frame.left) visible.left = frame.left;
            if (visible.top < frame.top) visible.top = frame.top;
            if (visible.right > frame.right) visible.right = frame.right;
            if (visible.bottom > frame.bottom) visible.bottom = frame.bottom;

            final Rect contentInsets = mContentInsets;
            contentInsets.left = content.left-frame.left;
            contentInsets.top = content.top-frame.top;
            contentInsets.right = frame.right-content.right;
            contentInsets.bottom = frame.bottom-content.bottom;

            final Rect visibleInsets = mVisibleInsets;
            visibleInsets.left = visible.left-frame.left;
            visibleInsets.top = visible.top-frame.top;
            visibleInsets.right = frame.right-visible.right;
            visibleInsets.bottom = frame.bottom-visible.bottom;

            if (mIsWallpaper && (fw != frame.width() || fh != frame.height())) {
                updateWallpaperOffsetLocked(this, mDisplay.getWidth(),
                        mDisplay.getHeight(), false);
            }

            ......
        }

        ......
    }

    ......
}

        这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。

        WindowState类的成员变量mHaveFrame用来描述一个窗口的大小是否计算过了。当WindowState类的成员函数computeFrameLw被
调用的时候，就说明一个相应的窗口的大小得到计算了，因此，WindowState类的成员函数computeFrameLw一开始就会将成员变量
mHaveFrame的值设置为true。

        回忆一下，在前面的Step 9中提到，参数pf描述的是父窗口的大小，参数df描述的是屏幕的大小，参数cf描述的内容区域大小
，参数vf描述的是可见区域大小，接下来我们就分析WindowState类的成员函数computeFrameLw是如何利用这些参数来计算一个窗口的大
小的。

        WindowState类的成员变量mContainingFrame和mDisplayFrame描述的是当前正在处理的窗口的父窗口和屏幕的大小，它们刚好
就分别等于参数pf和df的大小，因此，函数就直接将参数pf和df的值分别保存在WindowState类的成员变量mContainingFrame和
mDisplayFrame中。如果当前正在处理的窗口运行在兼容模式，即WindowState类的成员变量mAttrs所指向的一个
WindowManager.LayoutParams对象的成员变量flags的FLAG_COMPATIBLE_WINDOW位等于1，那么就需要将其父窗口的大小限制
mContainingFrame在兼容模式下的屏幕区域中。兼容模式下的屏幕区域保存在WindowManagerService类的成员变量
mCompatibleScreenFrame中，将父窗口的大小mContainingFrame与它执行一个相交操作，就可以将父窗品的大小限制兼容模式下的屏幕
区域中。在当前正在处理的窗口运行在兼容模式的情况下，如果它的大小被限制在了兼容模式下的屏幕区域之中，即WindowState类的成
员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量flags的FLAG_LAYOUT_NO_LIMITS位等于0，那么同样需要将屏幕
大小mDisplayFrame限制在兼容模式下的屏幕区域mCompatibleScreenFrame，这也是通过执行一个相交操作来完成的。

        WindowState类的成员变量mContentFrame和mVisibleFrame描述的是当前正在处理的窗口的内容区域和可见区域大小，它们刚好
就分别等于参数cf和vf的大小，因此，函数就直接将参数cf和vf的值分别保存在WindowState类的成员变量mContainingFrame和
mDisplayFrame中。现在，就剩下窗口的大小还没有计算。一旦窗口大小确定下来之后，就可以继续计算窗口的内容区域边衬和可见区域
边衬大小了。接下来我们就继续分析窗口大小的计算过程。

         WindowState类的成员变量mFrame描述的就是当前正在处理的窗品的大小，我们的目标就是计算它的值。一个窗口的大小是受
以下因素影响的：

         1. 是否指定了缩放因子。如果一个窗口的大小被指定了缩放因子，即WindowState类的成员变量mAttrs所指向的一个
WindowManager.LayoutParams对象的成员变量flags的FLAG_SCALED位等于1，那么该窗口的大小就是在它的布局参数中指定的，即是由
WindowState类的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量width和height所指定的。但是，如果在布
局参数中指定的窗口宽度或者高度小于0，那么就会使用其父窗口的大小来作为当前窗口的大小。当前窗口的父窗口的宽度和高度分别保
存在变量pw和ph中。

         2. 是否指定了等于父窗口的大小。如果一个窗口的大小被指定为其父窗口的大小，即WindowState类的成员变量mAttrs所指向
的一个WindowManager.LayoutParams对象的成员变量width和height的值等于mAttrs.MATCH_PARENT，那么该窗口的大小就会等于其父窗
口的大小，即等于变量pw和ph所描述的宽度和高度。另一方面，如果一个窗口的大小没有指定为其父窗口的大小的话，那么它的大小就
会等于应用程序进程请求WindowManagerService所设置的大小，即等于WindowState类的成员变量mRequestedWidth和mRequestedHeight
所描述的宽度和高度。

         经过上述2个操作之后，我们就初步地得到了窗口的宽度w和高度h，但是，它们还不是最终的窗口大小，还要进一步地根据窗
口的Gravity属性来作调整，这个调整分两步进行：

        1. 根据窗口的Gravity值，以及位置、初始大小和父窗口大小，来计算窗口的大小，并且保存在变量frame中，即保存在
WindowState类的成员变量mFrame中，这是通过调用Gravity类的静态成员函数apply来实现的。其中，窗口的初始大小保存在变量w和h中
，父窗口大小保存在变量container中，即WindowState类的成员变量mContainingFrame中，位置保存在WindowState类的成员变量mAttrs
所指向的一个WindowManager.LayoutParams对象的成员变量x和y中。注意，如果窗口指定了相对父窗口的margin值，那么还需要相应的
调整其位置值，即要在指定的位置值的基础上，再加上相对父窗口的margin值。一个窗口相对父窗口的margion是通过一个百分比来表示
的，用这个百分比乘以父窗口的大小就可以得到绝对值。这个百分比又分为在水平方向和垂直方向两个值，分别保存在WindowState类的
成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量horizontalMargin和verticalMargin中。

        2. 前面计算得到的窗口大小没有考虑在屏幕的大小，因此，接下来还需要继续调用Gravity类的静态成员函数applyDisplay来
将前面计算得到的窗口大小限制在屏幕区域df中，即限制在WindowState类的成员变量mDisplayFrame所描述的区域中。

        经过上述2个操作之后，窗口的最终大小就保存在变量frame中了，即WindowState类的成员变量mFrame中，接下来就可以计算窗
品的内容区域边衬和可见区域边衬大小了。

        内容区域边衬和可见区域边衬大小的计算很简单的，只要将窗口的大小frame，即WindowState类的成员变量mFrame所描述的区
域，分别减去变量content和visible，即WindowState类的成员变量mContentFrame和mVisibleFrame所描述的区域，就可以得到窗口的内
容区域边衬和可见区域边衬大小，它们分别保存在WindowState类的成员变量mContentInsets和mVisibleInsets中。注意，在计算窗口的
内容区域边衬和可见区域边衬大小之前，首先要保证窗口的内容区域和可见区域包含在整个窗口区域中，这一点是由中间的8个if语句来
保证的。

        窗口上一次的大小保存在变量fw和fh中。如果当前正在处理的窗口是一个壁纸窗口，即WindowState类的成员变量mIsWallpaper
的值等于true，并且该窗口的大小发生了变化，即变量fw和fh的所描述的窗口大小不等于变量frame描述的窗口大小，那么就需要调用
WindowManagerService类的成员函数updateWallpaperOffsetLocked来更新壁纸的位置。在后面的文章中，我们再详细描述系统的壁纸窗
口的位置是如何计算的。

        这一步执行完成之后，一个窗口的大小就计算完成了。从计算的过程可以知道，整个窗口大小保存在WindowState类的成员变量
mFrame中，而窗品的内容区域边衬大小和可见区域边衬大小分别保在WindowState类的成员变量mContentInsets和mVisibleInsets中。这
些值最终会通过前面的Step 4返回给应用程序进程。

        返回到前面的Step 7中，即WindowManagerService类的成员函数performLayoutLockedInner，接下来就会调用
PhoneWindowManager类的成员函数finishLayoutLw来结束当前这轮窗口大小的计算工作。

        Step 11. PhoneWindowManager.finishLayoutLw

public class PhoneWindowManager implements WindowManagerPolicy {
    ......

    public int finishLayoutLw() {
        return 0;
    }

    ......
}

        这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中。

        PhoneWindowManager类的成员函数finishLayoutLw是设计来结束一轮窗口大小的计算过程中，不过目前它什么也不做，只是一
个空实现。

        至此，我们就分析完成Activity窗口的大小计算过程了。从这个计算过程中，我们就可以知道一个Activity窗口除了有一个整
体大小之外，还有一个内容区域边衬大小和一个可见区域边衬大小。此外，我们还知道，一个Activity窗口的内容区域边衬大小和可见
区域边衬大小是可能会受到与其所关联的输入法窗口的影响的，因为输入法窗口会叠加在该Activity窗口上面，这就涉及到了系统中的
窗口的组织方式。在接下来的一篇文章中，我们就将继续分析WindowManagerService服务是如何组织系统中的窗口的。敬请关注！
#+END_QUOTE
** Zygote
*** DONE Java Process Creation
    CLOSED: [2011-03-01 Tue 11:20]
    - State "DONE"       [2011-03-01 Tue 11:20]
#+BEGIN_EXAMPLE lang:c
    AMS::startSpecificActivity()
      Process::start(className,uid..)
         Process::startViaZygote()
            Pro::zygoteSendArgAndGetPid()
               for zygote socket read pid
#+END_EXAMPLE
    zygote socket:
#+BEGIN_EXAMPLE lang:c
        runSelectLoopMode()
          got request form socket
             runOnce()
	       forkAndSpecialize(int uid, int gid, int[] gids..)
	         - uid: the UNIX uid that the new process should setuid() to after fork()ing and and before spawning any threads.
                 - gid: the UNIX gid that the new process should setgid() to after fork()ing and and before spawning any threads.
                 - gids: null-ok; a list of UNIX gids that the new process should setgroups() to after fork and before spawning any threads.
		   because zygote runs with root uid, it can setuid/gid/groups freely
                 // in child process
                 handleChildProc()
                   closeSocket();
                   RuntimeInit.zygoteInit(parsedArgs.remainingArgs);
                     commonInit()
                       Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); // NOTE: the UncaughtHandler does nothing but crash the app
                     zygoteInitNative()
                       gCurRuntime->onZygoteInit()
                         proc->startThreadPool();
                     invokeStaticMain();
                in parent process
                    return child pid
#+END_EXAMPLE
*** DONE Zygote init
    CLOSED: [2011-06-30 Thu 16:42]
    - State "DONE"       from ""           [2011-06-30 Thu 16:42]
    see also [[System init]]

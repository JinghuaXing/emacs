* Java
#+CATEGORY:Java
** Top topic
   - Security
   - Collection Framework
   - Memory Model & Concurrent
   - NIO
   - JVM
     - bytecode
     - constant pool
     - linking & loading & ClassLoader
   - JNI
   - GP
   - GC
   - Reflect
   - Module System
** misc
*** DONE [#A] java initialization
    CLOSED: [2011-08-02 Tue 15:28]
    - State "DONE"       from "TODO"       [2011-08-02 Tue 15:28]
    java code:
#+BEGIN_EXAMPLE
	class S {
	    static {
		System.out.println ("super static block");
	    }
	}

	class Test extends S {
	    static {
		System.out.println ("Test static block");
	    }
	    int x=1;
	    public Test () {
		System.out.println ("Test ctor");
		foo ();
	    }
	    public static void main(String args[]) {
		Test t=new Test ();
	    }
	    void foo () {

	    }
	}
#+END_EXAMPLE
    byte code of Test.class
#+BEGIN_EXAMPLE
	public Test();
	  Code:
	   Stack=2, Locals=1, Args_size=1
	   0:   aload_0                                                // put the first argument (this) to operand stack
	   1:   invokespecial   #1; //Method S."<init>":()V;           // call super.<init>
	   4:   aload_0
	   5:   iconst_1
	   6:   putfield        #2; //Field x:I                        // initialize x=1
	   9:   getstatic       #3; //Field java/lang/System.out:Ljava/io/PrintStream;  // The actual ctor: Test()
	   12:  ldc     #4; //String Test ctor
	   14:  invokevirtual   #5; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
	   17:  aload_0
	   18:  invokevirtual   #6; //Method foo:()V
	   21:  return
	static {};
	  Code:
	   Stack=2, Locals=0, Args_size=0
	   0:   getstatic       #3; //Field java/lang/System.out:Ljava/io/PrintStream;
	   3:   ldc     #9; //String Test static block
	   5:   invokevirtual   #5; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
	   8:   return
#+END_EXAMPLE
    To summarize:
    - <init> differs with ctor!
      <init> will:
      1. invoke super.<init>
      2. init member field
      3. call ctor

*** CharSequence vs. String
*** java de-initialization
*** final keyword
*** ConcurrentModificationException
*** DONE fail-fast iterator
    CLOSED: [2011-07-26 Tue 16:16]
    - State "DONE"       from ""           [2011-07-26 Tue 16:16]
    see also [[ConcurrentModificationException]]
    see also [[Immutable Collection]]

    An iterator is considered /fail-fast/ if it throws a /ConcurrentModificationException/ under either the following two conditions:
    1. In multithreaded processing: if one thread is trying to modify a /Collection/ while anther one is iterating over it.
    2. In single-threaded: if after the creating of the /iterator/, the container is modified at any time by any method other than the iterator's own
       remove or add methods

    - code snippet that will throw ConcurrentModificationException:
#+BEGIN_EXAMPLE
      for (Foo o:container) {
        if (o.v==0) {
          container.remove(o);
        }
      }
#+END_EXAMPLE
    - using fail-fast iterator to avoid ConcurrentModificationException:
#+BEGIN_EXAMPLE
      ListIterator ite=container.listIterator();
      while (ite.hasNext()) {
        Foo o=ite.next();
        if (o.v==0) {
          ite.remove();
        }
      }
#+END_EXAMPLE
    - using a copy of container to avoid ConcurrentModificationException: see also [[Immutable Collection]]
#+BEGIN_EXAMPLE
      List tmp=new ArrayList(container);
      for (Foo o:tmp) {
        if (o.v==0) {
          container.remove(o); // this works because of `shallow copy`
        }
      }
#+END_EXAMPLE
*** initialization on-demand holder
    :PROPERTIES:
    :CUSTOM_ID: @initialization on-demand holder
    :END:
#+BEGIN_EXAMPLE
// Correct lazy initialization in Java
    @ThreadSafe
    class Foo {
      private static class HelperHolder {
        public static Helper helper = new Helper();
      }
      public static Helper getHelper() {
        return HelperHolder.helper;
      }
    }
#+END_EXAMPLE
*** DONE java主线程与子线程的关系
    SCHEDULED: <2011-02-09 Wed> CLOSED: [2011-02-09 Wed 17:42]
    - State "DONE"       [2011-02-09 Wed 17:42]
    java 主线程退出后,子线程仍成执行
    linux 主线程退出后,子线程也在执行
*** Java Service Wrapper
*** DOING StringBuffer vs. StringBuilder                      :java:string:

** Java Criticism
   see also [[Immutable Collection]]
   see also [[GP]]
   see also [[GC]]

   - enumeration
   - final
** Tools
   - jps
   - jmap
   - jhat
   - jstack
   - jinfo
   - MAT
   - gcviewer
   - visualvm
   - keytool
   - jarsigner
     http://download.oracle.com/javase/1.3/docs/tooldocs/win32/jarsigner.html
   - javac
   - javah
   - javap -verbose 查看 bytecode
   - java
     可能需要 fastdebug 版本才能使用下列某些命令
     - java -Xcomp -XX:+PrintAssembly -XX:CompileCommand='compileonly A.foo' -XX:CompileCommand='compileonly Test.main' -XX:CompileCommand='compileonly B.foo
     - java -Xint
     - java -Xss4096k Test  // set stack size
     - java -Xms 4096k -Xmx 128m Test // set heap size
     - java -verbose:sizes
     - java -verbose:gc
     - java -XX:+DisableExplicitGC
     - java -client
     - java -server
** Java Language Specification (jls)
   - State "CANCELED"   from "DOING"      [2011-08-29 Mon 17:20]
   CLOCK: [2011-02-16 Wed 17:38]--[2011-02-16 Wed 18:01] =>  0:23
*** String
**** compile-time constant pool
     all reference to the same compile-time String literal constant refers to the same String object in the *compile-time constant pool*
     e.g.
     -
       String s1="abc";
       String s2="abc";
       s1==s2 is true
     -
       String s1=foo();
       String s2="abc";
       String foo() {return "abc";}
       s1==s2 is true;
**** A.intern()
     `constant pool` is stored in the .class file (like string literals in c/c++, which are statically stored at TEXT section)
     compile-time String are always `interned` to shared the same String instance in the constant pool.
     if the constant pool already contains a String whose value equals to A, return it, else, create a new String object in the pool, then return it.
     i.e. intern() may add a new entry to the constant pool!
     - intern() usage?
       suppose u are manage thousands of Strings whose value is
       among only 3 alternatives , u can make use of s.intern() instead of s, so
       as to store only 3 objects in the constant pool.
**** concatenation operator `+`
     The String concatenation operator `+` will only create new String object when operand are not *compile-time* constant.
     e.g.:
     - String s1="abc"
     - String s2="abc"+"abc";
       will not create new String object at run-time, since "abc" are compile-time constant.
     - final String s1="abc"; String s2=s1+"abc";
       also will not create new String object for s2, since s1 is a compile-time constant.
     - final String s1=getString() or final String s1=new String("abc"); String s2=s1+"abc";
       will create new String object for s2, since s1 is not a compile-time constant (it's a run-time constant)

*** conversion
**** Boolean
     conversion between boolean and numeric is impossible.
**** Numeric
     - conversion between numeric primitive type can always be applied, implicitly or explicitly.
       e.g.
       1. long l=2L;
	 int a=(int)l;
       2. void foo(int);
	 long x=2L;
	 foo((int)x)
       3. int i=2;
	  long l=i;
       Note:
       in example 1 & 2, if the conversion will cause loss of precision, e.g. from long to int, explicitly conversion is mandatory.
       in example 3, implicitly conversion is applied, since the conversion cause no loss of precision.
     - conversion between numeric primitive type's reference type is not allowed in anyway.
       e.g.
       Longer l=2L;
       Integer a=(Integer)l; is not allowed.
     - conversion between numeric primitive and reference type is allowed, with auto boxing and un-boxing conversion
       e.g.
       1. Integer a=1;
	  long xx=a; // a is firstly un-boxed to int
       2. int aa=1;
	  Long xx=(long)aa; // aa is firstly converted to long, then boxed to Long.

**** autoboxing & un-boxing conversion
     see also [[constant pool]]
     see also valueOf
     - un-boxing from one NULL object  will result in a NullPointerException, e.g. int a=getInt(); Integer getInt() {return null;}
     - primitive type's reference type's ++/-- will cause another reference class object be created
       e.g. Integer a=1; a++; then another Integer for value 2 is created automatically. (but may re-use an existing Integer(2) directly instead of
       create a new one)
     - autoboxing 实际是只是隐式的调用了 valueOf

**** valueOf
#+BEGIN_EXAMPLE
     Integer.valueOf():
       return  i >= 128 || i < -128 ? new Integer(i) : SMALL_VALUES[i + 128];
     static {
       for(int i = -128; i < 128; i++) {
         SMALL_VALUES[i + 128] = new Integer(i);
       }
     }
#+END_EXAMPLE

**** shift
     before shifting char,byte,short, the operand will be converted to int through Numeric Conversion.
     e.g.
#+BEGIN_EXAMPLE
     byte b=0xff;
     b=b<<8>>>8;
     first: b in converted to 0xff ff ff ff
     second:<<8 result in 0xff ff ff 00
     last :>>>8 result in 0x00 ff ff ff
     so lastly, b=0xff, instead of 0x00
#+END_EXAMPLE
*** equals, hashCode, HashMap, ==
    - HashMap.contains(key)的大致做法:
      if (this==key || (this.hashCode()==key.hashCode() && this.equals(key)):
        return true;
      else:
        return false;
    - equals的实现
      - Object.equals(o):
        return this==o;
      - Integer.equals(o):
	return this.value==o.value;
      - String.equals(o):
	if this==o:
	  return true;
	if this.hashCode()!=o.hashCode():
	  return false;
	foreach byte:
	  if byte1!=byte2:
	    return false;
    - hashCode 的实现
      - Object.hashCode():
	返回内存地址
      - Integer.hashCode():
	return this.value;
      - String.hashCode():
	built upon this.value[]

*** Object.clone, shadow copy & deep copy
    In java, though clone is intent to produce a copy of the same object
    it is not guaranteed. Clone comes with lots of its and buts. So my first advice
    is to not depend on clones. If you want to provide a handle / method to deliver
    a copy of the current instance write a kind of factory method and provide it
    with a good documentation. When you are in a situation to use a third party
    component and produce copies of it using the clone method, then investigate that
    implementation carefully and get to know what is underlying. Because when you
    ask for a rabbit, it may give monkeys!

    - Shallow Copy

      Generally clone method of an object, creates a new instance of the same
      class and copies all the fields to the new instance and returns it. This
      is nothing but shallow copy. Object class provides a clone method and
      provides support for the shallow copy. It returns ¡®Object¡¯ as type and
      you need to explicitly cast back to your original object.

      Since the Object class has the clone method (protected) you cannot use it
      in all your classes. The class which you want to be cloned should
      implement clone method and overwrite it. It should provide its own meaning
      for copy or to the least it should invoke the super.clone(). Also you have
      to implement Cloneable marker interface or else you will get
      CloneNotSupportedException. When you invoke the super.clone() then you are
      dependent on the Object class¡¯s implementation and what you get is a
      shallow copy.

    - Deep Copy

      When you need a deep copy then you need to implement it yourself. When the
      copied object contains some other object its references are copied
      recursively in deep copy. When you implement deep copy be careful as you
      might fall for cyclic dependencies. If you don¡¯t want to implement deep
      copy yourselves then you can go for serialization. It does implements deep
      copy implicitly and gracefully handling cyclic dependencies.

      One more disadvantage with this clone system is that, most of the
      interface / abstract class writers in java forget to put a public clone
      method. For example you can take List. So when you want to clone their
      implementations you have to ignore the abstract type and use actual
      implementations like ArrayList by name. This completely removes the
      advantage and goodness of abstractness.

      When implementing a singleton pattern, if its superclass implements a
      public clone() method, to prevent your subclass from using this class¡¯s
      clone() method to obtain a copy overwrite it and throw a
      CloneNotSupportedException.

      Note that clone is not for instantiation and initialization. It should not
      be synonymously used as creating a new object. Because the constructor of
      the cloned objects may never get invoked in the process. It is about
      copying the object in discussion and not creating new. It completely
      depends on the clone implementation. One more disadvantage (what to do
      there are so many), clone prevents the use of final fields. We have to
      find roundabout ways to copy the final fields into the copied object.

      Clone is an agreement between you, compiler and implementer. If you are
      confident that you all three have good knowledge of java, then go ahead
      and use clone. If you have a slightest of doubt better copy the object
      manually.

      Example source code for java clone and shallow copy

#+BEGIN_EXAMPLE
      class Employee implements Cloneable {
      private String name;
      private String designation;
      public Employee() {
        this.setDesignation("Programmer");
      }
      public Object clone() throws CloneNotSupportedException {
        /*
	Employee copyObj = new Employee();
	copyObj.setDesignation(this.designation);
	copyObj.setName(this.name);
	return copyObj;
	*/
        return super.clone(); // called Object.clone()
	}
      }
#+END_EXAMPLE
    - Object.clone()
      Object.clone() is quite efficient, since it relies on JNI and use a bit-wise copy to clone the Object

    To summarize:
    - clone is mainly used to produce a shadow copy of object
      - if u prefer deep copy, you can either use serialization, or use `
        ret=super.clone(); ret.obj1=this.obj1.clone();....`, things like
        that. but circular references should be well concerned
    - super(Object).clone() is quite efficient, u need not rewrite clone() for simple Object
    - *many Abstract containers is not clone-able...e.g. List, but ArrayList is clone-able*
*** constant variable
    we call a variable, of primitives type or of String type, that is final and initialized with a compile-time expression a constant variable
    e.g. final int a=10; final String s="abc";
*** Throwable, Exception,Error
    Note: all Exception and Error can be caught at run-time, even divided-by-zero error...
#+BEGIN_EXAMPLE lang:c
      Throwable
        Exception
          RuntimeException                    ;; unchecked exceptions
  	    NullPointerException
  	  ..                                  ;; checked exceptions, which can be declared in *Throws* clause
        Error
          OutOfMemoryError
  	  ..
#+END_EXAMPLE
**** Throwable.fillInStackTrace()
*** DONE java inner class can't have static member?                :coding:
CLOSED: [2012-09-03 Mon 17:33] SCHEDULED: <2012-09-03 Mon>
because java inner class is always associated with an outer class instance, thus
it can't define static members or methods. 
** Java Memory Area
   - Java Heap
     set by -Xms and -Xmx
   - Java Stack
     set by -Xss
   - Direct Buffer (ByteBuffer)
     - ByteBuffer.allocateDirect() actually will use mmap to map a separate VMA
     - while GC (minor/major) will caused automatically only when `Java Heap` is full...
     - Then: How about allocate 2G direct buffer while keep the Java Heap free?
       How is the direct buffer be `GC`ed?
       - Since the Java Heap is free, no GC is performed automatically
       - Actually, when allocateDirect(), Java will `try {} catch {}` the
         OutOfMemoryError and force a major GC using `System.gc()`, and gc may
         free some byte buffer.
       - But, if `-XX:+DisableExplicitGC` is specified..., good luck :(
#+BEGIN_EXAMPLE
    public static void main(String[] args) {
	ByteBuffer bf=ByteBuffer.allocateDirect(300*1024*1024);
	bf=ByteBuffer.allocateDirect(300*1024*1024);
	bf=ByteBuffer.allocateDirect(300*1024*1024);
    }
#+END_EXAMPLE
     when run the sample code above w/ or w/o `-XX:+DisableExplicitGC`:
#+BEGIN_EXAMPLE
     ~@mbjswglx56> java -XX:+DisableExplicitGC -verbose:gc TestByteBuffer
     Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory
        at java.nio.Bits.reserveMemory(Bits.java:633)
        at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98)
        at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)
        at TestByteBuffer.main(TestByteBuffer.java:7)
#+END_EXAMPLE
#+BEGIN_EXAMPLE
     ~@mbjswglx56> java -verbose:gc TestByteBuffer
     [GC 313K->320K(59840K), 0.0007220 secs]
     [Full GC 320K->121K(59840K), 0.0072890 secs]
#+END_EXAMPLE
   - Socket Buffer
   - JNI
   - Native Heap and Stack
** Concurrent
   see also [[Immutable Collection]]
   see also [[CopyOnWriteArrayList]]
*** AbstractQueuedSynchronizer
*** LockSupport
*** Callable vs. Runnable
*** CANCELED Future & FutureTask
    - State "CANCELED"   from "DOING"      [2011-07-18 Mon 17:43]
    see also [[Callable vs. Runnable]]
*** CountDownLatch
*** ReentrantLock
*** Semaphore
*** CyclicBarrier
*** Exchanger
*** Executor
** HttpClient
*** cookie
*** connection pool
** GC
   see also [[Java Criticism]]
*** Reference counting
*** Trace
**** Mark & sweep GC
**** Stop and copy
*** GC root
** CG (code generation / 代码生成 )
   see also [[CGLIB]]
   see also [[ASM]]
   see also [[Proxy]]
** GP
   see also [[Java Criticism]]
   google: “这可不是泛型”-Bruce Eckel眼中的Java泛型..
** DONE JDK Dynamic Proxy & CGLIB
   SCHEDULED: <2011-08-30 Tue> CLOSED: [2011-09-07 Wed 10:32]
   - State "DONE"       from "DOING"      [2011-09-07 Wed 10:32]
   see also [[Proxy]]
** JNI
*** tools
**** javah
**** javap
*** Reference
**** GlobalRef
***** NewGlobalRef/DeleteGlobalRef
**** LocalRef
***** DeleteLocalRef/NewLocalRef
***** PopFrame/PushFrame
*** JNIEnv
**** AttachThread
*** Monitor
**** MonitorEnter/MonitorExit
** Reflect
*** Class
**** newInstance
**** forName
**** getConstructor, getDeclaredConstructor
**** getField, getDeclaredField
**** getMethod, getDeclaredMethod
*** Field
**** get
**** set
**** setAccessible
*** Method
*** Constructor
**** newInstance
*** Proxy
    see also [[Dynamic Proxy]]
** NIO
*** Buffer
**** ByteBuffer
*** DONE [#A] ImportVCardActivity use NIO?
CLOSED: [2012-04-09 Mon 15:03] SCHEDULED: <2012-04-09 周一>
CLOCK: [2012-04-09 Mon 14:58]--[2012-04-09 Mon 15:03] =>  0:05
NIO, especially ByteBuffer.allocateDirect(), will improve performance in two
aspects:
1. allocateDirect use mmap to allocate buffer memory, thus bypass one
   kernel-user copy
2. mmapped memory won't trigger GC
** Optimization
** Java Collection Framework
*** DONE Immutable Collection
    SCHEDULED: <2011-07-26 Tue> CLOSED: [2011-07-27 Wed 15:27]
    - State "DONE"       from "DOING"      [2011-07-27 Wed 15:27]
    see also [[Java Criticism]]
    see also [[Concurrent]]
    see also [[CopyOnWriteArrayList]]
    see also [[Collections.unmodifiableXXX]]

    google: why i hate java.util collection library

    SUN has inverted the Metabolite vs. Immutability in the class hierarchy.
    Immutability, in ANY language that wants to:
      1. guarantee semantics,
      2. ease concurrency
      3. resource contention
    should have immutability as a default.
    However, SUN have decided to have Mutablity  as a default.
    e.g.
    `Collection unmodifiableList(Collection)` will return an immutabile collection, BUT, the unmodifiableList wrapper does nothing but wrap the
    `setXXX`, `addXXX`, `removeXXX` function to throw exception...
*** Collections
**** Collections.EMPTY_LIST & Collections.emptyList()
     Sometimes we need to return an `empty` collections to indicate that no data available...what ever.
     Instead of return `new ArrayList(0)`, we can simply return Collections.EMPTY_LIST, which is itself an [[Immutable Collection]] and light-weighted
**** Collections.unmodifiableXXX
     see also [[Immutable Collections]]
**** Collection.synchronizedXXX
*** CopyOnWriteArrayList / CopyOnWriteArraySet
    see also [[Immutable Collection]]
** Serialization
** DONE UncaughtExceptionHandler
   CLOSED: [2011-07-25 Mon 13:37]
   - State "DONE"       from "TODO"       [2011-07-25 Mon 13:37]
   see also [[Java Process Creation]]
   see also [[Android Process Crash and Restart]]
** JDWP
** Memory Model
   Memory model mainly talks about two topics:
   1. re-ordering  (bytecode related)
      compiler writer should care about re-ordering in java language level
      Note: re-ordering in java language level has nothing to do with `out-of-order` execution of the CPU.

   2. visibility   (cpu related)
      compiler writer should insert some memory barrier to instruct CPU to update it's cache.
*** happen-before
    - happen-before is a partial relationship introduced to java memory model in JSR-133.
    - In single-threaded execution, all java instructions follows the `as-if-serial` semantic (introduced in LS),
      there is no need to enforce the happen-before relationship.
    - In multi-threaded execution, happen-before relationship is enforced to make sure that there is no race condition.
    - `volatile`, `synchronization`, `Thread` will heavily affect the happen-before relationship;
    - happen-before affect both the re-ordering and visibility.
*** DONE double-checked locking
    CLOSED: [2011-08-19 Fri 11:36]
    - State "DONE"       from ""           [2011-08-19 Fri 11:36]
    :PROPERTIES:
    :CUSTOM_ID: @double-checked locking
    :END:
    see also [[Memory Model]]
    google: double-checked locking is BROKEN

    Double-checked locking was broken, just before JSR-133
#+BEGIN_EXAMPLE
    class Foo {
      private volatile Helper helper = null;
      public Helper getHelper() {
        Helper result = helper;
        if (result == null) {
            synchronized(this) {
                result = helper;
                if (result == null)
                    helper = result = new Helper();
            }
        }
        return result;
      }
    }
#+END_EXAMPLE

   SCHEDULED: <2011-08-08 Mon>
*** JSR 133 FAQ
    google: JSR 133 (Java Memory Model) FAQ
    - volatile
    - final
    - synchronization
** Java Module System
   see also [[ClassLoader]]
*** JSR-277: Java Module System
*** OSGi & HotSwap
** ClassLoader
   see also [[Java Module System]]
*** Thread.setContextClassLoader() / Thread.getContextClassLoader()
    a backdoor in the ClassLoader architecture, which broken up the `Parents Delegation Scheme`, mainly used by JNDI,JDBC,JAXP and OSGi
*** Class.getClassLoader()
    This is the default ClassLoader for Class.forName()
*** ClassLoader.getSystemClassLoader()
** CG (Code Generation)
*** ASM
    see also [[Visitor Pattern]]
** Security
*** ClassLoader
*** SecurityManager
*** Policy
*** How To Run Beanshell in Sandbox?
*** keystore
    keystore 中同时包含公钥,私钥及证书
*** keytool & jarsigner
    see also [[数字签名]] [[数字证书]]
    http://download.oracle.com/javase/1.3/docs/tooldocs/win32/jarsigner.html

    jarsigner will add two additional files to the original jar to generate
    the signed jar:
     1. xxx.sf
	xxx.sf will contains the HASH of every source file, e.g.
	XX1.java
	ADFASDFASDFASDFASDFASF
	XX2.java
	SAFASDFASDFASDFASDFASDFSAF
	...
     2. xxx.dsa
	xxx.dsa is encoded in two parts:
	1. digital signature of the xxx.sf
	2. certificate used to verify the signature

#+TITLE: Visitor Pattern
* Single/Double/Multiple Dispatching
  Dispatching, 指的是调用一个函数时, 因为存在多个同名的函数,仅仅靠函数的名字无法
  确定究竟要调用哪个, 这时函数参数的个数和类型就需要被考虑; Dispatching就是指: 根
  据函数的参数的个数和类型选择具体要执行的函数.

  看起来 Dispatching 和 Overloading 很像, 实际上从我个人的理解来看, 这里讨论的
  Dispatching属于 *运行时行为*, 则 Overloading 属于 *编译时行为* , 所以两者并没有关系.

** Single Dispatching
Single Dispatching, 即只能根据函数的某一个参数进行dispatch, 多态就是一
个single Dispatching, 因为每一个虚函数都隐含着一个this参数, 程序在运行
时可以根据this具体类型的不同, 选择不同的函数.

** Double Dispatching / Multiple Dispatching
Double Dispatching 和 Multiple Dispatching, 顾名思义, 就是根据函数的两
个或多个参数的运行时类型进行dispatch.大部分编译型的面向对象的语言,如
C++,Java, 都不支持Multiple/Double Dispatching, 例如:
#+BEGIN_SRC java
  public class Test {
      static void foo (Throwable e) {
  
      }
      static void foo (Error e) {
          
      }
      public static void main(String[] args) {
          Throwable e=new Error ();
          foo (e);
      }
  }
#+END_SRC

对应的byte code:

#+BEGIN_SRC TEXT
  public static void main(java.lang.String[]);
  Code:
   Stack=2, Locals=2, Args_size=1
   0:	new	#2; //class java/lang/Error
   3:	dup
   4:	invokespecial	#3; //Method java/lang/Error."<init>":()V
   7:	astore_1
   8:	aload_1
        // 编译时就确定为使用 Method foo:(Ljava/lang/Throwable;)V  
   9:	invokestatic	#4; //Method foo:(Ljava/lang/Throwable;)V  
   12:	return
}
#+END_SRC

在编译时 foo(e)就已经被确定为 foo(Throwable e) 这个函数, 而不会在运行时
根据e的具体类型选择 foo(Error). 所以函数重载不是Multiple Dispatching

虽然C++,Java等不支持Multiple/Double Dispatching, 但可以使用其他方法来模
拟,因为C++和Java都支持Single Dispatching和运行时类型识别 (C++的RTTI和
Java的Reflection)

** 使用运行时类型识别模拟Double Dispatching
#+BEGIN_SRC java
  public class Test {
     static void foo (Throwable e) {
       if (e instanceof Exception) {
  
       } else if (e instanceof Error) {
  
       }
     }
     public static void main(String[] args) {
       Throwable e=new Error ();
       foo (e);
     }
  }
#+END_SRC
** 使用Single Dispatching来模拟Double Dispatching
见 Visitor Pattern

* Visitor Pattern
** 使用Visitor Pattern模拟Double Dispatching
Visitor Pattern定义了两类对象: Element和Visitor, 其中Element需要定义一
个accept方法, 而visitor需要定义一个visit方法.

一个简单的Visitor Pattern的例子:
#+BEGIN_SRC java
  interface Element {
      void accept (Visitor v);
  }
  
  class AElement implements Element {
      public void accept (Visitor v) {
          v.visit (this);
      }
  }
  
  class BElement implements Element {
      public void accept (Visitor v) {
          v.visit (this);
      }
  }
  
  interface Visitor {
      void visit (AElement e);
      void visit (BElement e);
  }
  
  class AVisitor implements Visitor {
      public void visit (AElement ae) {
          System.out.println("AVisitor visit AElement");
      }
      public void visit (BElement ae) {
          System.out.println("AVisitor visit BElement");
      }
  }
  
  class BVisitor implements Visitor {
      public void visit (AElement ae) {
          System.out.println("BVisitor visit AElement");
      }
      public void visit (BElement ae) {
          System.out.println("BVisitor visit BElement");
      }
  }
  
  public class Test {
      public static void main(String[] args) {
          Element ae=new BElement ();
          Visitor av=new AVisitor ();
          ae.accept (av);
      }
  }
#+END_SRC

这个例子模拟了 Double Dispatching, 因为对于 Visitor 来说, 首先, 根据
Visitor的具体类型 (AVisitor) 找到 Avisitor 的方法, 然后 AVisitor 又根据
Element的具体类型(BElement)找到了最终的 AVisitor.visit(BElement) 方法.

这里的关键有两点:
1. 借助了 Element 类对自己的 accept 方法的 Single Dispatching.
2. 借助了 Overloading 
其中第一点是主要的,第二点可有可无, 大不了将程序改成这样:

#+BEGIN_SRC java
  class AElement implements Element {
      public void accept (Visitor v) {
          v.visitAElement (this);
      }
  }
  
  class BElement implements Element {
      public void accept (Visitor v) {
          v.visitBElement (this);
      }
  }
  
  interface Visitor {
      void visitAElement (AElement e);
      void visitBElement (BElement e);
  }
#+END_SRC

** Visitor Pattern
Visitor Pattern的目的是将数据结构与算法分离, 当需要对对象添加新的方法时,
不需要修改对象, 只需要修改算法. 在上面的例子中, Element指数据结构,
Visitor指算法.

举例来说, 动物这类对象做为Element, 其子类包括阿猫阿狗之类；动物能做的具
体的动作做为Visitor, 例如叫,跑,被人吃掉...

最传统的实现方法是:
#+BEGIN_SRC java
  interface Animal {
      void run () 
  }
  
  class Dog implements Animal {
      void run () {
          // concrete implmentation
      }
  }
#+END_SRC

但这种实现方法带来的问题是: 具体的算法 (如run) 和对象是绑定在一起的, 而
且如果要添加一个新的 bark 方法,必须修改接口类和实现类, 而修改接口类是不
可接受的.

若使用 Visitor Pattern, 则可以把 run 方法封装到的一个 RunVisitor 类中,
然后调用 Animal.accept(runVisitor()) 即可, 所有的算法都只包含在各个
Visitor 中.

如果要添加一个 bark 方法,只需要实现一个 BarkVisitor 即可.

* Visitor Pattern 的应用 
** ASM
[[http://asm.ow2.org][ASM Homepage]]

ASM (一个动态生成或修改java class的库) 使用 Visitor Pattern 来实现其基
于事件的模型.

它在解析class时会触发一系列事件, 如解析到一个class, 解析到一个method等,
这些事件被做为Element; 对这些事件的处理, 如打印log, 保存到目标class等被
做为Visitor. 在ASM中, Element被看作是事件的提供者, 而Visitor被看作事件
的处理者.

** MultiJava
[[http://multijava.sf.net][MultiJava Homepage]]

#+begin_quote
MultiJava is an extension to the Java programming language that adds open classes
and symmetric multiple dispatch. Multiple dispatch allows the code invoked by a 
method call to depend on the run-time type of all the arguments, instead of just
the receiver, this is useful for event handlers and for binary methods, like
equals in Java.

The MultiJava project provides `mjc`, a MultiJava compiler, that translate MultiJava
programs to regular Java bytecode. 
#+end_quote   

使用MultiJava进行event dispatching的例子:

#+BEGIN_SRC java
  public abstract class AbstractHandler {
      public abstract void handleEvent (Event e);
  }
  
  public class MyJavaHandler extends AbstractHandler {
      public void handleEvent (Event@Event1 e) {
          // handle Event1
      }
      public void handleEvent (Event@Event2 e) {
          // handle Event2
      }
  }
#+END_SRC

因为`Event@Event1`不是合法的Java语法,所以MultiJava需要使用`mjc`工具对源
码进来转换,转换的过程实际就是解析这种`Event@Event1`, 然后使用Visitor
Pattern生成相应的Element和Visitor
** dalvik GC
#+BEGIN_SRC java
  void dvmHeapMarkRootSet() {
      GcHeap *gcHeap = gDvm.gcHeap;
      dvmMarkImmuneObjects(gcHeap->markContext.immuneLimit);
      dvmVisitRoots(rootMarkObjectVisitor, &gcHeap->markContext);
  }
#+END_SRC

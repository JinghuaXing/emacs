#+TITLE: Sync
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* Sync
Sync 部分主要包含以下的内容:

1. lock/wait/notity 的实现
2. java hashcode 的实现

** thin locks
每一个 C++ Object 类都有一个成员: int lock, 用来表示 lock 的状态.
dalvik 的 lock 是一种称为 thin locks 的锁. 这种 lock 与传统的基于
mutex 的 lock 不同, 它分为两种状态: thin 和 fat.  在不同的状态下, lock
字段的意义不同:
1. thin 状态
   #+BEGIN_EXAMPLE
     [31 ---- 19] [18 ---- 3] [2 ---- 1] [0]
      lock count   thread id  hash state  0
   #+END_EXAMPLE

2. fat 状态
   #+BEGIN_EXAMPLE
     [31 ---- 3] [2 ---- 1] [0]
       pointer   hash state  1
   #+END_EXAMPLE

   其中的 pointer 是指向 struct Monitor 的指针

初始时所有 lock 都处于 thin 状态, 这种状态下 dalvik 会使用 spinlock 来
获得锁. 当发生 lock contention 时, lock 会 thin 状态 inflate 到 fat 状
态, 此后该 lock 就会通过传统的 mutex 来进行锁的获得与释放, 而该 lock 会
一直处于 fat 状态 (无法退回到 thin 状态)

参考: java lightweight_lock

** hashcode
对与 MarkSweep GC 来说, hashcode 就是 struct Object 的地址. 因为
MarkSweep GC 不会移动对象. 

对于 Copying GC 来说, 获得 hashcode 时会参考 lock byte 中的 hashState字
段, 例如, 若 hashState 为 LW_HASH_STATE_HASHED 或
LW_HASH_STATE_UNHASHED, 则 hashcode 直接就是Object 地址. 若 hashState
为 LW_HASH_STATE_HASHED_AND_MOVED, 说明之前获取后 hashcode 且后来
Copying GC 移动过对象, 这时 hashcode 不能简单的取对象的地址了: Copying
GC 会负责在移动对象时根据当前 hashState 决定是否把移动前的对象地址做为
hashcode 保存到对象后面的一个特定位置中.
** lock
*** dvmLockObject
*** lockMonitor
*** unlockMonitor
** wait/notify
*** waitMonitor
*** notifyMonitor

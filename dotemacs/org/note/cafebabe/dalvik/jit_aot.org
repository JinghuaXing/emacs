#+TITLE: JIT And AOT
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* JIT
** 基本流程
JIT 的入口是 common_updateProfile

#+BEGIN_SRC text
  common_updateProfile:   
    // 这里负责从 thread->pJitProfTable 中获得该 rPC 对应的 threshold (初始为最大值 40, 每命中一次减一)
    // 若 threshold 已经为 0, 说明该代码是 hot 的, 然后会跳到 common_Profile 进行 jit 相关操作. 否则直接
    // 通过 GOTO_NEXT 继续执行 interp
    common_Profile:
      // 根据 pc 查找该 trace 是否已经被编译      
      call   dvmJitGetTraceAddrThread  # (pc, self)
      // 若还没有被编译出来
      // 通过查看 interpBreak->subMode, 确定是否已经在编译 (kSubModeJitSV)        
      movzwl      offThread_subMode(%ebx), %ecx
      and         $(kSubModeJitTraceBuild | kSubModeJitSV), %ecx
      // 若已经在编译, 则继续以 interp 方式执行
      jne         3f                     # already doing JIT work, continue
      FETCH_INST
      // 否则     
      call dvmJitCheckTraceRequest
        // 开始 trace build 模式
        dvmEnableSubMode (self, kSubModeJitTraceBuild);
          updateInterpBreak
            // 修改了 curHandlerTable, 后续 byte code 的解释会通过这个
            // altHandlerTable 解释
            newValue.ctl.curHandlerTable = (newValue.ctl.breakFlags) ?
              thread->altHandlerTable : thread->mainHandlerTable;
#+END_SRC

当 dvmJitCheckTraceRequest 决定开始 trace build 模式后, 后续所有的
byte code 的解释会通过 altHandlerTable 进行, 而 altHandlerTable 对所有
byte code 的解释基本都是一样的, 例如:

#+BEGIN_SRC text
  .L_ALT_OP_MOVE: /* 0x01 */
  /* File: armv5te/alt_stub.S */
  /*
  ,* Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
  ,* any interesting requests and then jump to the real instruction
  ,* handler.    Note that the call to dvmCheckBefore is done as a tail call.
  ,* rIBASE updates won't be seen until a refresh, and we can tell we have a
  ,* stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
  ,* bail to the real handler if breakFlags==0.
  ,*/
  ldrb   r3, [rSELF, #offThread_breakFlags]
  adrl   lr, dvmAsmInstructionStart + (1 * 64)
  ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
  cmp    r3, #0
  // 检查 interpBreak->subMode, 若不是 jni 模式, 则直接调用
  // mainHandlerTable 中相应的 entry (dvmAsmInstructionStart 对应于 mainHandlerTable)
  bxeq   lr                   @ nothing to do - jump to real handler
  EXPORT_PC()
  mov    r0, rPC              @ arg0
  mov    r1, rFP              @ arg1
  mov    r2, rSELF            @ arg2
  // 否则, 调用 dvmCheckBefore 进行 trace build
  b      dvmCheckBefore       @ (dPC,dFP,self) tail call
    if (self->interpBreak.ctl.subMode & kSubModeJitTraceBuild):
      dvmCheckJit(pc, self);
        // 若 trace build 正在进行
        if self->jitState == kJitTSelect:
          self->trace[self->currTraceRun].info.frag.numInsts++;
          self->totalTraceLen++;
          self->currRunLen += len;
        else if self->jitState == kJitTSelectEnd:
        // trace build 结束, 提交给 compiler 编译
          dvmCompilerWorkEnqueue
#+END_SRC
* AOT

#+TITLE: Alloc
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* Alloc
** Glossary
- HeapSource
- GcHeap
- MarkSweep
- Copying
- Mspace & dlmalloc
- liveBits
- markBits
- markStack
- cardTable
- HeapWorker

** dvmAllocObject
#+BEGIN_SRC text
  Object* dvmAllocObject(ClassObject* clazz, int flags)
    newObj = (Object*)dvmMalloc(clazz->objectSize, flags);
      ptr = tryMalloc(size);
        ptr = dvmHeapSourceAlloc(size);
        if (ptr != NULL):
          return ptr;
        // 分配失败, 开始 GC, false 表示 SoftReferences 不被 GC
        gcForMalloc(false);
          dvmCollectGarbageInternal(GC_FOR_MALLOC);
        // 第二次 malloc  
        ptr = dvmHeapSourceAlloc(size);
          ptr = mspace_malloc(heap->msp, n);
          // countAllocation 会将 hs->liveBits 对应的置 1
          countAllocation(heap, ptr);
        if (ptr != NULL): return ptr;
        // 第三次 ... 前两次的 alloc 会受 softLimit 的影响导致分配失败
        // 这一次会首先尝试去掉 softLimit, 若还不行, 则去掉 footprint 的限制
        ptr = dvmHeapSourceAllocAndGrow(size);
        if (ptr != NULL): return ptr;
        // 即使 Heap Grow 了还是不行, 再次 GC, true 表示 SoftReferences 也被 GC
        gcForMalloc(true);
        // 第四次 ...
        ptr = dvmHeapSourceAllocAndGrow(size);
        if (ptr != NULL): return ptr;
        return null;
      if (ptr == NULL):
        throwOOME();
    DVM_OBJECT_INIT(newObj, clazz);
      dvmSetFieldObject(obj, OFFSETOF_MEMBER(Object, clazz), clazz_)
#+END_SRC

** dvmCollectGarbageInternal
#+BEGIN_SRC text
    dvmCollectGarbageInternal(spec)
      // 一共有四种类型的 GC:
      // 1. GC_FOR_MALLOC, 对应于 dvmMalloc 时的第一次 GC (不清理 SoftReferences)
      // 2. GC_CONCURRENT, 由 HeapWorker 发起的 GC
      // 3. GC_EXPLICIT, 由 System.gc() 发起的 GC
      // 4. GC_BEFORE_OOM, 对应于 dvmMalloc 时第二次 GC (清理 SoftReferences)
      if (spec == GC_FOR_MALLOC):
        ATRACE_BEGIN("GC (Alic)");
      else if (spec == GC_CONCURRENT):
        ATRACE_BEGIN("GC (concurrent)");
      else if (spec == GC_EXPLICIT):
        ATRACE_BEGIN("GC (explicit)");
      else if (spec == GC_BEFORE_OOM):
        ATRACE_BEGIN("GC (before OOM)");
      else:
        ATRACE_BEGIN("GC (unknown)");
      // 参考: dalvik thread dvmSuspendAllThreads
      dvmSuspendAllThreads(SUSPEND_FOR_GC);
      // mark 阶段
      /* Mark the set of objects that are strongly reachable from the roots.
      ,*/
      dvmHeapMarkRootSet();
      // 若 spec 表明该 gc 由 HeapWorker 发起, 则 dvmHeapScanMarkedObjects
      // 时并不 stop the world. 这也是 Concurrent GC 的本意.
      if (spec->isConcurrent):
        dvmClearCardTable();
        dvmResumeAllThreads(SUSPEND_FOR_GC);
      /* Recursively mark any objects that marked objects point to strongly.
      ,* If we're not collecting soft references, soft-reachable
      ,* objects will also be marked.
      ,*/
      dvmHeapScanMarkedObjects();
      if (spec->isConcurrent):
        dvmSuspendAllThreads(SUSPEND_FOR_GC);
        dvmHeapReMarkRootSet();
        dvmHeapReScanMarkedObjects();
      /*
      ,* All strongly-reachable objects have now been marked.  Process
      ,* weakly-reachable objects discovered while tracing.
      ,*/
      dvmHeapProcessReferences();
      // sweep 阶段
      dvmHeapSweepSystemWeaks();
      /*
      ,* Live objects have a bit set in the mark bitmap, swap the mark
      ,* and live bitmaps.  The sweep can proceed concurrently viewing
      ,* the new live bitmap as the old mark bitmap, and vice versa.
      ,*/
      dvmHeapSourceSwapBitmaps();
      dvmHeapSweepUnmarkedObjects();
  
      // 根据 utilization, maxFree, minFree 的值重新设置 softLimit
      dvmHeapSourceGrowForUtilization();

      // 将本次 GC 产生的 white reference 和 finalizer reference 通知给
      // java 层的 ReferenceQueueDaemon
      dvmEnqueueClearedReferences(&gDvm.gcHeap->clearedReferences);
      
#+END_SRC

*** dvmHeapMarkRootSet
#+BEGIN_SRC text
  rootMarkObjectVisitor(void *addr, u4 thread, ...)
    markObjectNonNull(obj, ctx, false);
    
  dvmHeapMarkRootSet
    // rootMarkObjectVisitor 是一个 callback, 对每一个 gc root 中的对象
    // 都会调用这个 visitor
    dvmVisitRoots(rootMarkObjectVisitor, &gcHeap->markContext);
      visitHashTable(visitor, gDvm.loadedClasses, ROOT_STICKY_CLASS, arg);
      visitPrimitiveTypes(visitor, arg);
      visitHashTable(visitor, gDvm.literalStrings, ROOT_INTERNED_STRING, arg);
      visitIndirectRefTable(visitor, &gDvm.jniGlobalRefTable, 0, ROOT_JNI_GLOBAL, arg);
      visitReferenceTable(visitor, &gDvm.jniPinRefTable, 0, ROOT_VM_INTERNAL, arg);
      // visitThreads 是最主要的一过 scan 过程: GC root 大部分例如 static 对象,
      // 局部对象等都包含在 stack frame 中, visitThreads 负责扫描所有
      // stack frame
      visitThreads(visitor, arg);
        for each thread:
          (*visitor)(&thread->threadObj, threadId, ROOT_THREAD_OBJECT, arg);
          (*visitor)(&thread->exception, threadId, ROOT_NATIVE_STACK, arg);
          visitIndirectRefTable(visitor, &thread->jniLocalRefTable, threadId, ...);
          // visitThreadStack 负责扫描所有的 stack frame, 并根据 stack
          // frame 中 register 的使用情况来判断是否要 mark
          visitThreadStack(visitor, thread, arg);
            // 遍历所有 frame
            for (u4 *fp = (u4 *)thread->interpSave.curFrame;
                  fp != NULL;
                  fp = (u4 *)saveArea->prevFrame):
              // 若此时存在 register map, 则根据 register map 得到
              // register 使用情况, 否则, 扫描所有的 register
              // 对每一个可能使用的 register, 通过 liveBits 可以判断
              // 出这个 register 对应的地址是否是一个 java 对象
#+END_SRC

**** 关于 bitmap 的操作
对于 markBits 和 liveBits 一样

markObjectNonNull 的过程是: 根据 addr 换算出对象在 bitmap 中的 bit
index, 将 bitmap 该bit 置 1, 因为 dalvik 中所有的对象都是 8 bytes 对齐
的, 所以 bitmap 中每 bit 代表 heap 的 8 bytes.

假设 gc heap 大小为 32 bytes, 则 markBits 的大小为 4 bits, 假设一共有两
个对象需要 mark, 地址相对于 heap->base 的 offset 分别为 0, 16, 则
markBits 的值为 1010, 即 markBits 只标记对象的地址, 和对象的大小无关.

*** dvmHeapScanMarkedObjects
#+BEGIN_SRC text
  dvmHeapScanMarkedObjects
    /* The bitmaps currently have bits set for the root set.
    ,* Walk across the bitmaps and scan each object.
    ,*/
    // dvmHeapBitmapScanWalk 负责扫描 markBits, 对直接引用的
    // filed 等进行 mark, 并放到 markStack 中
    dvmHeapBitmapScanWalk(ctx->bitmap, scanBitmapCallback, ctx);
    processMarkStack(ctx);
      // 在 scanObject 过程中, markStack 会增长, 通过 markStack, 将递归
      // 过程变为迭代
      GcMarkStack *stack = &ctx->stack;
      while (stack->top > stack->base):
        const Object *obj = markStackPop(stack);
        scanObject(obj, ctx);
#+END_SRC

*** dvmHeapProcessReferences
到此, 所有 strong references 的对象都被 mark 了, 但 soft, weak,
phantom references 并没有被 mark. 

dvmHeapProcessReferences 负责将 reference 放到 reference queue 中, 另
外, 对 soft reference, 会根据上层 dvmCollectGarbageInternal 使用的
spec, 决定是否将 soft reference 也进行 mark

gcHeap 本身对所有 soft, weak, phantom reference对象都维护着一个列表, 保
存着这些 Reference 对象, 以便这里可以方便的遍历. 每次 GC 时在 scan 阶段
都会重新生成这些列表, 这些列表中保存的 reference 对象本身肯定是 marked.

#+BEGIN_SRC text
  scanObject
    scanDataObject(obj, ctx);
      if (IS_CLASS_FLAG_SET(obj->clazz, CLASS_ISREFERENCE)):
        delayReferenceReferent((Object *)obj, ctx);
          enqueuePendingReference(obj, list);
#+END_SRC

另外, gcHeap 还维护着一个 finalizerReferences 列表, 这个队列中的成员不
是用户通过 new 生成的 reference, 而是一些那些定义了 finalize 函数的对
象. 

#+BEGIN_SRC text
  dvmHeapProcessReferences
    if (!gDvm.zygote && !clearSoftRefs):
      preserveSomeSoftReferences(softReferences);
        while (*list != NULL) {
          Object *ref = dequeuePendingReference(list);
          // referent 是 Reference 类的一个成员, 指向 reference 引用的对象
          // 例如 new WeakReference<Object>(o), 则 referent 指向 o
          Object *referent = dvmGetFieldObject(ref, referentOffset);
          bool marked = isMarked(referent, ctx);
          if (!marked && ((++counter) & 1)):
            /* Referent is white and biased toward saving, mark it. */
            markObject(referent, ctx);
            marked = true;
          if (!marked):
            /* Referent is white, queue it for clearing. */
            enqueuePendingReference(ref, &clear);
    // 所谓的 white reference, 是否 referent 没有被 mark 的 reference       
    clearWhiteReferences(softReferences);
    clearWhiteReferences(weakReferences);
    // 若 finalizerReferences 中的 reference 的 referent 没有 mark, 则
    // 将这个 reference 放到 f-queue 中, HeapWorker 会负责执行它的
    // finalize 函数. 但是正因为 HeapWorker 还需要访问 referent, 所以
    // referent 会被重新置为 marked
    enqueueFinalizerReferences(finalizerReferences);
  
    /*
    ,* Clear all f-reachable soft and weak references with white
    ,* referents.
    ,*/
    // 这两句又被调用一次? 因为 enqueueFinalizerReferences 可能导致
    // 新的 referent 变为 unmarked, 进而导致这些 referent 中的
    // reference 成员也变为 unmarked, 进而被加入 references 列表中, 所以需
    // 要对这些新加入的 reference 对象本身再 clear 一次. 
  
    clearWhiteReferences(softReferences);
    clearWhiteReferences(weakReferences);
  
    // phantom 在最后被 clear, 而不是像 weak, soft 那样在
    // enqueueFinalizerReferences 前就进行一次 clear. 为啥 weak, soft 的
    // 不能像 phantom 一样只在 enqueueFinalizerReferences 后进行一次?
    // 因为 soft, weak 对象本身有一个 referent 引用...而 phantom 是不包
    // 括这个成员的: 若新 enqueueFinalizerReferences 再 clear weak
    // references, 有可能会发生本该 clear 的 weak reference 没有 clear:
    // 因为 enqueueFinalizerReferences 将某个 weak reference 的 referent
    // 变为 marked 了...
  
    // phantom 的这个特点也使它适合用来代替 finalize 函数
    // 参考 jvm 使用 PhantomReference 避免 finalize()
    clearWhiteReferences(phantomReferences);
  
#+END_SRC

**** FinalizerReference
FinalizerReference 是一个 java 类, 但在 java 层并不可见: dalvik 在初始
化一个 Object 时, 若发现该对象实现了 finalize() 方法, 则会通过
dvmSetFinalizable (通过 FinalizerReference.add) 方法添加一个
FinalizerReference 对象对 FinalizerReference 的一个静态成员. 后续 GC
scan 时一定会找到这个 FinalizerReference.

*** dvmHeapSourceSwapBitmaps
#+BEGIN_SRC c
  HeapBitmap tmp = gHs->liveBits;
  gHs->liveBits = gHs->markBits;
  gHs->markBits = tmp;
#+END_SRC
简单的交换一下 liveBits 与 markBits, 以便进行下次 GC.
*** dvmHeapSweepUnmarkedObjects

Walk through the list of objects that haven't been marked and free
them.  Assumes the bitmaps have been swapped.

真正的 sweep 阶段

#+BEGIN_SRC text
  dvmHeapSweepUnmarkedObjects
    // 对每一个 garbage object 执行
    // 如何找到 garbage object? (liveBits & ~markBits) = 1 表示 garbage object
    // 注意这里的 markBits, liveBits 指的是 swap 前的 bitmap, 而且这个操作并
    // 不等价于 "异或" 操作.
    dvmHeapBitmapSweepWalk(sweepBitmapCallback,...)
#+END_SRC
 
#+BEGIN_SRC text
  sweepBitmapCallback(size_t numPtrs, void **ptrs, void *arg)
    dvmHeapSourceFreeList(numPtrs, ptrs);
      mspace_bulk_free(msp, ptrs, numPtrs);
#+END_SRC
** Daemons 与 ReferenceQueue
clearWhiteReferences 和 enqueueFinalizerReferences 最终会将 reference
对象放在 gDvm.gcHeap->clearedReferences 这个列表中. 

对于 FinalizerReference, 其 referent 对应的 finalize() 函数需要被调用.对
于 weak, soft, phantom reference, 其 ReferenceQueue 的 poll 或remove 需
要结束阻塞并返回该 reference. 如何做到?

在 GC 的最后阶段, dvmEnqueueClearedReferences 会负责将这些 reference
通知给 java 层的 ReferenceQueueDaemon:

#+BEGIN_SRC text
  dvmEnqueueClearedReferences
    Method *meth = gDvm.methJavaLangRefReferenceQueueAdd;
    dvmCallMethod(self, meth, NULL, &unused, reference);
#+END_SRC

实际上就是调用了 ReferenceQueue 的静态方法: add

#+BEGIN_SRC java
  static void add(Reference<?> list) {
      synchronized (ReferenceQueue.class) {
          if (unenqueued == null) {
              unenqueued = list;
          } else {
              Reference<?> next = unenqueued.pendingNext;
              unenqueued.pendingNext = list.pendingNext;
              list.pendingNext = next;
          }
          ReferenceQueue.class.notifyAll();
      }
  }
#+END_SRC

静态的 ReferenceQueue 拿到了所有的 white reference 和 finalize
reference, 但是 notifyAll 是通知谁?

答案就是 ReferenceQueueDaemon !

Daemons 是一个 java 类, 实际上就是对 Thread 的一个简单包装. 
当 zygote fork 后, 会通过 Daemons.start 启动如下的线程:

1. ReferenceQueueDaemon
2. FinalizerDaemon
3. FinalizerWatchdogDaemon

ReferenceQueueDaemon 负责在 ReferenceQueue 上 wait, 等待 dalvik 的通知,
一旦拿到 reference, 会把消息分发给各个 reference

1. 对于 weak, soft, phantom 等 white reference 来说, 就是通知各自的 ReferenceQueue 对象.
2. 对于 FinalizerReference 来说, 就是通知 FinalizerDaemon 开始工作: 调
   用 finalize() 函数.

还有一个 FinalizerWatchdogDaemon 是负责监视 finalize 函数的执行的, 执
行过久的进程会被 kill. 

** HeapWorker
dalvik 启动时会启动 HeapWorker 线程, 负责 concurrent GC.

HeapWorker 对应于这个 native thread:

#+BEGIN_SRC c
  static void *gcDaemonThread(void* arg)
  {
      dvmChangeStatus(NULL, THREAD_VMWAIT);
      bool trim = false;
      if (gHs->gcThreadTrimNeeded) {
          int result = dvmRelativeCondWait(&gHs->gcThreadCond, &gHs->gcThreadMutex,
                                           HEAP_TRIM_IDLE_TIME_MS, 0);
          if (result == ETIMEDOUT) {
              /* Timed out waiting for a GC request, schedule a heap trim. */
              trim = true;
          }
      } else {
          dvmWaitCond(&gHs->gcThreadCond, &gHs->gcThreadMutex);
      }
  
      // Many JDWP requests cause allocation. We can't take the heap lock and wait to
      // transition to runnable so we can start a GC if a debugger is connected, because
      // we don't know that the JDWP thread isn't about to allocate and require the
      // heap lock itself, leading to deadlock. http://b/8191824.
      if (gDvm.debuggerConnected) {
          continue;
      }
  
      dvmLockHeap();
      /*
       ,* Another thread may have started a concurrent garbage
       ,* collection before we were scheduled.  Check for this
       ,* condition before proceeding.
       ,*/
      if (!gDvm.gcHeap->gcRunning) {
          dvmChangeStatus(NULL, THREAD_RUNNING);
          if (trim) {
              trimHeaps();
              gHs->gcThreadTrimNeeded = false;
          } else {
              dvmCollectGarbageInternal(GC_CONCURRENT);
              gHs->gcThreadTrimNeeded = true;
          }
          dvmChangeStatus(NULL, THREAD_VMWAIT);
      }
      dvmUnlockHeap();
      dvmChangeStatus(NULL, THREAD_RUNNING);
      return NULL;
  }
#+END_SRC

可见, HeapWorker 是否工作取决于 gHs->gcThreadCond, 参考
dvmHeapSourceAlloc 的代码:

#+BEGIN_SRC text
  dvmHeapSourceAlloc
    if (heap->bytesAllocated > heap->concurrentStartBytes):
      /*
      ,* We have exceeded the allocation threshold.  Wake up the
      ,* garbage collector.
      ,*/
      dvmSignalCond(&gHs->gcThreadCond);
  
#+END_SRC
所以, 如果当前已经发配的内存大于 heap->concurrentStartBytes 时 (默认的
配置是 freeBytes - CONCURRENT_START(128KB), 即当可用内存少于 128KB 时),
HeapWorker 会开始工作, 并且周期性的 (HEAP_TRIM_IDLE_TIME_MS) 执行
dvmCollectGarbageInternal

** Concurrent GC
HeapWorker 实际上就是实现了 Concurrent Mark Sweep (CMS), 说它是
concurrent, 不是因为它会周期性的执行, 而是因为它允许在
dvmHeapScanMarkedObjects() 时各个 java 继续执行, 而不必`stop the
world` (并发标记).

关于 CMS:
http://dl.acm.org/citation.cfm?id=362422.362480

"This paper reports our experiences with a mostly-concurrent
incremental garbage collector, implemented in the context of a high
performance virtual machine for the Java™ programming language. The
garbage collector is based on the “mostly parallel” collection
algorithm of Boehm et al. and can be used as the old generation of a
generational memory system. It overloads efficient write-barrier code
already generated to support generational garbage collection to also
identify objects that were modified during concurrent marking. These
objects must be rescanned to ensure that the concurrent marking phase
marks all live objects. This algorithm minimises maximum garbage
collection pause times, while having only a small impact on the
average garbage collection pause time and overall execution time. We
support our claims with experimental results, for both a synthetic
benchmark and real programs."

CMS 一般分为四个阶段:
1. 初始标记
   对应于 dvmCollectGarbageInternal 的 dvmHeapMarkRootSet
2. 并发标记
   对应于 dvmHeapScanMarkedObjects
3. 重新标记
   对应于 dvmHeapReMarkRootSet 与 dvmHeapReScanMarkedObjects
4. 清除


CMS 可以更快, 是因为并发标记期间并没有 `stop the world`, 但带来的后果是
并发标记结束后有可能会因为其他线程的执行产生新的可达对象, 这时就需要重
新标记. 但是重新标记不能像初始标记和并发标记那样从头扫描一次, 这样就速
度太慢没有意义.

要做到快速重新标记, 需要一个叫做 CardTable 的东西与之配合.

CardTable 实际就是一个 write barrier, GC Heap 被分割为固定大小的 card
保存在 CardTable 中, 每次对 GC Heap 的修改会导致 CardTable 中相应的
card 被标记为 dirty. 如此一来, 重新标记时只需要考虑这些 dirty 的 card
对应的内存中的对象. 
#+BEGIN_SRC text
    scanDirtyCards
      HeapBitmap *markBits = ctx->bitmap;
      const u1 *card = start, *prevAddr = NULL;
      while (card < end):
        if (*card != GC_CARD_DIRTY):
          return card;
        while (ptr < limit):
          // 所谓的 gray object, 是指该 object 已经扫描到, 但没有后续进一步扫描
          // dalvic GC mark 部分代码频繁提到 black, white, gray, 应该是指 dalvik
          // 使用了 tri-color marking (三色标记算法)
          // 重新标记的目的不是为了把已经 mark 的 unmark, 而是
          // 将新产生的可达的 object 重新 mark, 确保没有正在使用
          // 的对象被 GC
          // Additionally, although the
          // collector guarantees to identify all live objects during a
          // marking phase, some objects may become garbage during that phase
          // and they will not be reclaimed until the next old
          // generation collection. Such objects are referred to as floating garbage.
          Object *obj = nextGrayObject(ptr, limit, markBits);
            // nextGrayObject 的过程是在 dirty card 表示的内存的范围内
            // 对每一个 8 bytes 对齐的地址在 markBits 中查找, 看看是不是一个
            // 对象.
            for (ptr = base; ptr < limit; ptr += HB_OBJECT_ALIGNMENT) {
              if (dvmHeapBitmapIsObjectBitSet(markBits, ptr)):
                return (Object *)ptr;
          scanObject(obj, ctx);
          ptr = (u1*)obj + ALIGN_UP(objectSize(obj), HB_OBJECT_ALIGNMENT);
         
        if (ptr < limit) {
        /* Ended within the current card, advance to the next card. */
          ++card;
#+END_SRC

** Copying GC
上面提到的都是关于 MarkSweep GC 的, 包含 markBits, liveBits,
Concurrent GC 等都是和 MarkSweep GC 相关. 因为 android 默认的就是
MarkSweep GC. 

实际上, android 还实现了一个 Copying GC, 还两种 GC 对外都是实现了
HeapSource 这一接口, 例如 dvmHeapSourceAlloc 这个负责分配内存的函数在
HeapSource.cpp (对应 MarkSweep) 和 Copying.cpp (对应 Copying) 中都有实
现. 编译时只会编译某一个进行 (否则会发生重复定义), 所以两者只能在编译
时确定使用哪个, 无法动态切换. 

Copying GC 把整个 GC Heap 分为大小为 512 Bytes 的 block, 并且通过一个
blockSpace 数组来记录各个 block 的状态, 目前定义了四种状态:
- BLOCK_FREE
- BLOCK_FROM_SPACE
- BLOCK_TO_SPACE
- BLOCK_CONTINUED

即, Copying GC 并没有像传统的 Copying GC 那样, 把 heap 分为两个固定大
小的空间, 也没有像 hotspot 那样分为一个 eden 和两个 survivor. 


*** dvmHeapSourceAlloc
初始状态下所有 block 都为 free, 当每次调用 dvmHeapSourceAlloc 时,
Copying GC 会通过两个指针记录当前正在"使用"的 block:

#+BEGIN_SRC text
  /* Start of free space in the current block. */
  u1 *allocPtr;
  /* Exclusive limit of free space in the current block. */
  u1 *allocLimit;
#+END_SRC

若要分配的对象大小还能放在当前正在"使用"的 block 中, 则直接通过
advance allocPtr 的方法来分配. 

若当前 block 大小不够了, 则通过 allocateBlocks(heapSource, blocks) 分
配一个或多个新的连续 block, 然后把这些 block 在 blockSpace 中标记为
BLOCK_TO_SPACE, 并且修改 allocPtr 和 allocLimit, 把当前正在"使用" 的
block 指向新的 block.

*** dvmScavengeRoots
与 MarkSweep 把 GC 分为 mark 阶段和 sweep 阶段不同, copying 只有一个
scavenge 阶段. 

Copying GC 与 MarkSweep 一样, 都是通过 Heap.cpp 的
dvmCollectGarbageInternal 开始 GC 的

#+BEGIN_SRC text
  dvmCollectGarbageInternal
    dvmHeapMarkRootSet();
      /* do nothing */
    dvmHeapScanMarkedObjects();
      dvmScavengeRoots
    dvmHeapProcessReferences();
      /* do nothing */
    dvmHeapSweepUnmarkedObjects();
      /* do nothing */
    // ...
#+END_SRC

可见, 为了把后写的 Copying GC 放到之前按照 MarkSweep 实现的框架,Copying
GC 写了许多空的 stub 函数. 最终只有一个 dvmScavengeRoots 是有用的.


dvmScavengeRoots 需要解决几个问题:
1. 把对象从 BLOCK_FROM_SPACE 的 block 复制到 BLOCK_TO_SPACE
2. 修改引用关系
3. 对 `pinning` 的对象要特殊处理
4. 处理 hashcode

#+BEGIN_SRC text
  dvmScavengeRoots
    dvmHeapSourceFlip();
      // 把类型为 BLOCK_TO_SPACE 的 block 变为 BLOCK_FROM_SPACE
      // 因为 dvmHeapSourceAlloc 分配的对象都放在 BLOCK_TO_SPACE 中
      
    /*
    ,* Promote blocks with stationary objects.
    ,*/
    pinThreadList();
    pinReferenceTable(&gDvm.jniGlobalRefTable);
    pinReferenceTable(&gDvm.jniPinRefTable);
    pinHashTableEntries(gDvm.loadedClasses);
    pinHashTableEntries(gDvm.dbgRegistry);
    pinPrimitiveClasses();
    pinInternedStrings();
      // 所谓的 pin, 就是把一个 object 所在的 block 由 BLOCK_FROM_SPACE
      // 变为 BLOCK_TO_SPACE
      promoteBlockByAddr(*addr)
        heapSource->blockSpace[block] = BLOCK_TO_SPACE;
        enqueueBlock(heapSource, block);
  
    // 重置 allocPtr 和 allocLimit
    gDvm.gcHeap->heapSource->allocPtr = allocateBlocks(gDvm.gcHeap->heapSource, 1);
    gDvm.gcHeap->heapSource->allocLimit = gDvm.gcHeap->heapSource->allocPtr + BLOCK_SIZE;
  
    scavengeThreadList();
    scavengeReference(&gDvm.outOfMemoryObj);
    scavengeReference(&gDvm.internalErrorObj);
    scavengeReference(&gDvm.noClassDefFoundErrorObj);
    scavengeInternedStrings();
  
    scavengeBlockQueue();
  
    preserveSoftReferences(&gDvm.gcHeap->softReferences);
    clearWhiteReferences(&gDvm.gcHeap->weakReferences);
    processFinalizableReferences();
    clearWhiteReferences(&gDvm.gcHeap->softReferences);
    clearWhiteReferences(&gDvm.gcHeap->weakReferences);
    clearWhiteReferences(&gDvm.gcHeap->phantomReferences);
    clearFromSpace(gcHeap->heapSource);
#+END_SRC
与 MarkSweep 采用一个 markStack 来迭代 mark 类似, Copying GC 使用一个
blockQueue 进行迭代式的 scavenge.

在上面的函数中, scavengeBlockQueue 之前的各种 scavangeXxx 类似于
MarkSweep 的 scanRootSet, 这些函数会负责对 GC root 进行初步的
scavange, 主要是通过 allocateGray 在 BLOCK_TO_SPACE 生成 GC ROOT 的
copy. 这个新对象被称为 gray object, 是因为它们还需要后续的处理: 

1. 它引用到的其他对象还没处理
2. 它引用的对象的指针需要被调整

以下面的对象为例:
#+BEGIN_SRC java
  class A {
      B b;
      C c;
  }
  
  class B {
      int x;
  }
  
  class C {
      B b2;
  }
#+END_SRC

假设 A 对象有 GC root, 则 
1. scavange a, blockQueue 为 {a'}, 但其 a'.b, a'.c 都指向旧的 b,c 的地址.
2. scavange a', 导致 b,c 被 copy 到 b',c', 此时 blockQueue 为 {b',c'}
3. scavange b'
4. scavange c', blockQueue 为 {b2'}
5. scavange b2'

可见, scavange 过程是一个 BFS 过程.

BFS 中对每个节点的处理, 主要是 scavengeObject

#+BEGIN_SRC text
  scavengeObject
    scavengeDataObject
      scavengeReference((Object **) obj);
      for every field:
        Object **ref = (Object **)((u1 *)obj + offset);
        scavengeReference(ref);
#+END_SRC

最主要的代码是在 scavengeReference, 当我们对 a'->b 调用scavengeReference 时,
会导致:
1. a'->b 被复制到 b' 
2. a'->b 这个引用被修改为 a'->b'
3. b' 被加入 blockQueue 中

#+BEGIN_SRC text
  scavengeReference(Object ** obj)
    // toSpaceContains, 说明 *obj 已经是复制后的对象(或者该对象是 pin 状
    // 态),且上层引用的也是新的对象了, 直接返回
    if (toSpaceContains(*obj)):
      LOG_SCAV("scavengeReference skipping pinned object @ %p", *obj);
      return;
    if (isForward(*obj)):
      // 说明 a'->b 指向还是旧的 b 对象, 但是旧的 b 对象已经被标记为 forward
      // 即 b' 已经生成, 通过 getForward 可以拿到这个 b'
      ,*obj = (Object *)getForward(*obj);
      return;
    // a'->b 还没经过 copy
    toObj = transportObject(fromObj);
      assert(fromSpaceContains(fromObj));
      toObj = allocateGray(allocSize);
        addr = dvmHeapSourceAlloc(size);
        block = addressToBlock(heapSource, (const u1 *)addr);
        // 新的 gray object 进行 blockQueue
        enqueueBlock(heapSource, block);
      memcpy(toObj, fromObj, copySize);
    setForward(toObj, fromObj);
      ,*(unsigned long *)fromObj = (uintptr_t)toObj | 0x1;
    ,*obj = (Object *)toObj;    
      
#+END_SRC

**** forward
getForward, isForward, setForward 这三个函数是用来实现对象移动后指针的
重定位的. 
例如, 假设 a->b 和 c->b2 本来指向的是同一个 B 对象. 当 scavenge a 的过
程中, b 被复制到 b', 那么 scavenge c 时, 如果把 c'->b2 指向 b'?

当 b 被复制到 b' 时, 会调用 setForward(b',b), 即

#+BEGIN_SRC text
    *(unsigned long *)b = (uintptr_t)b' | 0x1;
#+END_SRC

可见, setForward 后, 原来的 b 对象不再是一个有效的 java 对象, 因为它的
每一个 long 会被改写为 b' 的地址加一个 0x1 的标记 (这种 b' | 0x1 是有
效的, 因为 b' 保证是 8 bytes 对齐的), 这种改写虽然破坏了 b 对象, 但信
息通过 b' 已经保存了下来, 没有什么问题. 

当 scavenge c' 时, 通过对 c'->b2 执行 isForward 判断, 可以知道 b2' 是
否存在, 若已经存在, 则直接通过 getForward 从 b2 中获得 b2' 地址即可.

**** hashcode
#+BEGIN_SRC text
  Object *transportObject(const Object *fromObj)
    if (LW_HASH_STATE(fromObj->lock) != LW_HASH_STATE_UNHASHED):
      /*
      ,* The object has been hashed or hashed and moved.  We must
      ,* reserve an additional word for a hash code.
      ,*/
      allocSize += sizeof(u4);
    toObj = allocateGray(allocSize);
    if (LW_HASH_STATE(fromObj->lock) == LW_HASH_STATE_HASHED):
      /*
      ,* The object has had its hash code exposed.  Append it to the
      ,* instance and set a bit so we know to look for it there.
      ,*/
      ,*(u4 *)(((char *)toObj) + copySize) = (u4)fromObj >> 3;
      toObj->lock |= LW_HASH_STATE_HASHED_AND_MOVED << LW_HASH_STATE_SHIFT;
  
#+END_SRC

** softLimit 与 footprint
softLimit 总是和 utilization 对应的, 每次 GC 结束时都会通过
dvmHeapSourceGrowForUtilization 将 softLimit 设置为一个稍微大于
bytesAllocated 的值, 以防止有过多的垃圾被保留. 

footprint 在 softLimit 去掉后仍不能分配成功时会临时性的增长为
growthLimit, 待分配完毕后会被设为 bytesAllocated, 但是当
dvmHeapSourceGrowForUtilization 时 dalvik 会保证 footprint 一定不小于
softLimit.

#+BEGIN_SRC text
  setSoftLimit()
    size_t currentHeapSize = mspace_footprint(msp);
    if (softLimit < currentHeapSize):
      /* Don't let the heap grow any more, and impose a soft limit.
      ,*/
      mspace_set_footprint_limit(msp, currentHeapSize);
      hs->softLimit = softLimit;
    else:
      /* Let the heap grow to the requested max, and remove any
      ,* soft limit, if set.
      ,*/
      mspace_set_footprint_limit(msp, softLimit);
      hs->softLimit = SIZE_MAX;
#+END_SRC

所以这种情况是可能的:
因为不停的分配而不释放, footprint 被增长到很大. 后来大批垃圾被 GC,
footprint 仍会保留为原先那个较大的值 (代码中没有看到 footprint 会在 GC
后被缩小), 此时 heap 可能显示有大量的剩余, 但因为 softLimit 总是维持在
一个比较小的范围, 所以此时进行内存分配时还是可能发生 GC.

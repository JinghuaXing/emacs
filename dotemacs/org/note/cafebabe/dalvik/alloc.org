#+TITLE: Alloc
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* Alloc
** Glossary
- HeapSource
- GcHeap
- MarkSweep
- Copying
- Mspace & dlmalloc
- liveBits
- markBits
- markStack
- cardTable
- HeapWorker

** dvmAllocObject
#+BEGIN_SRC text
  Object* dvmAllocObject(ClassObject* clazz, int flags)
    newObj = (Object*)dvmMalloc(clazz->objectSize, flags);
      ptr = tryMalloc(size);
        ptr = dvmHeapSourceAlloc(size);
        if (ptr != NULL):
          return ptr;
        // 分配失败, 开始 GC, false 表示 SoftReferences 不被 GC
        gcForMalloc(false);
          dvmCollectGarbageInternal(GC_FOR_MALLOC);
        // 第二次 malloc  
        ptr = dvmHeapSourceAlloc(size);
          ptr = mspace_malloc(heap->msp, n);
          // countAllocation 会将 hs->liveBits 对应的置 1
          countAllocation(heap, ptr);
        if (ptr != NULL): return ptr;
        // 第三次 ...
        ptr = dvmHeapSourceAllocAndGrow(size);
        if (ptr != NULL): return ptr;
        // 即使 Heap Grow 了还是不行, 再次 GC, true 表示 SoftReferences 也被 GC
        gcForMalloc(true);
        // 第四次 ...
        ptr = dvmHeapSourceAllocAndGrow(size);
        if (ptr != NULL): return ptr;
        return null;
      if (ptr == NULL):
        throwOOME();
    DVM_OBJECT_INIT(newObj, clazz);
      dvmSetFieldObject(obj, OFFSETOF_MEMBER(Object, clazz), clazz_)
#+END_SRC

** dvmCollectGarbageInternal
#+BEGIN_SRC text
    dvmCollectGarbageInternal(spec)
      // 一共有四种类型的 GC:
      // 1. GC_FOR_MALLOC, 对应于 dvmMalloc 时的第一次 GC (不清理 SoftReferences)
      // 2. GC_CONCURRENT, 由 HeapWorker 发起的 GC
      // 3. GC_EXPLICIT, 由 System.gc() 发起的 GC
      // 4. GC_BEFORE_OOM, 对应于 dvmMalloc 时第二次 GC (清理 SoftReferences)
      if (spec == GC_FOR_MALLOC):
        ATRACE_BEGIN("GC (Alic)");
      else if (spec == GC_CONCURRENT):
        ATRACE_BEGIN("GC (concurrent)");
      else if (spec == GC_EXPLICIT):
        ATRACE_BEGIN("GC (explicit)");
      else if (spec == GC_BEFORE_OOM):
        ATRACE_BEGIN("GC (before OOM)");
      else:
        ATRACE_BEGIN("GC (unknown)");
      // 参考: dalvik thread dvmSuspendAllThreads
      dvmSuspendAllThreads(SUSPEND_FOR_GC);
      // mark 阶段
      /* Mark the set of objects that are strongly reachable from the roots.
      ,*/
      dvmHeapMarkRootSet();
      /* Recursively mark any objects that marked objects point to strongly.
      ,* If we're not collecting soft references, soft-reachable
      ,* objects will also be marked.
      ,*/
      dvmHeapScanMarkedObjects();
      /*
      ,* All strongly-reachable objects have now been marked.  Process
      ,* weakly-reachable objects discovered while tracing.
      ,*/
      dvmHeapProcessReferences();
      // sweep 阶段
      dvmHeapSweepSystemWeaks();
      /*
      ,* Live objects have a bit set in the mark bitmap, swap the mark
      ,* and live bitmaps.  The sweep can proceed concurrently viewing
      ,* the new live bitmap as the old mark bitmap, and vice versa.
      ,*/
      dvmHeapSourceSwapBitmaps();
      dvmHeapSweepUnmarkedObjects();
      // 将本次 GC 产生的 white reference 和 finalizer reference 通知给
      // java 层的 ReferenceQueueDaemon
      dvmEnqueueClearedReferences(&gDvm.gcHeap->clearedReferences);
  
#+END_SRC

*** dvmHeapMarkRootSet
#+BEGIN_SRC text
  rootMarkObjectVisitor(void *addr, u4 thread, ...)
    markObjectNonNull(obj, ctx, false);
    
  dvmHeapMarkRootSet
    // rootMarkObjectVisitor 是一个 callback, 对每一个 gc root 中的对象
    // 都会调用这个 visitor
    dvmVisitRoots(rootMarkObjectVisitor, &gcHeap->markContext);
      visitHashTable(visitor, gDvm.loadedClasses, ROOT_STICKY_CLASS, arg);
      visitPrimitiveTypes(visitor, arg);
      visitHashTable(visitor, gDvm.literalStrings, ROOT_INTERNED_STRING, arg);
      visitIndirectRefTable(visitor, &gDvm.jniGlobalRefTable, 0, ROOT_JNI_GLOBAL, arg);
      visitReferenceTable(visitor, &gDvm.jniPinRefTable, 0, ROOT_VM_INTERNAL, arg);
      // visitThreads 是最主要的一过 scan 过程: GC root 大部分例如 static 对象,
      // 局部对象等都包含在 stack frame 中, visitThreads 负责扫描所有
      // stack frame
      visitThreads(visitor, arg);
        for each thread:
          (*visitor)(&thread->threadObj, threadId, ROOT_THREAD_OBJECT, arg);
          (*visitor)(&thread->exception, threadId, ROOT_NATIVE_STACK, arg);
          visitIndirectRefTable(visitor, &thread->jniLocalRefTable, threadId, ...);
          // visitThreadStack 负责扫描所有的 stack frame, 并根据 stack
          // frame 中 register 的使用情况来判断是否要 mark
          visitThreadStack(visitor, thread, arg);
            // 遍历所有 frame
            for (u4 *fp = (u4 *)thread->interpSave.curFrame;
                  fp != NULL;
                  fp = (u4 *)saveArea->prevFrame):
              // 若此时存在 register map, 则根据 register map 得到
              // register 使用情况, 否则, 扫描所有的 register
              // 对每一个可能使用的 register, 通过 liveBits 可以判断
              // 出这个 register 对应的地址是否是一个 java 对象
#+END_SRC

**** 关于 bitmap 的操作
对于 markBits 和 liveBits 一样

markObjectNonNull 的过程是: 根据 addr 换算出对象在 bitmap 中的 bit
index, 将 bitmap 该bit 置 1, 因为 dalvik 中所有的对象都是 8 bytes 对齐
的, 所以 bitmap 中每 bit 代表 heap 的 8 bytes.

假设 gc heap 大小为 32 bytes, 则 markBits 的大小为 4 bits, 假设一共有两
个对象需要 mark, 地址相对于 heap->base 的 offset 分别为 0, 16, 则
markBits 的值为 1010, 即 markBits 只标记对象的地址, 和对象的大小无关.

*** dvmHeapScanMarkedObjects
#+BEGIN_SRC text
  dvmHeapScanMarkedObjects
    /* The bitmaps currently have bits set for the root set.
    ,* Walk across the bitmaps and scan each object.
    ,*/
    // dvmHeapBitmapScanWalk 负责扫描 markBits, 对直接引用的
    // filed 等进行 mark, 并放到 markStack 中
    dvmHeapBitmapScanWalk(ctx->bitmap, scanBitmapCallback, ctx);
    processMarkStack(ctx);
      // 在 scanObject 过程中, markStack 会增长, 通过 markStack, 将递归
      // 过程变为迭代
      GcMarkStack *stack = &ctx->stack;
      while (stack->top > stack->base):
        const Object *obj = markStackPop(stack);
        scanObject(obj, ctx);
#+END_SRC

*** dvmHeapProcessReferences
到此, 所有 strong references 的对象都被 mark 了, 但 soft, weak,
phantom references 并没有被 mark. 

dvmHeapProcessReferences 负责将 reference 放到 reference queue 中, 另
外, 对 soft reference, 会根据上层 dvmCollectGarbageInternal 使用的
spec, 决定是否将 soft reference 也进行 mark

gcHeap 本身对所有 soft, weak, phantom reference对象都维护着一个列表, 保
存着这些 Reference 对象, 以便这里可以方便的遍历. 每次 GC 时在 scan 阶段
都会重新生成这些列表, 这些列表中保存的 reference 对象本身肯定是 marked.

#+BEGIN_SRC text
  scanObject
    scanDataObject(obj, ctx);
      if (IS_CLASS_FLAG_SET(obj->clazz, CLASS_ISREFERENCE)):
        delayReferenceReferent((Object *)obj, ctx);
          enqueuePendingReference(obj, list);
#+END_SRC

另外, gcHeap 还维护着一个 finalizerReferences 列表, 这个队列中的成员不
是用户通过 new 生成的 reference, 而是一些那些定义了 finalize 函数的对
象. 

#+BEGIN_SRC text
  dvmHeapProcessReferences
    if (!gDvm.zygote && !clearSoftRefs):
      preserveSomeSoftReferences(softReferences);
        while (*list != NULL) {
          Object *ref = dequeuePendingReference(list);
          // referent 是 Reference 类的一个成员, 指向 reference 引用的对象
          // 例如 new WeakReference<Object>(o), 则 referent 指向 o
          Object *referent = dvmGetFieldObject(ref, referentOffset);
          bool marked = isMarked(referent, ctx);
          if (!marked && ((++counter) & 1)):
            /* Referent is white and biased toward saving, mark it. */
            markObject(referent, ctx);
            marked = true;
          if (!marked):
            /* Referent is white, queue it for clearing. */
            enqueuePendingReference(ref, &clear);
    // 所谓的 white reference, 是否 referent 没有被 mark 的 reference       
    clearWhiteReferences(softReferences);
    clearWhiteReferences(weakReferences);
    // 若 finalizerReferences 中的 reference 的 referent 没有 mark, 则
    // 将这个 reference 放到 f-queue 中, HeapWorker 会负责执行它的
    // finalize 函数. 但是正因为 HeapWorker 还需要访问 referent, 所以
    // referent 会被重新置为 marked
    enqueueFinalizerReferences(finalizerReferences);
  
    /*
    ,* Clear all f-reachable soft and weak references with white
    ,* referents.
    ,*/
    // 这两句又被调用一次? 因为 enqueueFinalizerReferences 可能导致
    // 新的 referent 变为 unmarked, 进而导致这些 referent 中的
    // reference 成员也变为 unmarked, 进而被加入 references 列表中, 所以需
    // 要对这些新加入的 reference 对象本身再 clear 一次. 
  
    clearWhiteReferences(softReferences);
    clearWhiteReferences(weakReferences);
  
    // phantom 在最后被 clear, 而不是像 weak, soft 那样在
    // enqueueFinalizerReferences 前就进行一次 clear. 为啥 weak, soft 的
    // 不能像 phantom 一样只在 enqueueFinalizerReferences 后进行一次?
    // 因为 soft, weak 对象本身有一个 referent 引用...而 phantom 是不包
    // 括这个成员的: 若新 enqueueFinalizerReferences 再 clear weak
    // references, 有可能会发生本该 clear 的 weak reference 没有 clear:
    // 因为 enqueueFinalizerReferences 将某个 weak reference 的 referent
    // 变为 marked 了...
  
    // phantom 的这个特点也使它适合用来代替 finalize 函数
    // 参考 jvm 使用 PhantomReference 避免 finalize()
    clearWhiteReferences(phantomReferences);
  
#+END_SRC
*** dvmHeapSourceSwapBitmaps
#+BEGIN_SRC c
  HeapBitmap tmp = gHs->liveBits;
  gHs->liveBits = gHs->markBits;
  gHs->markBits = tmp;
#+END_SRC
简单的交换一下 liveBits 与 markBits, 以便进行下次 GC.
*** dvmHeapSweepUnmarkedObjects

Walk through the list of objects that haven't been marked and free
them.  Assumes the bitmaps have been swapped.

真正的 sweep 阶段

#+BEGIN_SRC text
  dvmHeapSweepUnmarkedObjects
    // 对每一个 garbage object 执行
    // 如何找到 garbage object? (liveBits & ~markBits) = 1 表示 garbage object
    // 注意这里的 markBits, liveBits 指的是 swap 前的 bitmap, 而且这个操作并
    // 不等价于 "异或" 操作.
    dvmHeapBitmapSweepWalk(sweepBitmapCallback,...)
#+END_SRC
 
#+BEGIN_SRC text
  sweepBitmapCallback(size_t numPtrs, void **ptrs, void *arg)
    dvmHeapSourceFreeList(numPtrs, ptrs);
      mspace_bulk_free(msp, ptrs, numPtrs);
#+END_SRC
** Daemons 与 ReferenceQueue
clearWhiteReferences 和 enqueueFinalizerReferences 最终会将 reference
对象放在 gDvm.gcHeap->clearedReferences 这个列表中. 

对于 FinalizerReference, 其 referent 对应的 finalize() 函数需要被调用.对
于 weak, soft, phantom reference, 其 ReferenceQueue 的 poll 或remove 需
要结束阻塞并返回该 reference. 如何做到?

在 GC 的最后阶段, dvmEnqueueClearedReferences 会负责将这些 reference
通知给 java 层的 ReferenceQueueDaemon:

#+BEGIN_SRC text
  dvmEnqueueClearedReferences
    Method *meth = gDvm.methJavaLangRefReferenceQueueAdd;
    dvmCallMethod(self, meth, NULL, &unused, reference);
#+END_SRC

实际上就是调用了 ReferenceQueue 的静态方法: add

#+BEGIN_SRC java
  static void add(Reference<?> list) {
      synchronized (ReferenceQueue.class) {
          if (unenqueued == null) {
              unenqueued = list;
          } else {
              Reference<?> next = unenqueued.pendingNext;
              unenqueued.pendingNext = list.pendingNext;
              list.pendingNext = next;
          }
          ReferenceQueue.class.notifyAll();
      }
  }
#+END_SRC

静态的 ReferenceQueue 拿到了所有的 white reference 和 finalize
reference, 但是 notifyAll 是通知谁?

答案就是 ReferenceQueueDaemon !

Daemons 是一个 java 类, 实际上就是对 Thread 的一个简单包装. 
当 zygote fork 后, 会通过 Daemons.start 启动如下的线程:

1. ReferenceQueueDaemon
2. FinalizerDaemon
3. FinalizerWatchdogDaemon

ReferenceQueueDaemon 负责在 ReferenceQueue 上 wait, 等待 dalvik 的通知,
一旦拿到 reference, 会把消息分发给各个 reference

1. 对于 weak, soft, phantom 等 white reference 来说, 就是通知各自的 ReferenceQueue 对象.
2. 对于 FinalizerReference 来说, 就是通知 FinalizerDaemon 开始工作: 调
   用 finalize() 函数.

还有一个 FinalizerWatchdogDaemon 是负责监视 finalize 函数的执行的, 执
行过久的进程会被 kill. 

** HeapWorker
dalvik 启动时会启动 HeapWorker 线程, 负责 concurrent GC.

HeapWorker 对应于这个 native thread:

#+BEGIN_SRC c
  static void *gcDaemonThread(void* arg)
  {
      dvmChangeStatus(NULL, THREAD_VMWAIT);
      bool trim = false;
      if (gHs->gcThreadTrimNeeded) {
          int result = dvmRelativeCondWait(&gHs->gcThreadCond, &gHs->gcThreadMutex,
                                           HEAP_TRIM_IDLE_TIME_MS, 0);
          if (result == ETIMEDOUT) {
              /* Timed out waiting for a GC request, schedule a heap trim. */
              trim = true;
          }
      } else {
          dvmWaitCond(&gHs->gcThreadCond, &gHs->gcThreadMutex);
      }
  
      // Many JDWP requests cause allocation. We can't take the heap lock and wait to
      // transition to runnable so we can start a GC if a debugger is connected, because
      // we don't know that the JDWP thread isn't about to allocate and require the
      // heap lock itself, leading to deadlock. http://b/8191824.
      if (gDvm.debuggerConnected) {
          continue;
      }
  
      dvmLockHeap();
      /*
       ,* Another thread may have started a concurrent garbage
       ,* collection before we were scheduled.  Check for this
       ,* condition before proceeding.
       ,*/
      if (!gDvm.gcHeap->gcRunning) {
          dvmChangeStatus(NULL, THREAD_RUNNING);
          if (trim) {
              trimHeaps();
              gHs->gcThreadTrimNeeded = false;
          } else {
              dvmCollectGarbageInternal(GC_CONCURRENT);
              gHs->gcThreadTrimNeeded = true;
          }
          dvmChangeStatus(NULL, THREAD_VMWAIT);
      }
      dvmUnlockHeap();
      dvmChangeStatus(NULL, THREAD_RUNNING);
      return NULL;
  }
#+END_SRC

可见, HeapWorker 是否工作取决于 gHs->gcThreadCond, 参考
dvmHeapSourceAlloc 的代码:

#+BEGIN_SRC text
  dvmHeapSourceAlloc
    if (heap->bytesAllocated > heap->concurrentStartBytes):
      /*
      ,* We have exceeded the allocation threshold.  Wake up the
      ,* garbage collector.
      ,*/
      dvmSignalCond(&gHs->gcThreadCond);
  
#+END_SRC
所以, 如果当前已经发配的内存大于 heap->concurrentStartBytes 时 (默认的
配置是 freeBytes - CONCURRENT_START(128KB), 即当可用内存少于 128KB 时),
HeapWorker 会开始工作, 并且周期性的 (HEAP_TRIM_IDLE_TIME_MS) 执行
dvmCollectGarbageInternal

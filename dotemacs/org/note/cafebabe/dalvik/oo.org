#+TITLE: OO
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* OO
Java 本身并没有规定 Object 的内存布局, 例如在 class 文件, 引用某个
instance filed 时完全通过 constant pool 来指定, 不涉及任何实现细节. 但
具体实现 vm 时, 内存布局是必须要考虑的.

Dalvik 的 Object Model 定义起来比较简单: 它是用 C++ 语言来描述的. 所以
`一般`不需要关注内存布局中的细节, 但如果涉及到 fast mterp, 还是需要从内
存布局的角度描述 Object Model.

Dalvik 使用 C++ 定义了五种对象:

1. Object
2. ArrayObject
3. ClassObject
4. StringObject
5. DataObject

其中 Object 是其它四种对象的基类.

** ClassObject 与 Object

#+BEGIN_SRC c++
  struct Object {
      ClassObject*    clazz;
      u4              lock;
  };
  
  struct ClassObject : Object {
      u4              instanceData[CLASS_FIELD_SLOTS];
      const char*     descriptor;
      u4              accessFlags;
      // objectSize 是保存在 ClassObject (即 java 类中), 而不是保存在
      // java 对象中. 因为同一个类的对象的大小是相同的. 实际上就是 8 +
      // InstField 的大小. 
      size_t          objectSize;
      ClassObject*    super;
      Object*         classLoader;
      int             interfaceCount;
      ClassObject**   interfaces;
      // directMethod, 包括 private, static, <init> 等
      int             directMethodCount;
      Method*         directMethods;
      // 虚函数, 即非 directMethods, 这些函数不会直接被调用:
      // 它们会通过后面的 vtable 被调用. 另外, virtualMethods 只包含本 class 实现的虚函数.
      int             virtualMethodCount;
      Method*         virtualMethods;
      /*
       ,* Virtual method table (vtable), for use by "invoke-virtual".  The
       ,* vtable from the superclass is copied in, and virtual methods from
       ,* our class either replace those from the super or are appended.
       ,*/
      int             vtableCount;
      Method**        vtable;
      // 成员变量
      int             ifieldCount;
      InstField*      ifields;
  
      // interface table
      int             iftableCount;
      InterfaceEntry* iftable;
  
      /* static fields */
      int             sfieldCount;
      StaticField     sfields[0]; /* MUST be last item */
  };
#+END_SRC

从两个类的定义中, 可以看出:
1. Object 本身并没有太多的数据, 数据都存在于 ClassObject 中, 实际上,
   只有 InstField 会被保存在 Object 中.

以下面的代码为例:
#+BEGIN_SRC java
  class Base {
      int base;
  }
  class Foo extends Base {
      public static int xxx;
      public int bcd;
      public int abc;

      public static void main(String[] args) {
          Foo f = new Foo();
          f.abc= 0x1234;
          System.out.println("Hello, foo"+f.abc);
      }
  }
#+END_SRC

这段代码执行时会生成一个 Object 对象代表 Foo 对象, 以及一个
ClassObject 代表 Foo 类, 一个 ClassObject 代表 Base 类. 其中
ClassObject 的内存布局与 C++ 定义的一致.而 Object 的布局会有一点
tricky:

#+BEGIN_EXAMPLE

  Object
 -+-------------+      ClassObject
  | ClassObject-+---->+-------------------+
 -+-------------+     | ClassObject (NULL)|
  | lock        |    -+-------------------+
 -+-------------+     | lock              |
  | base field  |    -+-------------------+
 -+-------------+     | instance data     |
  | abc field   |    -+-------------------+
 -+-------------+     | descriptor        |
  | bcd field   |    -+-------------------+
 -+-------------+     | ....              |
                     -+-------------------+


#+END_EXAMPLE

上面的示意图有几点要注意:
1. instance field 是直接按一定顺序放在 Object 中的. 虽然 Object本身并没
   有定义一个类似于 InstField 的字段.
2. 基类的 InstField 会插入到 Object 自身的 InstField 之前 (通过
   computeFieldOffsets 代码可以确认)
3. ClassObject 的开头 8 个字节与 Object 结构相同, 因为它继承自 Object,
   这一点要参考 C++ Object Model
4. Object 中定义的 lock 字与 hotspot 中的 mark word作用类似, 但与 mark
   word 不同的是, lock 并不包含对象的年代信息以及 GC 信息.
** ArrayObject

#+BEGIN_SRC java
  struct ArrayObject : Object {
      /* number of elements; immutable after init */
      u4              length;
  
      /*
       ,* Array contents; actual size is (length * sizeof(type)).  This is
       ,* declared as u8 so that the compiler inserts any necessary padding
       ,* (e.g. for EABI); the actual allocation may be smaller than 8 bytes.
       ,*/
      u8              contents[1];
  };
  #+END_SRC
可见, 
1. ArrayObject offset 为 8 的 int 值保存着 Array 的长度. 
2. Array 的数据部分保存在它的变长的 contents 区域.
** StringObject
*** intern

OP_CONST_STRING:

#+BEGIN_SRC c
  HANDLE_OPCODE(OP_CONST_STRING /*vAA, string@BBBB*/)
  {
      StringObject* strObj;
  
      vdst = INST_AA(inst);
      ref = FETCH(1);
      ILOGV("|const-string v%d string@0x%04x", vdst, ref);
      strObj = dvmDexGetResolvedString(methodClassDex, ref);
      if (strObj == NULL) {
          EXPORT_PC();
          strObj = dvmResolveString(curMethod->clazz, ref);
          if (strObj == NULL)
              GOTO_exceptionThrown();
      }
      SET_REGISTER(vdst, (u4) strObj);
  }
  FINISH(2);
  OP_END
#+END_SRC

dvmResolveString:

#+BEGIN_SRC text
  StringObject* dvmResolveString(const ClassObject* referrer, u4 stringIdx)
    utf8 = dexStringAndSizeById(pDvmDex->pDexFile, stringIdx, &utf16Size);
    strObj = dvmCreateStringFromCstrAndLength(utf8, utf16Size);
    internStrObj = dvmLookupImmortalInternedString(strObj);
    return internStrObj;
#+END_SRC

** Class Loading
java 类加载的过程包含一般包括加载, 解析, 初始化等过程.  特别的, dvm 加
载类的过程基本上就是:
1. 加载

   从 odex 中加载类 (loadClassFromDex), 此后 ClassObject 的多数成员已经
   被初始化

2. 解析 (link)

   通过 dvmLinkClass, 将 ClassObject 中的存在的 symbolic references
   resolve 为 direct pointer (对于 vtable, superclass, iftable 等) 或
   offset (对于 sfields, ifields)

   需要注意的是, 在最初的 ClassLoader 初始化阶段, dexopt 会负责将 dex
   转换为 odex, 这时会做一些类似于 resolve 的工作, 但这些工作影响的主
   要是 dex 中的代码部分: 即 xxx 指令会被转换为 xxx_quick 指令, 使代码
   由使用 symbolic references 的方式变为使用 direct pointer 或 offset
   的方式. 所以, 即使有 odex, dvmLinkClass 时还是需要做 resolve 的动作. 

Class Loading 的入口是 findClassNoInit

findClassNoInit:
#+BEGIN_SRC text
  ClassObject* findClassNoInit(descriptor, loader, pDvmDex)
    clazz = loadClassFromDex(pDvmDex, pClassDef, loader);
      newClass = (ClassObject*) dvmMalloc(size, ALLOC_NON_MOVING);
      newClass->descriptor = descriptor;
      newClass->interfaceCount = pInterfacesList->size;
      // 读取 ifaces
      newClass->interfaces = (ClassObject**) dvmLinearAlloc(classLoader,
      newClass->interfaceCount * sizeof(ClassObject*));
  
      for (i = 0; i < newClass->interfaceCount; i++):
        const DexTypeItem* pType = dexGetTypeItem(pInterfacesList, i);
        newClass->interfaces[i] = (ClassObject*)(u4) pType->typeIdx;
  
      // 读取 sfield  
      newClass->sfieldCount = count;
      for (i = 0; i < count; i++):
        dexReadClassDataField(&pEncodedData, &field, &lastIndex);
        loadSFieldFromDex(newClass, &field, &newClass->sfields[i]);
      // 读取 ifield, direct methods, virtual methods ...
  
    dvmLinkClass(clazz)
      // resolve superclass 为 direct pointer
      ClassObject* super = dvmResolveClass(clazz, superclassIdx, false);
      dvmSetFieldObject(clazz,  OFFSETOF_MEMBER(ClassObject,super),super);
      // resolve ifaces
      for (i = 0; i < clazz->interfaceCount; i++) {
        clazz->interfaces[i] = dvmResolveClass(clazz,interfaceIdxArray[i], false);
      // 根据 virtualMethods 及 superclass, ifaces 生成 vtable
      createVtable(clazz)
        clazz->vtable = (Method**) dvmLinearAlloc(clazz->classLoader, maxCount);
        // 将 super 的 vtable 与 clazz 自己的 virtualMethods 进行比较,
        // 生成最终的 clazz->vtable
  
        // maxCount 是指本类的 vtable 可能达到的最大大小, 最终 vtable 的
        // 大小必然会 <= maxCount
        maxCount = clazz->virtualMethodCount;
        if (clazz->super != NULL):
          maxCount += clazz->super->vtableCount;
        clazz->vtable = (Method**) dvmLinearAlloc(sizeof(Method*) * maxCount);
        // 先用 super->vtable 覆盖 class->vtabl 的前几项
        memcpy(clazz->vtable, clazz->super->vtable,
              sizeof(*(clazz->vtable)) * clazz->super->vtableCount);
        actualCount = clazz->super->vtableCount;        
        // 然后扫描 class->virtualMethods, 通过名字的比较看是否有方法需要覆盖基类               for (i = 0; i < clazz->virtualMethodCount; i++):
          Method* localMeth = &clazz->virtualMethods[i];
          for (si = 0; si < clazz->super->vtableCount; si++):
            Method* superMeth = clazz->vtable[si];
            // 两个方法的名字和 signature 是相同的 ...
            if (dvmCompareMethodNamesAndProtos(localMeth, superMeth) == 0):
              // 确保基类方法不是 final
              if (dvmIsFinalMethod(superMeth)): bail;
              // 本类方法覆盖基类方法
              clazz->vtable[si] = localMeth;
              localMeth->methodIndex = (u2) si;
           // inner for ends here
           // super->vtable 中各项扫描完毕, 发现不能覆盖, 放到结尾
           if (si == clazz->super->vtableCount):
             clazz->vtable[actualCount] = localMeth;
             localMeth->methodIndex = (u2) actualCount;
         // outer for ends here
         assert(actualCount <= maxCount);
          
      // 生成 iftable
      // 上一步的 vtable 中包含了所有的虚函数, 包括继承自 super 的和自己
      // 实现的, 但自己实现的接口中的虚函数需要通过 iftable 进行索引, 因
      // 为 invoke-interface 和 invoke-virtual 是不同的, 前者需要
      // iftable 才能工作, 具体见
      // http://stackoverflow.com/questions/1504633/what-is-the-point-of-invokeinterface
      createIftable(clazz)
      // 计算所有 ifiled 的 offset, 后面的 GetFieldID 等需要使用
      // ifiled 与 vtable 的组织有些类似: 都是基类成员在前, 自身成员在后
      computeFieldOffsets(clazz)
        if (clazz->super != NULL):
          fieldOffset = clazz->super->objectSize;
          for (i = 0; i < clazz->ifieldCount; i++):
            pField->byteOffset = fieldOffset;
            fieldOffset += sizeof(u4);
      // precacheReferenceOffsets 会负责将 referent filed 从 ifields
      // 移除, 以便 GC 时 scanDataObject 时不会扫描到 referent 对象.
      if (strcmp(clazz->descriptor, "Ljava/lang/ref/Reference;") == 0):
        precacheReferenceOffsets(clazz)
#+END_SRC

loadClassFromDex
#+BEGIN_SRC text
  DexClassDef* pClassDef;
  pClassDef = dexFindClass(pDvmDex->pDexFile, descriptor);
    // DexClassDef 实际上就是 dex 文件中 Class Definition Table 中的一项
    // pLookup 是 odex 包含的一个对于加速查找的数据结构
    // ...
    return (const DexClassDef*)
      (pDexFile->baseAddr + pLookup->table[idx].classDefOffset);
  
  clazz = loadClassFromDex(pDvmDex, pClassDef, loader);
    // class data 是 class definition 的一项, 包含了各种 fields, methods
    // 的索引和权限信息
    pEncodedData = dexGetClassData(pDexFile, pClassDef);
    dexReadClassDataHeader(&pEncodedData, &header);
      pHeader->staticFieldsSize = readUnsignedLeb128(pData);
      pHeader->instanceFieldsSize = readUnsignedLeb128(pData);
      pHeader->directMethodsSize = readUnsignedLeb128(pData);
      pHeader->virtualMethodsSize = readUnsignedLeb128(pData);
    // pDvmDex 是 dex file
    // pClassDef 是 dex file 中的 Class Definition Table 中的一项
    // header 是 class 的各种 field, methods 在 dex file 中的索引
    // pEncodedData 是 pClassDef 的 data 部分
    loadClassFromDex0(pDvmDex, pClassDef, &header, pEncodedData, classLoader);
      pDexFile = pDvmDex->pDexFile;
      descriptor = dexGetClassDescriptor(pDexFile, pClassDef);
        // 使用 pClassDef->classIdx 扫描 String Table 获得 descriptor
        dexStringByTypeIdx(pDexFile, pClassDef->classIdx);
      newClass->descriptor = descriptor;
      //... 读取其它的 field, methods, interface ...
      // 包括在 LinearAlloc 上分配相应的 Field, Method 对象, 从 dex file
      // 中读取相应的数据, 这里读到的数据需要被后续的 dvmLinkClass 处理
      // 后才能使用, 包括:
      // 1. ifield 需要通过 link 得到在 Object 中的索引.
      // 2. super 需要通过 link 将 idx 变为实际的 ClassObject*
      // 3. iftable 需要通过 link 将 idx 变为 ClassObject*
      // 4. vtable 需要通过 link 生成
      // 5. ...
#+END_SRC

至此 ClassObject 已经准备完毕:

1. clazz->super 指向了父类的 ClassObject
2. clazz->virtualMethods 包含了所有该类实现的虚函数 Method, 而
   Method->insns 又指向了 mmap 的 odex 中真正的代码部分
3. clazz->vtable 包含该类, 父类中定义的所有虚函数 Method 的引用.
4. clazz->iftable 包含该类实现的接口函数在 vtable 中的引用.
5. clazz->ifield 中所有的 InstField 在 Object 中的 offset 被计算出来
6. ...

注意: ClassObject 本身分配在 GC Heap, 但它的 ifield, sfield,
virtualMethods 等成员却分配在 LinearAlloc. 分配在 GC Heap 可能主要是考
虑到 ClassObject 也要参与到 GC 扫描, 而 GC 扫描通过 liveBits, markBits
进行的, 必须要求 ClassObject 本身分配在 GC Heap 上 (因为 liveBits,
markBits 是针对 GC Heap 的 bitmap)

*** class 何时被加载
基本上涉及到 clazz 的 OP_CODE 都会直接或间接通过 dvmResolveClass 来导致
class 被加载.

以下情况下 class 会首次被加载:

1. 主动调用 Class.forName 等函数
2. 通过 reflect 的一些方法对 class 进行操作时
3. OP_NEW_INSTANCE
4. OP_SGET/OP_SSET
5. OP_INVOKE_STATIC
6. OP_INSTANCE_OF

invoke-virtual, invoke-interface 等以及 iget/iset 不包含在以上列表中,
因为这些调用之前, OP_NEW_INSTANCE 肯定已经把 class 加载完成了. 

** 各种函数的实现
*** iget / iset
**** Jni version
第一步, 获得 jfieldID, 这个 jfieldID 实际上是 InstField *, 其
byteOffset 保存着 Object 中保存该 ifield 的偏移量. 

#+BEGIN_SRC java
  static jfieldID GetFieldID(JNIEnv* env, jclass jclazz, const char* name, const char* sig) {
      ScopedJniThreadState ts(env);
      ClassObject* clazz = (ClassObject*) dvmDecodeIndirectRef(ts.self(), jclazz);
  
      // jfieldID 与 jmethodID 等一样, 实际类型都是一个 opaque pointer
      // 这里 jfieldID 的实际类型为 InstField*
      jfieldID id = (jfieldID) dvmFindInstanceFieldHier(clazz, name, sig);
      return id;
  }
#+END_SRC

第二步, 调用 GetField##_jname, 以 byte 为例
#+BEGIN_SRC text
  INLINE s1 dvmGetFieldByte(const Object* obj, int offset) {
      return ((JValue*)BYTE_OFFSET(obj, offset))->b;
  }
#+END_SRC
**** interpreter version
与下面 sget / sset 类似, 根据 dex 中的 id 获得 name, 然后根据 name 找
到 InstField*, 然后根据偏移量得到 ifield 的值. 

*** sget / sset
sget/sset 比 iget/iset 要复杂, 因为 static 变量可以存在于 interface 中
**** jni version
首先, GetStaticFieldID 得到 jfieldID, 这个 jfieldID 实现上是
StaticField *, 其 value 值即为所求. 
#+BEGIN_SRC text
  jfieldID GetStaticFieldID(env, jclazz, char* name, char* sig)
    jfieldID id = dvmFindStaticFieldHier(clazz, name, sig);
      // search in current clazz
      pField = dvmFindStaticField(clazz, fieldName, signature);
        // 通过遍历 clazz->sfields 查找
        pField = &clazz->sfields[0];
        for (i = 0; i < clazz->sfieldCount; i++, pField++):
          if (strcmp(fieldName, pField->name) == 0 &&
            strcmp(signature, pField->signature) == 0)
            return (StaticField*) pField;
        // 若 clazz 中没找到, 则查找所有接口
        for ( ; i < clazz->iftableCount; i++) {
          ClassObject* iface = clazz->iftable[i].clazz;
          pField = dvmFindStaticField(iface, fieldName, signature);
          if (pField != NULL):
            return pField;
        // 若所有接口中都没有找到, 则查找父类
        if (clazz->super != NULL):
          return dvmFindStaticFieldHier(clazz->super, fieldName, signature);
        else
          return NULL;
#+END_SRC

第二步, GetStaticField##_jname, 这个函数直接从 jfieldID (即
StaticField* ) 中取出 value 字段即可. 
**** interpreter version
#+BEGIN_SRC text
  // ref 是一个整数, odex 代码中不是使用 name 查找 filed 的, 而是已
  // 经计算出了 sfield 在 sfields 中的 offset, 所以第一步需要根据 ref 找
  // 到原来的 name
  
  StaticField* sfield = dvmResolveStaticField(clazz, ref);
    DexFieldId pFieldId = dexGetFieldId(pDvmDex->pDexFile, ref);
    // 通过 dexStringById 后到 name 后, 后面的调用和 jni 相同
    return dvmFindStaticFieldHier(resClass,
             dexStringById(pDvmDex->pDexFile, pFieldId->nameIdx),
             dexStringByTypeIdx(pDvmDex->pDexFile, pFieldId->typeIdx));
#+END_SRC
*** iget-quick/iset-quick
由于 iget/iset 本质是操作 Object 的一个 offset, 所以 odex 提供 quick 版
本的iget/iset, 直接以 offset 做为操作数. 

但 sget/sset 并不存在 quick 版本, 因为接口也可以包含 static 变量, 无法
通过一个 offset 简单的搞定. 

*** invoke
所有 invoke 类调用都分为两步:
1. 查找真正的 Method (dvmResolveMethod)
2. 调用 Method (处理参数, 返回值, 栈帧等)

dalvik 的 invoke 类调用共分为五种, 主要原因是查找 Method 的方法不同,
例如, invoke-direct 是从 Object 的 directMethods 中找, 而
invoke-virtual 需要从 Object->vtable 和 Object->virtualMethods 中找.
更复杂的 invoke-interface 需要从 Object->iftable, Object->vtable 和
Object->virtualMethods 中找到.

**** 五种 invoke
#+BEGIN_SRC java
  interface I {
      void i();
  }
  
  class Base {
      public void b() {};
  }
  
  class Foo extends Base implements I {
      public void b() {
          // invoke-super
          super.b();
      }
      public void i() {
          
      }
  
      void v() {}
      static void s() {}
  
      private void p() {}
      final void f() {}
      
      public static void main(String[] args) {
          // invoke-static
          Foo.s();
  
          Foo f =  new Foo();
          // invoke-virtual
          f.v();
          f.i();
          f.f();
          // invoke-interface
          ((I)f).i();
          // invoke-direct
          f.p();
      }
  }
  
#+END_SRC

对应的 dalvik 字节码为:
#+BEGIN_SRC text
  .class LFoo;
  .super LBase;
  .source "Foo.java"
  
  # interfaces
  .implements LI;
  
  
  # direct methods
  .method constructor <init>()V
      .locals 0
  
      .prologue
      .line 10
      invoke-direct {p0}, LBase;-><init>()V
  
      return-void
  .end method
  
  .method public static main([Ljava/lang/String;)V
      .locals 1
      .parameter
  
      .prologue
      .line 27
      invoke-static {}, LFoo;->s()V
  
      .line 29
      new-instance v0, LFoo;
  
      invoke-direct {v0}, LFoo;-><init>()V
  
      .line 31
      invoke-virtual {v0}, LFoo;->v()V
  
      .line 33
      invoke-virtual {v0}, LFoo;->i()V
  
      .line 34
      invoke-virtual {v0}, LFoo;->f()V
  
      .line 36
      invoke-interface {v0}, LI;->i()V
  
      .line 38
      invoke-direct {v0}, LFoo;->p()V
  
      .line 39
      return-void
  .end method
  
  .method private p()V
      .locals 0
  
      .prologue
      .line 22
      return-void
  .end method
  
  .method static s()V
      .locals 0
  
      .prologue
      .line 20
      return-void
  .end method
  
  
  # virtual methods
  .method public b()V
      .locals 0
  
      .prologue
      .line 13
      invoke-super {p0}, LBase;->b()V
  
      .line 14
      return-void
  .end method
  
  .method final f()V
      .locals 0
  
      .prologue
      .line 23
      return-void
  .end method
  
  .method public i()V
      .locals 0
  
      .prologue
      .line 17
      return-void
  .end method
  
  .method v()V
      .locals 0
  
      .prologue
      .line 19
      return-void
  .end method
  
#+END_SRC

虽然 invoke 分为五种, 但实际上根据查找的表的不同又分为两大类:

1. 查找 Object->directMethods
   - invoke-static
   - invoke-direct
2. 查找 Object->virtualMethods
   - invoke-super
   - invoke-virtual
   - invoke-interface
**** dvmResolveMethod
任何一种 invoke 的第一步都是调用 dvmResolveMethod 来查找真正的 Method,
不过不同的 invoke 会使用不同的参数

#+BEGIN_SRC text
  Method* dvmResolveMethod(const ClassObject* referrer, u4 methodIdx,MethodType methodType)
    // 根据 nameIdx 从 dex 中获得 method name
    char* name = dexStringById(pDvmDex->pDexFile, pMethodId->nameIdx);
    if (methodType == METHOD_DIRECT):
      resMethod = dvmFindDirectMethod(resClass, name, &proto);
    else if (methodType == METHOD_STATIC):
      resMethod = dvmFindDirectMethodHier(resClass, name, &proto);
    else:
      resMethod = dvmFindVirtualMethodHier(resClass, name, &proto);
  
  // ------------------- for direct
  Method* dvmFindDirectMethod(clazz, methodName, proto)
    // 从 Object->directMethods 中查找, 但使用一个 false 参数表示不需要
    // 从父类中查找
    findMethodInListByProto(clazz, METHOD_DIRECT, false, methodName,proto);
      while (clazz != NULL) {
        int i;
        if (wantedType == METHOD_VIRTUAL || wantedType == METHOD_UNKNOWN):
          for (i = 0; i < clazz->virtualMethodCount; i++):
            Method* method = &clazz->virtualMethods[i];
              // 基于字符串的匹配
              if (dvmCompareNameProtoAndMethod(name, proto, method) == 0) {
                return method;
        if (wantedType == METHOD_DIRECT || wantedType == METHOD_UNKNOWN):
          for (i = 0; i < clazz->directMethodCount; i++):
            Method* method = &clazz->directMethods[i];
              if (dvmCompareNameProtoAndMethod(name, proto, method) == 0):
                return method;
        if (! isHier):
          break;
      
        clazz = clazz->super;
      // end while
  
  // -------------------- for STATIC
  Method* dvmFindDirectMethod(clazz, methodName, proto)
    findMethodInListByProto(clazz, METHOD_DIRECT, true, methodName, proto)
  
  // -------------------- for VIRTUAL (mainly SUPER)
  Method* dvmFindVirtualMethodHier(clazz,methodName,proto)
    findMethodInListByProto(clazz, METHOD_VIRTUAL, true, methodName,proto);
  
  
#+END_SRC

**** invoke-static
#+BEGIN_SRC text
  methodToCall = dvmResolveMethod(curMethod->clazz, ref, METHOD_STATIC);
  // 找到 methodToCall 后直接调用即可
  GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
#+END_SRC
**** invoke-direct
#+BEGIN_SRC text
  methodToCall = dvmResolveMethod(curMethod->clazz, ref,METHOD_DIRECT);
  // 与 invokeStatic 一样, 直接调用, 只不过因为它用的参数是METHOD_DIRECT
  // 导致在 clazz->directMethods 查找时不会查找到父类
  GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
#+END_SRC
**** invoke-super
#+BEGIN_SRC text
  // 查找 base method 时, 可以在当前 class 找到, 也可能在父类中找到
  // 但不影响最终的结果, 即 baseMethod->methodIndex
  baseMethod = dvmResolveMethod(curMethod->clazz, ref,METHOD_VIRTUAL);
  if (baseMethod->methodIndex >= curMethod->clazz->super->vtableCount):
     // error
  // 这里需要在 super->vtable 中查找, 是因为有可能 baseMethod 是在当前类
  // 中找到的, 我们需要调用的是父类的版本.
  methodToCall = curMethod->clazz->super->vtable[baseMethod->methodIndex];
  GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
#+END_SRC
**** invoke-virtual
#+BEGIN_SRC text
  baseMethod = dvmResolveMethod(curMethod->clazz, ref,METHOD_VIRTUAL);
  // 这里没有直接使用 baseMethod, 是因为有可能 baseMethod 是从父类中开始
  // 查找的, 我们要用的是子类中的版本
  methodToCall = thisPtr->clazz->vtable[baseMethod->methodIndex];
  GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
#+END_SRC
**** invoke-interface
invoke-interface 与 invoke-virtual 不同:

invoke-interface 时使用的 ref 参数是和 interface 相关的, 无法通过调用
dvmResolveMethod 直接找到 clazz->virtualMethods 中对应的虚函数. 必须通过它
先找到接口类, 然后根据接口类在 clazz->iftable 中找到对应于该接口的
methodIndexArray, 然后才能从 clazz->vtable 中找到真正的 virtual
methods. 

#+BEGIN_SRC text
  methodToCall = dvmFindInterfaceMethodInCache(thisClass, ref,curMethod,methodClassDex);
    dvmInterpFindInterfaceMethod(thisClass, methodIdx,method,methodClassDex)
      // 从接口类中找到 absMethod, 这个 absMethod 并不能执行, 直接的可执行的 method
      // 在 thisClass 的 virtualMethods 中
      // 这里的 method->clazz 指的是接口类本身
      absMethod = dvmResolveInterfaceMethod(method->clazz, methodIdx);
        Method* dvmFindInterfaceMethodHier(iface,methodName,proto)
      for (i = 0; i < thisClass->iftableCount; i++):
        if (thisClass->iftable[i].clazz == absMethod->clazz):
          break;
      // iftable[i] 此时代表相应的接口类
      vtableIndex =
        thisClass->iftable[i].methodIndexArray[absMethod->methodIndex];
      methodToCall = thisClass->vtable[vtableIndex];    
  GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);  
#+END_SRC
**** invoke-virtual-quick 与 invoke-super-quick
odex 对 dex 优化时, 会将原来的 invoke-virtual 或 invoke-super 替换为相
应的 quick 版本, 相应的指令参数也会变: 由原来的 ref 直接变为 vtable
index, 这样可以节省一个 dvmResolveMethod 的过程. 

但是, invoke-direct, invoke-static 和 invoke-interface 并没有相应的
quick 版本. 因为这是不可能的...

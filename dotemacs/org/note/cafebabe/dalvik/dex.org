#+TITLE: Dex
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* Dex
** dex 文件结构

http://www.retrodev.com/android/dexformat.html
http://stackoverflow.com/questions/7750448/dex-file-in-android
http://source.android.com/devices/tech/dalvik/dex-format.html
http://blog.csdn.net/hlchou/article/details/6303566
http://www.2cto.com/Article/201308/236054.html

dex 文件主要由一个 dex header, 多个表(ids, defs)和数据 (data) 部分组成.
构成一个复杂的索引关系, 这些表和数据的位置大约是:

1. dex header
2. dex string ids
3. dex type ids
4. dex field ids
5. dex method ids                 o
6. dex class defs
7. data
8. dex map list

*** dex header
dex header 中主要下面提到的各个 ids, defs 的 size 和 offset, 以便能找
到这些 table, 例如:
#+BEGIN_SRC c
  struct header_item {
      struct dex_magic {
          /* dex.. */
      };
      uint checksum;
      char signature[20];
      uint file_size;
      uint header_size;
      uint endian_tag;
      uint link_size;
      uint link_off;
      uint map_off;               /* map list offset */
      uint string_ids_size;
      uint string_ids_off;
      uint type_ids_size;
      uint type_ids_off;
      uint proto_ids_size;
      uint proto_ids_off;
      uint field_ids_size;
      uint field_ids_off;
      uint method_ids_size;
      uint mehtod_ids_off;
      uint class_defs_size;
      uint class_defs_off;
      uint data_size;
      uint data_off;              /* data_off 可能主要用来检查 */
  };

#+END_SRC

*** dex string ids
#+BEGIN_SRC c
  struct string_id_list {
      struct string_id_item {
          uint string_data_off;
      } [string_ids_size];
  };

#+END_SRC

通过这个 string_data_off, 可以在 data 部分找到这个 string 对应的
string_item 结构.

*** dex type ids

#+BEGIN_SRC c
  struct type_id_list {
      struct type_id_item {
          uint descriptor_idx;    /* => string_id_item */
      } [type_ids_size];
  };

#+END_SRC

*** dex proto ids
#+BEGIN_SRC c
  struct proto_id_list {
      struct proto_id_item {
          uint shorty_idx;            /* => string_id_item */
          uint reture_type_idx;       /* => type_id_item */
          unit parameters_off;
      } [proto_ids_size];
  };
#+END_SRC


**** prarameters_off
parameters_off 表示该函数的参数情况, 指向 data 部分的一个
type_item_list 结构

#+BEGIN_SRC c
  struct type_item_list {
      uint size;                  /* 参数的个数 */
      struct type_item [size];
  };
  struct type_item {
      ushort type_idx;            /* 指向 string ids */
  };
#+END_SRC

*** dex field ids
#+BEGIN_SRC c
  struct field_id_list {
      struct field_id_item {
          uint class_idx;             /* => type_id_item */
          uint type_idx;              /* => type_id_item */
          uint name_idx;              /* => string_id_item */
      } [field_ids_size];
  };
#+END_SRC

*** dex method ids
#+BEGIN_SRC c
  struct method_id_list {
      struct method_id_item {
          ushort class_idx;           /* => type_id_item */
          ushort proto_idx;           /* => proto_id_item */
          uint name_idx;              /* => string_id_item */
      } [method_ids_size];
  };

#+END_SRC

*** dex class defs
class defs 是这些表中是复杂的一个表.

#+BEGIN_SRC c
  struct class_def_item_list {
      struct class_def_item {
          uint class_idx;             /* => type_id_item */
          enum ACCESS_FLAGS;
          uint superclass_idx;        /* => type_id_item */
          uint interface_off;
          uint source_file_idx;       /* => string_id_item */
          uint annotation_off;
          uint class_data_off;
          uint static_value_off;
      } [class_defs_size];
  };

#+END_SRC

与 string_id_item 中的 string_data_off 及 proto_id_item 中的
parameters_off 类似, class_def_item 中包含四项 off 也存在到 data 部分,


**** interface_off
   #+BEGIN_SRC c
     struct type_item_list {
         uint size;
         struct type_item[size];
     };

     struct type_item {
         ushort type_index;          /* => type_id_item */
     };
   #+END_SRC

**** static_value_off

**** class_data_off
class_data_off 是 class_def_item 中最复杂的.

#+BEGIN_SRC c
  struct class_data_item {
      uleb128 static_fields_size;
      uleb128 instance_fields_size;
      uleb128 direct_methods_size;
      uleb128 virtual_methods_size;

      struct encoded_field_list {
          struct encoded_field {
              /* field_idx_diff 与前面提到的 xxx_idx 不同:
                 actual_idx[i]= sum_{0}^{i}(field_idx_diff[x]d(x))
               ,,*/
              uleb128 field_idx_diff; /* => field_id_item */
          } [static_fields_size];
      } static_fields;

      struct encoded_field_list {
          struct encoded_field {
              uleb128 field_idx_diff; /* => field_id_item */
              uleb128 access_flags;
          } [instance_fields_size];
      } instance_fields;

      struct encoded_methods_list {
          struct encoded_method {
              uleb128 method_idx_diff; /* => method_id_item */
              uleb128 access_flags;
              uleb128 code_off;
          } [direct_methods_size];
      } direct_methods;

      struct encoded_methods_list {
          struct encoded_method {
              uleb128 method_idx_diff; /* => method_id_item */
              uleb128 access_flags;
              uleb128 code_off;
          } [virtual_methods_size];
      } virtual_methods;
  };
#+END_SRC

***** code off
encoded_method 中包含一个 code_off 的指针, 指向真正的 code_item

#+BEGIN_SRC c
  struct code_item {
      ushort register_size;       /* 使用多少个 register, 包括参数, 局域
                                   ,* 变量等 */
      ushort ins_size;            /* 参数用到的 register 个数 */
      ushort outs_size;           /* 调用其他函数需要用到的 register 个
                                   ,* 数 */
      ushort tries_size;
      uint debug_info_off;
      uint insns_size;            /* instruction size, 以 16 bits 为单位 */
      ushort insns[insns_size];   /*  真正的 byte code*/
  };
#+END_SRC
如果 tries_size 不为 0, 则 insns 后还会有另两部分和 exception 相关的内
容:
1. try_item_list
2. encoded_catch_handler_list

这两个 list 对应着 exception table.

其中 tries_item 为:
#+BEGIN_SRC c
  struct try_item {
      // catcher 对应的 start_addr
      uint start_addr;
      // catcher 对应的 end_addr 为 start_addr + insn_count
      ushort insn_count;
      // catcher 的位置. 以上三个值都是当前 method 中的相对地址
      ushort handler_off;
  }
#+END_SRC

根据 handler_off 可以找到 encoded_catch_handler, encoded_catch_handler
结构比较啰嗦, 但基本信息为:
#+BEGIN_SRC c
  struct encoded_type_addr_pair {
      // catcher 要 catch 的异常的类型
      uleb128 type_idx;
      // catcher 的代码, 也是相对地址
      uleb128 addr;
  };
#+END_SRC

*** dex map list
#+BEGIN_SRC c
  struct map_list_type {
      uint size;
      struct map_item_list {
          struct map_item {
              enum type;
              ushort unused;
              uint size;
              uint offset;
          } [size];
      };
  };
#+END_SRC

`This is a list of the entire contents of a file, in order. It contains
some redundancy with respect to the header_item but is intended to be
an easy form to use to iterate over an entire file.`

map_list 中保存着许多不同类型的 entry 对应的 offset, 与 header_item有些重复,
例如以下类型的 entry 在 header_item 中也是存在的

- TYPE_TYPE_ID_ITEM
- TYPE_PROTO_ID_ITEM
- TYPE_FIELD_ID_ITEM
- ...

但它也可以包含以下类型:

- TYPE_CLASS_DATA_ITEM
- TYPE_CODE_ITEM
- TYPE_STRING_DATA_ITEM
- ...

这些数据在 header_item 是不存在的, 以 CLASS_DATA_ITEM 为例, 如果不使用
中 map_list, 必须通过 header_item -> class_def_item -> class_data_item
这条路径才能找到. 有了 map_list, 代码可以用一种更简单一致的方法来遍历
整个 dex 文件.
** odex 文件结构
odex 文件对 dex 做了如下的修改:
1. 文件开头加入一个 odex header
2. dex 文件本身会被修改, 例如 xxx => xxx_quick
3. 在文件末尾加入两个数据结构: classLookup 与 registerMapPool
*** classLookup
*** registerMap
register map 主要用来帮助 dvm 知道当前各个寄存器中哪些保存着 java 对象.
以便 GC 时这些会被做为 GC Root.
** class 文件结构
** DexFile 与 DvmDex
dalvik 在扫描 class path 时, 会负责将所有的 odex 文件 parse 一遍. parse
的过程基本是:

1. 通过 mmap 将 odex 映射到内存 A
2. 生成 DexFile 结构, 将其成员设置为到 A 各个区域的指针

#+BEGIN_SRC text
    pDexFile->pStringIds = (const DexStringId*) (A + pHeader->stringIdsOff);
    pDexFile->pTypeIds = (const DexTypeId*) (A + pHeader->typeIdsOff);
    pDexFile->pFieldIds = (const DexFieldId*) (A + pHeader->fieldIdsOff);
    pDexFile->pMethodIds = (const DexMethodId*) (A + pHeader->methodIdsOff);
    pDexFile->pProtoIds = (const DexProtoId*) (A + pHeader->protoIdsOff);
    pDexFile->pClassDefs = (const DexClassDef*) (A + pHeader->classDefsOff);
    pDexFile->pLinkData = (const DexLink*) (A + pHeader->linkOff);
#+END_SRC

3. 生成 DvmDex 结构

   这个结构实际就是 procmem 时显示的 "dalvik-aux-structure".
   这是一个辅助的数据结构: 因为 DexFile 基本是直接映射了 odex 文件, 里
   面的内容都是一些 "ID", 但实际执行时程序需要的通常不是 "ID", 而是真
   正的内容, 这时 DvmDex 相当于一个将 "ID" 映射为真正内容的一个 cache.

   以 dvmResolveClass 为例:

   #+BEGIN_SRC text
     dvmResolveClass
       resClass = dvmDexGetResolvedClass(pDvmDex, classIdx);
         return pDvmDex->pResClasses[classIdx];
       if (resClass != NULL):
         return resClass;
   #+END_SRC
** dex 与 ClassLoader
ClassLoader 并不是一定要在 native 实现的, 有些 ClassLoader 是完全用
Java 写的. 但 dalvik 的 ClassLoader 因为底层都依赖于 dex, 所以都是通过
native 层的 DexFile (代表 dex), RawDexFile (代表 odex), DvmDex (代表
auxiliary cache) 实现的.

Java 层和 ClassLoader 相关的类主要有:

1. VMClassLoader
2. ClassLoader
3. BootClassLoader
4. BaseDexClassLoader
5. PathClassLoader


#+BEGIN_EXAMPLE

                              -+-------------+
                               | ClassLoader |
                              -+-----+-------+
                                     |
                                     |
                       -+------------+-----------------+
                        |                              |
                        |                              |
                 -+-----+-----------+          -+------+-------------+
                  | BootClassLoader |           | BaseDexClassLoader |
                 -+-----+-----------+          -+------+-------------+
                        |                              |
              comp      |                       comp   |
             -+---------+-----+                -+------+---+
              | VMClassLoader |                 | DexFile  |
             -+---------+-----+                -+------+---+
                        |                              |
                        |                              |
                    native                         native


#+END_EXAMPLE


*** 双亲委派 loadClass
ClassLoader 这个基类主要作用是实现双亲委派

#+BEGIN_SRC java
  protected Class<?> loadClass(String className) {
      Class<?> clazz = findLoadedClass(className);
  
      if (clazz == null) {
          try {
              clazz = parent.loadClass(className, false);
          } catch (ClassNotFoundException e) {
              // Don't want to see this.
          }
  
          if (clazz == null) {
              clazz = findClass(className);
          }
      }
      return clazz;
  }
#+END_SRC

ClassLoader 通过 parent 指针可以形成一棵树, BootClassLoader 是树根.

在 dalvik 底层代码中并没有 BootClassLoader 这个东西: dalvik 通过把
clazz->classLoader 置为 NULL 表示该 class 是由 BootClassLoader 加载的.

#+BEGIN_SRC text
/* defining class loader, or NULL for the "bootstrap" system loader */
Object*         classLoader;
#+END_SRC

简单起见, 我们假设 BaseDexClassLoader 的 parent 都是
BootClassLoader, 所以 PathClassLoader 的 loadClass 会先调用
BootClassLoader 的 loadClass:

#+BEGIN_SRC text
  BootClassLoader.loadClass
    BootClassLoader.findClass
      VMClassLoader.loadClass(name, false);
        // native, 其中 null 表示 ClassLoader 为 null, 以
        // 便从 bootstrap class 中查找
        clazz = dvmFindClassByName(nameObj, NULL, resolve);
          dvmFindClassNoInit
            dvmFindSystemClassNoInit
              findClassNoInit(descriptor, null);
#+END_SRC

若 BootClassLoader 没有找到 class, 则使用 BaseDexClassLoader 有加载

#+BEGIN_SRC text
  BaseDexClassLoader.findClass(String name)
    Class c = pathList.findClass(name, suppressedExceptions);
      Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);
        DexFile.defineClassNative(name, loader, cookie);
          // native
          clazz = dvmDefineClass(pDvmDex, descriptor, loader);
            findClassNoInit(descriptor, loader);
#+END_SRC

无论是 VMClassLoader 或是 DexFile, 最终都通过 native 的
findClassNoInit 进行 dex 的加载

**** ClassLoader 的具体工作过程
和类加载相关的入口主要有:
1. findClassNoInit
2. dvmResolveClass
3. java 层的 classForName

***** findClassNoInit
findClassNoInit 最底层的加载类的方法, 它需要指定一个字符串来表示要加载
的类, 以及一个 ClassLoader.

后面提到的 dvmResolveClass 实际上就是把 ref 转换为字符串, 并且根据
referrer 找到调用者的 ClassLoader 后直接调用 findClassNoInit. 而
classForName 因为本身就使用字符串表示要加载的类, 所以它只需要找到调用
者的 ClassLoader 后就可以直接调用 findClassNoInit

#+BEGIN_SRC text
  dvmFindClassNoInit(className, referrer->classLoader);
    // 此时 loader 不为空, 它对应的是 app 的 BaseDexClassLoader,
    // 所以会调用 findClassFromLoaderNoInit
    if (loader != NULL):
      return findClassFromLoaderNoInit(descriptor, loader);
        // ClassLoader 开始工作
        // 调用 ClassLoader.java 的 loadClass 函数
        const Method* loadClass =
          loader->clazz->vtable[gDvm.voffJavaLangClassLoader_loadClass];
        dvmCallMethod(self, loadClass, loader, &result, nameObj);
          // 双亲委派导致 ClassLoader.loadClass 被调用
          // BootClassLoader 导致 dvmFindClassNoInit 再次被调用, 但是
          // loader 参数为 null
          ClassLoader.loadClass
            BootClassLoader.loadClass
              dvmFindClassNoInit(className, null);
                return dvmFindSystemClassNoInit(descriptor);
            // 若 BootClassLoader.loadClass 失败, 说明这个类是 BaseDexClassLoader
            // 定义的, 双亲委派会调用 BaseDexClassLoader.findClass
            BaseDexClassLoader.findClass
              pathList.findClass(name);
                dvmFindClassNoInit(className, loader);
    else:
      dvmFindSystemClassNoInit(descriptor);
  
#+END_SRC
***** dvmResolveClass 是 byte code 中加载 class 的入口 (因为它使用 ref 指示 class
而且不是 class 名)

#+BEGIN_SRC text
  HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
    clazz = dvmResolveClass(curMethod->clazz, ref, false);
      dvmResolveClass(referrer, ref, init)
        // referrer->classLoader 调用该代码的对象使用的 BaseDexClassLoader
        // jvm spec 规定了若 A 由 cl 加载, 则 A->B 时也要由 cl 负责加载 B
        dvmFindClassNoInit(className, referrer->classLoader);
#+END_SRC
***** classForName
classForName 即 Class.forName(str, classLoader), 若不指定 classLoader,
根据 jvm 规范, 当前方法所属的 class 的 classLoader 负责加载这个类. 即
像 dvmResolveClass 中展示的那样: curMethod->clazz->classLoader.

这里有个问题: 若 Class.forName 在 java 层不指定 classLoader, 而要求
jni 层像 dvmResolveClass 那样自己获得 curMethod->clazz->classLoader 是否可
行? 不可行, 因为:

若 classForName 对应的 native 函数 Dalvik_java_lang_Class_classForName
方法调用 curMethod, curMethod代表是当前 jni 方法, 而它的 clazz 是
Class 类, 最终会使用BootClassLoader 来加载, 这不是我们想要的.

因此, java 层调用 classForName 时, 需要提交获得
curMethod->clazz->classLoader, 并做为参数传给 findClassNoInit. 

而 java 层获得当前的 classLoader 是使用 native
VMStack.getCallingClassLoader

#+BEGIN_SRC text
  VMStack.getCallingClassLoader
    static void Dalvik_dalvik_system_VMStack_getCallingClassLoader
      ClassObject* clazz = dvmGetCaller2Class(dvmThreadSelf()->interpSave.curFrame);
        // dvmGetCaller2Class:  Get the caller's caller's class.  Pass in the current fp.
        // 所谓的 caller's caller's class, 是这么回事:
        // 第一个 caller 是指 调用 VMStack 的 getCallingClassLoader 这个方法的方法, 即
        // Class.forName 方法, 显然不是我们想要的. 
        // caller's caller 是调用 Class.forName 的那个方法, 是我们想要的.
  
        // 当前的 frame 对应的是 getCallingClassLoader 这个 jni 方法,
        // prevFrame 对应 Class.forName 方法
        void* caller = SAVEAREA_FROM_FP(curFrame)->prevFrame;
        callerCaller = dvmGetCallerFP(caller);
          void* caller = SAVEAREA_FROM_FP(curFrame)->prevFrame;
          if (dvmIsBreakFrame((u4*)caller)):
            caller = SAVEAREA_FROM_FP(caller)->prevFrame;
          return caller;                  
        return SAVEAREA_FROM_FP(callerCaller)->method->clazz;
  
#+END_SRC
*** 总结

对于 dvmResolveClass 和 classForName 都需要提交根据
curMethod->clazz->classLoader 获得`定义当前 method 的 class 使用的
classLoader`, 并使用这个 classLoader 调用 dvmFindClassNoInit, 这是 jvm
规范要求的. 

dvmFindClassNoInit load class 时, 要 classLoader 不为空, 则使用
classLoader 来加载, 否则使用 dvmFindSystemClassNoInit 从 bootstrap
classpath 中加载 (即从 `BootClassLoader` 中加载)


通过 ClassLoader 加载时, 双亲委派会优先使用 BootClassLoader 来加载,
BootClassLoader 最终会通过 dvmFindSystemClassNoInit 来加载.

若 BootClassLoader 没有加载成功, 则 BaseDexClassLoader 的 findClass 会
负责通过 dvmDefineClass(pDvmDex, descriptor, loader) 在 app 自己的 dex
中加载类. 

但不管怎么加载, 最终 dex 都是通过 findClassNoInit 加载进来的. 



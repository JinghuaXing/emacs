* C/C++
#+CATEGORY:C++
** static变量不要写在头文件中
   通常static变量在头文件中是错误的, 除非多个编译单元真的想各自使用独立的该变量
** void参数与空参数
   引用网址：http://david.tribble.com/text/cdiffs.htm#C99-func-vararg

   “
   Empty parameter lists

   C distinguishes between a function declared with an empty parameter list and
   a function declared with a parameter list consisting of only void. The former
   is an unprototoped function taking an unspecified number of arguments, while
   the latter is a prototyped function taking no arguments.

    // C code

#+BEGIN_EXAMPLE
    extern int  foo();          // Unspecified parameters
    extern int  bar(void);      // No parameters

    void baz()
    {
        foo(0);         // Valid C, invalid C++
        foo(1, 2);      // Valid C, invalid C++

        bar();          // Okay in both C and C++
        bar(1);         // Error in both C and C++
    }
#+END_EXAMPLE
    C++, on the other hand, makes no distinction between the two declarations
    and considers them both to mean a function taking no arguments.

    // C++ code

#+BEGIN_EXAMPLE
    extern int  xyz();
    extern int  xyz(void);  // Same as 'xyz()' in C++,
                            // Different and invalid in C
    For code that is intended to be compiled as either C or C++, the best solution to this problem is to always declare functions taking no parameters with an explicit void prototype. For example:

    // Compiles as both C and C++
    int bosho(void)
    {
        ...
    }
#+END_EXAMPLE
    Empty function prototypes are a deprecated feature in C99 (as they were in C89).

    即 在c中,void f()表示参数个数未指定,而不是表示无参数,表示无参数要使用void f(void)
    在c++中,void f()和void f(void)是一样的.

    即 尽量使用void f(void) 而不要使用void f()

    --
    发信人: sunway (sunway), 信区: CPP
    标  题: Re: 关于函数参数个数的问题
    发信站: 北邮人论坛 (Wed Oct 14 13:01:02 2009), 站内

    gcc确实能编译过去...神奇
    一般情况下不会错误,gcc默认使用cdecl调用约定,调用者会负责清理栈上的参数,但如果使
    用了stdcall,被调用的f不知道有参数要清理,而调用者又认为f会清理参数...然后就有问题
    了,比如:

#+BEGIN_EXAMPLE
    void  __attribute__((stdcall)) f (int a,int b) {
        f (1,2);
    }

    int main()
    {
        f(1,2);
	return 0;
    }
#+END_EXAMPLE

    【 在 SuperBrother (xiaohui) 的大作中提到: 】
    : 标  题: 关于函数参数个数的问题
    : 发信站: 北邮人论坛 (Wed Oct 14 11:29:31 2009), 站内
    :
    : void f() {}
    : void g(int a) {}
    :
    : int main()
    : {
    :     f(1);
    :     //g(1, 1);  编译不过，提示参数个数过多
    :     return 0;
    : }
    :
    : 用的是GCC 4.2.4
    : 想问问为啥f(1)能过，而g(1, 1)不能？
    : 另外，假设f()不用参数就能完成相应功能，调用f(1)会引起运行时错误吗？
    : --
    :
    ※ 修改:・sunway 于 Oct 14 13:02:34 修改本文・[FROM: 2001:da8:215:1800:211:11ff:
    : ※ 来源:・北邮人论坛 http://forum.byr.edu.cn・[FROM: 2001:da8:215:5200:0:5efe:
** switch与跳转表
#+BEGIN_EXAMPLE
int
main (int argc, char * argv[]) {
    int a=0;
    switch (a) {
    case 1:
	printf ("%d\n",a);
	break;
    case 2:
	printf ("%d\n",a);
	break;
    case 3:
	printf ("%d\n",a);
	break;
    case 11:
	printf ("%d\n",a);
	break;
    case 100:
	printf ("%d\n",a);
	break;
    case 13:
	printf ("%d\n",a);
	break;
    case 4:
	printf ("%d\n",a);
	break;
    case 5:
	printf ("%d\n",a);
	break;
    case 6:
	printf ("%d\n",a);
	break;
    case 7:
	printf ("%d\n",a);
	break;
    case 8:
	printf ("%d\n",a);
	break;

    default:
	printf ("%d\n",a);
	break;
    }
    return 0;
}
#+END_EXAMPLE
当case分支较少时,和if..else一样,通过一系列cmp,je..跳转.
当case分支较多时,会根据情况生成一个跳转表,如:
#+BEGIN_EXAMPLE
        movl    -24(%ebp), %edx
        movl    .L14(,%edx,4), %eax
        jmp     *%eax
        .section        .rodata
        .align 4
        .align 4
.L14:
        .long   .L2
        .long   .L3
        .long   .L4
        .long   .L5
        .long   .L6
        .long   .L7
        .long   .L8
        .long   .L9
        .long   .L10
        .long   .L2
#+END_EXAMPLE
.L14就是跳转表的入口, %eax是分支在表中的偏移,如case为100,则其偏移量为100*4(因为每个表项为4字节)
这时存在一个问题是:如果case值范围过大,比如一共100个case,但有一个case的值为1000,则表中有900个项需要用default分支的地址去填充,浪费空间.
所以gcc在这种情况下又会转而使用原始的cmp,je..跳转.

** volatile keyword in C
#+BEGIN_EXAMPLE
   int main(int args, char **argv)  {
       char x, y, z;
       int i;
       int a[16];

       for(i=0; i<=16; i++) {
           a[i] = 0;
           printf("%d\n", i);
       }
       return 0;
   }
#+END_EXAMPLE

   1. 程序正常终止,打印出0-16
   2. 在 int i; 前加上 volatile, 死循环

   Volatile is an ANSI C type modifier that is frequently needed in C code that
   is part of signal/interrupt handlers, threaded code, and other kernel code,
   including device drivers. In general, any data that may be undated
   asynchronously should be declared to be volatile. Incidentally, this issue is
   not related to CPU caches except that re-loading of variables into registers
   may involve cache hits or misses.

   Why Use Volatile?  The reason to use volatile is to insure that the compiler
   generates code to re-load a data item each time it is referenced in your
   program. Without volatile, the compiler may generate code that merely re-uses
   the value it already loaded into a register.

   Volatile advises the compiler that the data may be modified in a manner that
   may not be determinable by the compiler. This could be, for example, when a
   pointer is mapped to a device's hardware registers. The device may
   independently change the values unbeknownst to the compiler.


   With gcc the -O2 option is normally required to see the effect of not using
   volatile. Without -O2 or greater optimization, the compiler is likely to
   re-load registers each time a variable is referenced, anyway. Don't blame the
   optimizer if a program gets incorrect results because the program does not
   use volatile where required.

   For example, if two threads share a variable, sum, and one or both threads
   modify it, then the other thread may use a stale value in a register instead
   of going back to memory to get the new value. Instead, each time the thread
   references sum, it must be re-loaded. The way to insure this occurs in ANSI C
   is to declare sum to be volatile.

   Example: The use of volatile can be required to get correct answers. For
   example the program wrong will give incorrect results when it is compiled -O2
   and without volatile. This slightly obtuse program is designed to stop after
   100 ticks of an interval timer that ticks at 100Hz and print the value of the
   variable total. The tick count is incremented in the signal handler. When the
   count gets to 100, the program should terminate. If the tick count does not
   get to 100 within 10 seconds then an alarm goes off and the program
   terminates.

   By compiling the program as: gcc -O2 -DVOLATILE=volatile wrong.c -o wrong_v
   you will see, (unless your program is preempted for quite a while), that the
   count gets to 100 and the program terminates as designed. With the program
   compiled as gcc -O2 wrong.c -o wrong_nv you will see, that the count becomes
   greater than 100 as shown when the handler prints it, but, the while loop
   does not terminate.

   Incidentally, attempts to determine what is happening may thwart your
   efforts. For example, a function call, such as to printf(), or the use of a
   breakpoint, in the loop, will likely spill and re-load the registers.


   http://en.allexperts.com/q/C-1587/volatile.htm
   http://www.netrino.com/node/80

** 栈对齐 stack align
#+BEGIN_EXAMPLE
  int
  main (int argc, char * argv[]) {
     int a=9;
     double b=0;
     char * c=&b;
     printf ("%d\n",*(int *)(c+8));
     return 0;
  }
#+END_EXAMPLE
  c+8后才是a的地址,而不是c+4

  gcc保证,对于8 bytes的类型如double,在栈上是8字节对齐的

  On the Pentium and subsequent x86 processors, there is a substantial
  performance penalty if double-precision variables are not stored 8-byte
  aligned; a factor of two or more is not unusual. Unfortunately, the stack (the
  place that local variables and subroutine arguments live) is not guaranteed by
  the Intel ABI to be 8-byte aligned.

  Recent versions of gcc (as well as most other compilers, we are told, such as
  Intel's, Metrowerks', and Microsoft's) are able to keep the stack 8-byte
  aligned; gcc does this by default (see -mpreferred-stack-boundary in the gcc
  documentation). If you are not certain whether your compiler maintains stack
  alignment by default, it is a good idea to make sure.

  Unfortunately, gcc only preserves the stack alignment―as a result, if the
  stack starts off misaligned, it will always be misaligned, with a disastrous
  effect on performance (in double precision).

  http://www.fftw.org/doc/Stack-alignment-on-x86.html

** gcc -E
** 结构体的 struct A a={.a=1,.b=2};形式的初始化
   gcc扩展:

#+BEGIN_EXAMPLE
   struct A {
     int a;
     int b;
   };

   int
   main(int argc, char *argv[]) {
     struct A a={.b=1,.a=2}; //或者 struct A a={2,1};
     printf ("%d %d\n",a.a,a.b);
     return 0;
   }
#+END_EXAMPLE

** do {} while (0)
   http://c2.com/cgi/wiki?TrivialDoWhileLoop
** char * str[MAXSIZE]
   当打算将strlen是n的字符串存入str时，要分配n+1个char的空间，因为结尾的'\0'不包括在strlen里
** scanf
*** %n
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%d%n",&a,&b)
    #>./a.out
    1234
    a=1234 b=4
#+END_EXAMPLE
*** %[]

*** %*
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%*d%n",&a);
    #>./a.out
    1234
    a=4
#+END_EXAMPLE
*** 空白字符的处理
    空白字符包括 空格,tab,\n
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%d",&a);
    scanf("%d",&b);
    #>./a.out
    1234 123
    a=1234,b=123
#+END_EXAMPLE
    实际上,第一个scanf执行后,输入流里还有一个\n,但是,下一句scanf用%d做参数时,会忽略输入流开头的空白字符.
    大多数%..会忽略开头的空白字符,但以下几个除外:
    %c,%[]
    所以:
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%d",&a);
    scanf("%c",&b);
    #>./a.out
    1234
    a=1234,b=134513674
#+END_EXAMPLE
    b没有要求输入值,而是直接用的流中剩余的\n,对于%c,%[]这种情况,需要手工用%s忽略开头的空白字符,如:
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%d",&a);
    scanf("%*[ \t\n]%c",&b);
#+END_EXAMPLE

*** 回车的作用
    回车用来表示将输入提交到输入流中,但回车本身也会被正常放在输入流中,所以
    scanf("%d\n",&a) 也是可以被匹配的
*** scanf类型不匹配时死循环?
#+BEGIN_EXAMPLE
    int a;
    label:
    scanf("%d",&a);
    goto label;
#+END_EXAMPLE
    若输入不为整数,如'a',则后面的scanf会被跳过,死循环
    原因:
    scanf类型不匹配时,scanf失败,不匹配的数据仍然留在输入流中,必须用%*..丢弃这些错误的数据.
#+BEGIN_EXAMPLE
    int a;
    label:
    scanf("%d",&a);
    scanf("%*s");
    goto label;
#+END_EXAMPLE

** scanf中的%s与%[]
scanf ("%s,%d",a,&b);
然后输入 abc,2,打印a的值是 abc,2 ,不是abc,就是说%s会贪婪的吞掉它后面所有的输入,
除非你输入空格让它停止

s

Matches  a sequence of non-white-space characters; the next pointer must be
a pointer to character array that is long enough to hold the input sequence
and  the  terminating  null character ('\0'), which is added automatically.
The input string stops at white  space  or  at  the  maximum  field  width,
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ \t\n]+
whichever occurs first.


如果你确实喜欢用abc,2这种形式输入,可以试试这个:
scanf("%[^,]%d",a,&b);
比较爽

我觉得%s可能就是%[^ \t\n]吧

** c中的声明与定义
   在1.c和2.c两个文件中,

以下情形时编译正确:
#+BEGIN_EXAMPLE
   |----------------+----------------|
   | 1.c            | 2.c            |
   |----------------+----------------|
   | int a          | int a          |
   | int a          | char a         |
   | int a          | extern int a   |
   | int a          | extern char a  |
   | int a=2        | char a         |
   | int a=2        | int a          |
   | static int a=2 | static int a=1 |
   |----------------+----------------|
#+END_EXAMPLE

以下情形时出错:
#+BEGIN_EXAMPLE
   |---------+----------|
   | 1.c     | 2.c      |
   |---------+----------|
   | int a=2 | int a=3  |
   | int a=2 | char a=3 |
   | int a=2 | int a=2  |
   |---------+----------|
#+END_EXAMPLE
结论:
   没有赋值的定义如 int a 和 声明 extern int a 一样,可以声明多次,类型也可以不同(虽然这是个错误)
   赋值的定义只能定义一次
   static的定义和声明不干扰
即:没赋值的可以随便写,赋值的只能写一次.extern关键字没有用.
** DONE compile time assert						:ATTACH:
   CLOSED: [2008-11-03 一 16:13]
   - State "DONE"       [2008-11-03 一 16:13]
   :PROPERTIES:
   :Attachments: compile-time-assertions_1.pdf
   :ID:       7xl4i9z0ife0@sunway-lab.bupt.edu.cn
   :END:
   #define ASSERT_STATIC(e) char UXXX[(e)-1]

** DONE C Preprocessor -- the whole story
   CLOSED: [2008-11-03 一 16:15]
   - State "DONE"       [2008-11-03 一 16:15]
   http://developer.apple.com/documentation/DeveloperTools/gcc-4.0.1/cpp/
   http://en.wikipedia.org/wiki/C_preprocessor
   http://blog.chinaunix.net/u1/41845/showart_446562.html

** c++容器当pop元素时元素如果被自动析构
   Test t;
   vector<Test> v;
   v.push_back(t);
   v.pop_back();
   v pop_back时,容器中相应的元素(t的拷贝)被自动析构.
   但
   Test * t=new Test;
   v.push_back(t);
   v.pop_back()时,t指向的元素却并不会被析构.
   同样,若vector中元素为其它内置类型也,也不可能被自动析构

   vector的源码中,
   pop_back() {
   __M_content;
   destroy(..);
   }
   而destroy(p)只是简单的调用 p->~T()

   为了容器的一致,C++规定,内置类型的析构也能编译通过,但这些析构实际上什么也不做,
   即当T为int时,p->~int()也能编译通过,指针也属于内置类型,所以容器中为指针时,也能
   编译通过,但析构时实际上什么也不做.

   从上面vector的代码中也可以看到,vector pop_back时并不释放内存,而list与此不同:
   list的pop_back大致为:
   destroy();
   deallocate();
   ..
   其中deallocate负责释放内存

   上面提到的destroy,deallocate,还有allocate,construct都是容器的allocator的功能,
   可以自己重写一个allocator,实现不同的allocate,deallocate,construct,destroy行为,然后把
   新的allocator做为容器的模板参数

** c++引入引用的最根本原因
   c++引入引用,是因为容器的存在.

   对比C语言中经典的容器:数组. 数组可以保存各种类型,包括内置类型,自定义struct等,
   如array[0]=structA,则后面array[0].value1=1时,即是修改structA,数组的[]是C内置运
   算符,不存在array[0]取得的是structA的拷贝的问题

   但在c++中,容器类的[],at,get...都是函数,如vector<struct> v; v[0]=structA;
   v[0].value=1;若operator[]直接返回struct类型,而不是引用或指针,则v[0].value=1修
   改的实际上是structA的拷贝.所以C++的容器类的getter,为了与c语义上的一致,都是返回
   引用.如果没有引用,C++容器只能设计成必须存储指针类型

   另外,用c写的glib中容器,如garray,getter都是使用宏来完成的,宏可以认为是
   return-by-name, 和引用的效果类似.如 #define g_array_index(a,t,i) (((t*) (void
   *) (a)->data) [(i)]), a是array,t是容器中成员类型,i是偏移量

   综上:容器类的getter方法都是函数调用,为了避免return-by-value,使用了 return-by-name

** operator->()								:ATTACH:
   :PROPERTIES:
   :Attachments: 1.cpp
   :ID:       shn19b504ie0@sunway-lab.bupt.edu.cn
   :END:
   operator->()用来使某个类像指针,如iteraotr

** [23.11] How can I set up my class so it won't be inherited from?	:ATTACH:
   :PROPERTIES:
   :Attachments: virtual.cpp
   :ID:       4to2d6y03ge0@sunway-lab.bupt.edu.cn
   :END:
   This is known as making the class "final" or "a leaf." There are three ways
   to do it: an easy technical approach, an even easier non-technical approach,
   and a slightly trickier technical approach.

   The (easy) technical approach is to make the class's constructors private and
   to use the Named Constructor Idiom to create the objects. No one can create
   objects of a derived class since the base class's constructor will be
   inaccessible. The "named constructors" themselves could return by pointer if
   you want your objects allocated by new or they could return by value if you
   want the objects created on the stack.

   The (even easier) non-technical approach is to put a big fat ugly comment
   next to the class definition. The comment could say, for example, // We'll
   fire you if you inherit from this class or even just /*final*/ class Whatever
   {...};. Some programmers balk at this because it is enforced by people rather
   than by technology, but don't knock it on face value: it is quite effective
   in practice.

   A slightly trickier technical approach is to exploit virtual
   inheritance. Since the most derived class's ctor needs to directly call the
   virtual base class's ctor, the following guarantees that no concrete class
   can inherit from class Fred:

#+BEGIN_EXAMPLE
   class Fred;

   class FredBase {
   protected:
     FredBase() { }
   };

   class Fred : private virtual FredBase {
   public:
   ...
   };
#+END_EXAMPLE

   Class Fred can access FredBase's ctor, since Fred is deprived from FredBase,
   but no class derived from Fred can access FredBase's ctor (note 1),and therefore no
   one can create a concrete class derived from Fred.

   note 1:
   'no class derived from Fred can access FredBase's ctor' need 3 constrains be considered:
   1. FredBase() must be
      case1: protected and Fred derives from Fred or
      case2: FredBase() is private , Fred derived from FredBase and is a friend of Fred
   2. Fred must private inherits from FredBase on case 1 or protected inherits from FredBase on case 2
   3. virtual inherits is a must for Fred, because:

      When a base class is inherited virtualy, it is up to the *most derived*
      class to initialize it.

      in our case, if class F deprived from Fred, it's F's duty to initialize Fred, which is impossible since
      Fred's ctor is not accessable.

      about virtual inheritance, check attached virtual.cpp

#+BEGIN_EXAMPLE
      ~@sunway-lab> ./a.out
      ctor for FredBase called
      ctor for Fred called
      ctor for Fred2 called
#+END_EXAMPLE

** never throw exceptions in dtor
[17.3] How can I handle a destructor that fails?

Write a message to a log-file. Or call Aunt Tilda. But do not throw an exception!
Here's why (buckle your seat-belts):

The C++ rule is that you must never throw an exception from a destructor that is
being called during the "stack unwinding" process of another exception. For
example, if someone says throw Foo(), the stack will be unwound so all the stack
frames between the throw Foo() and the } catch (Foo e) { will get popped. This
is called stack unwinding.

During stack unwinding, all the local objects in all those stack frames are
destructed. If one of those destructors throws an exception (say it throws a Bar
object), the C++ runtime system is in a no-win situation: should it ignore the
Bar and end up in the } catch (Foo e) { where it was originally headed? Should
it ignore the Foo and look for a } catch (Bar e) { handler? There is no good
answer ― either choice loses information.

So the C++ language guarantees that it will call terminate() at this point, and
terminate() kills the process. Bang you're dead.

The easy way to prevent this is never throw an exception from a destructor. But
if you really want to be clever, you can say never throw an exception from a
destructor while processing another exception. But in this second case, you're
in a difficult situation: the destructor itself needs code to handle both
throwing an exception and doing "something else", and the caller has no
guarantees as to what might happen when the destructor detects an error (it
might throw an exception, it might do "something else"). So the whole solution
is harder to write. So the easy thing to do is always do "something else". That
is, never throw an exception from a destructor.

Of course the word never should be "in quotes" since there is always some
situation somewhere where the rule won't hold. But certainly at least 99% of the
time this is a good rule of thumb.

** what is type-safe and strong type
   http://hi.baidu.com/chenfalei/blog/item/f33ac0133500ac21dd540186.html
   没有绝对的类型安全与强类型语言。类型安全都是相对的。
   比如C/C++基本的类型检查保证了一部分的类型安全，但它的 union/指针/强制转换/数组 却破坏了类型安全。
   绝对的类型安全是指：一旦程序通过编译，即不再存在除逻辑错误外的其他错误。
** why pop_back returns void instead of the removed object?
   - The SGI's docs contain the reasoning - it's from queue's documentation
     but it also applies for deque:
     "One might wonder why pop() returns void, instead of value_type. That
     is, why must one use front() and pop() to examine and remove the
     element at the front of the queue, instead of combining the two in a
     single member function? In fact, there is a good reason for this
     design. If pop() returned the front element, it would have to return
     by value rather than by reference: return by reference would create a
     dangling pointer. Return by value, however, is inefficient: it
     involves at least one redundant copy constructor call. Since it is
     impossible for pop() to return a value in such a way as to be both
     efficient and correct, it is more sensible for it to return no value
     at all and to require clients to use front() to inspect the value at
     the front of the queue."
   - exception safety
     假设 pop_back()定义为：
#+BEGIN_EXAMPLE
     T topValue=vector1.pop();

     T pop_back() {
         T temp=vec[top];
	 --top;
	 return temp; // what about if the copy assignment or copy constructor of temp->topValue fails?
     }
#+END_EXAMPLE

** 数组蜕化为指针及数组引用做为函数参数

#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

void f (int (& a) [10]) {
    cout<<a[0]<<endl;
    cout<<sizeof(a)<<endl;
}
void g (int a []) {
    f (a);
}
int
main(int argc, char *argv[]) {
    int a[10]={9};
    g (a);
    return 0;
}
#+END_EXAMPLE
编译错误

#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

void f (int (& a) [10]) {
    cout<<a[0]<<endl;
    cout<<sizeof(a)<<endl;
}
int
main(int argc, char *argv[]) {
    int a[10]={9};
    f (a);
    return 0;
}
#+END_EXAMPLE
编译正确

可见,数组作为参数会蜕化为指针,但数组引用做为参数不会
** c++ template 链接问题					   :template:模板:
   or 为什么c++ template的声明和定义通常在同一个文件,而不把定义单独编译成目标文件
   因为c++ template is instantiated at compile time.
   http://en.wikibooks.org/wiki/C%2B%2B_Programming/Template
** The Standard Librarian: Containers of Incomplete Types
   http://www.ddj.com/database/184403814
** 临时对象的const引用						   :引用:const:常量:
   string foo() {return string("abc");}
   const string & a=foo();
   是合法的,这是C++对大量存在的 foo (const & T) 类型的函数的折衷
   string & a=foo()是非法的
   类似的,对于foo("abc")的调用,void foo(const string & s)是合法的,void foo(string & s)是非法的,除非
   string a("abc");string & b=a; foo(b);

   虽然c++要求返回的临时对象的引用必须是const,但在gcc里,复杂对象通常都是用
   named-return-value,所以返回的临时对象实际上必然在调用者的栈中,所以

#+BEGIN_EXAMPLE
   main (int argc, char * argv[]) {
    const T & t=fun ();
    T & tt=const_cast<T &>(t);
    tt.a=19;
    printf ("%d\n",t.a);
    return 0;
    }
#+END_EXAMPLE
    并没有问题
    main的栈:
    临时对象a
    引用t的指针,指向临时对象a

** bitwise copy
   http://blogs.msdn.com/slippman/archive/2004/01/20/60655.aspx
   http://www.cppblog.com/jerysun0818/archive/2006/05/05/6632.html

   In practice, a good compiler can generate bitwise copies for most class objects since they
   have bitwise copy semantics….
   That is, a copy constructor is not automatically generated by the compiler for each class that
   does not explicitly define one.

   Default constructors and copy constructors…are generated (by the compiler) where needed.
   Needed in this instance means when the class does not exhibit bitwise copy semantics
   When are bitwise copy semantics not exhibited by a class? There are four instances:

   1. When the class contains a member object of a class for which a copy constructor exists
      (either explicitly declared by the class designer, as in the case of the previous String
      class, or synthesized by the compiler, as in the case of class Word)
   2. When the class is derived from a base class for which a copy constructor exists (again,
      either explicitly declared or synthesized)
   3. When the class declares one or more virtual functions
   4. When the class is derived from an inheritance chain in which one or more base classes are virtual


   如果一个类的成员中有指针成员，如果它又有bitwise copy semantics(如无虚函数，成
   员类没有定义copy constructor..),默认会使用bitwise copy,但是对指针做shadow
   copy在对象析构时指针成员可能会被多次delete,所以对于这个类要自定义copy
   constructor使其丧失bitwise copy semantics

** 可怜的bool
发信人: Oversense (空), 信区: CPlusPlus
标  题: 可怜的bool
发信站: BBS 水木清华站 (Mon Oct 21 17:53:11 2002), 转信

可怜的bool

作者: Jim Hyslop 和 Herb Sutter
翻译：oversense <17:33 2002-10-21>
出处: http://www.cuj.com/experts/2011/hyslop.htm?topic=experts

嘿嘿...今天的活比较爽！前几天写了点破程序，今天改改就搞定了。
哎，真困！喝点咖啡，靠在我的小椅子上，看看我的代码...

神奇，这是啥？
void f()
{
 TextHandler t;
 t.sendText("Hello, world", true);
// ...
}

后面那个true是什么东东？翻翻定义:
class TextHandler
{
public:
 void sendText( const std::string & msg,
                bool sendNewLine );
//...
};

喝点coffee，我想起来了，true表示sendText函数自动加上一个回车换行，我怎
么忘了？难道是我笨？我陷入迷茫的沉思...

砰！！！的一声巨响，我一慌张，嘴里的咖啡差点喷出来，还好我嘴紧。一定是Guru合上
了她的什么大头书。我转向她，挤出一点微笑。她手里拿着一本不到一百页的小册子。
神奇，这么小的书弄得这么响，她是怎么弄得？

显然，她什么都知道了。

"我的宝贝！如果你这么快就忘了参数的含义，那么当其他程序员第一次看你的代
码的时候，他怎么明白你要表达的意思呢？"

"嗯，是啊" 我咕噜道 "但是在IDE里面，他只要把鼠标移到函数上，他就可以看
到参数说明了啊！"

"有些IDE如此，并非全部，甚至不是大多数！我说过很多次，源代码最主要的用途
是用来交流，对意图的交流。我手中这本古老的，令人尊敬的卷册阐述了交流的艺术。
在这儿，它写道，'使用明确，详细，具体的语言'[1]，你代码中的bool与此无缘，
他不能传递任何有用的信息给读者。 "

"不哈，一旦他知道这个bool是什么意思，就很容易记住了哈！"我中气不足的说。

Guru用她美丽而坚定的蓝眼睛盯着我，我心里扑通扑通跳起来。

"你多久以前写的这段代码？"Guru很温柔的说道--那种我喜欢的温柔。
"嗯，好，嗯，那如何改正呢？"我巧妙的回避她的问题。
"你不能另外想一种方式去表达你的意图吗？"她也不直接回答我，我们就好像在
煎鸡蛋。

"我可以不要第二个参数，让用户自己加 '\n' 好了。"我边说边写:
{
 t.sendText("Hello, world\n");
}
"如果传递给sendText是一个变量呢？" Guru问。
"那就这样好了"
{
 t.sendText( variable );
 t.sendText( "\n" );
}
我抬头看到Guru脸色不善，赶紧说道:
"那就这样，我提供两个函数"
void sendText( const std::string & );
void sendTextWithNewLine( const std::string & );

"没有其他的办法了吗？"Guru思考的时候，微微皱眉。
哎，看来我今天不要想轻松溜走了，我一阵猛想......什么也没想出来，我投降
了，"就这样吧！"

"关于你的问题，你还要认识一点" Guru写道:
void displayText( const std::string &,
                  bool applyItalics,
                  bool applyBold );
void f(){
    displayText( "This is bold but not italic",true, false );
}
"如果一个程序员要用斜体显示文字，但是弄错了参数顺序，那么这些文字就要用
粗体显示了，而且显然编译器无法发现这个错误。"

"如果Bob拿到了这段代码，改变了参数的顺序，一种叫做'Permute And Baffle'
的技术[2]。会怎样？"

"显然，问题多多的displayText不能得到 '明确，详细，具体' 的参数。"

"现在来看你的问题，你的第一个方案，因为displayText需要其他参数而没法用
。你的第二个方案，
可以工作，但是如果displayText需要很多信息，比如颜色，字体等，你是不是要
提供如此多的函数呢？"

"所以，我们可以用enumerated."
"Enumerations?"我奇怪的说。

"是的，Enumerations在这儿能得到很好的应用，看，"
class TextHandler
{
public:
 enum NewLineDisposition { sendNewLine, noNewLine };
 void sendText( const std::string &, NewLineDisposition );
};
void f()
{
 TextHandler t;
 t.sendText( "Hello, ", TextHandler::noNewLine );
 t.sendText( "world", TextHandler::sendNewLine );
}
"这种写法很好，这段代码现在self-documenting了，不需要注释，意图和结果都
很清楚。看得人不需要去查找函数的定义了。"
"而且，这种写法有很好的扩展性，如果你需要只加一个回车，你只需要在enume
ration中加上prependNewLine就可以了，现有的代码无需任何改变。"

"不要抛弃你第一个方案，宝贝。在有的情况下，他是最优的。"Guru转过身，重
新打开那本书，优雅而轻快的走开，消失在拐角处。

注解:
[1] William Strunk Jr. and E.B. White. The Elements of Style (MacMilla
n Publishing Co. Ltd,
1979).
[2] From Roedy Green's "How To Write Unmaintainable Code,"
<http://mindprod.com/unmaindesign.html>. (Primarily aimed at Java prog
rammers, it still has
lots of relevance for C++ programmers.)

** operator new							    :new:delete:
   http://www.scs.cs.nyu.edu/~dm/c++-new.html
#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

class Test {
    int val;
public:
    Test (int v):val (v) {cout<<val<<endl;}
    void * operator new (size_t size,int count) {cout<<__LINE__<<endl;return malloc (size);}
    void operator delete( void * p,size_t size ) {cout<<size<<endl;free (p);}
    //new和delete只负责分配释放内存，不负责ctor和dtor调用
};

int
main(int argc, char ** argv) {
    Test * t=new (10) Test (20);
    Test tt; //局部变量不使用operator new和operator delete
    return 0;
}
#+END_EXAMPLE
** prefrer ++i to i++
   For builtin types, it really doesn't matter. But in C++, you can write
   and operator++ for your own class. And then it might matter, becaure
   postfix ++ has to create a copy of the object so that the old value can
   be returned. If you don't need the return value, that copy is
   unnecessary. If the compiler doesn't do named return value
   optimization, that copy might even need to be copied again, and all
   that just to throw the result away. The postfix operator++ for an own
   class might look something like this:

#+BEGIN_EXAMPLE
   MyClass MyClass::operator++(int)
   {
   MyClass retval(*this); // copy the object
   // do whatever is needed to "increment" the object
   reutrn retval; // return the copy by value
   }
#+END_EXAMPLE

   while prefix ++ might look like:

#+BEGIN_EXAMPLE
   MyClass& MyClass::operator++()
   {
   // do whatever is needed to "increment" the object
   return *this; // return a refernce to the object
   }
#+END_EXAMPLE

   Therefore, it's considered a good habit to always use prefix ++ if the
   return value is not needed.

** Decorator pattern
http://en.wikipedia.org/wiki/Decorator_pattern

#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

class B {
public:
    virtual void fun () {cout<<"C"<<endl;}
};

class Dec:public B {
    B * pbase;
public:
    Dec (B * b):pbase(b) {}
    virtual void fun () {cout<<"Dec"<<endl;pbase->fun ();}
};

int
main(int argc, char ** argv) {
    B * b=new Dec(new Dec (new B));
    b->fun ();

    return 0;
}
#+END_EXAMPLE

** 一个Printable类
#+BEGIN_EXAMPLE
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
class Printable {
    virtual string to_str () const=0;
public:
    friend ostream & operator<<(ostream &,const Printable &);
};

ostream & operator<<(ostream & o,const Printable & p) {
    return o<<p.to_str ()<<endl;
}

class Test:public Printable {
    int a;
    int b;
private:
    string to_str () const {
	stringstream ss;
	ss<<a<<" ";
	ss<<b<<endl;
	return ss.str ();
    }
public:
    Test (int a,int b):a (a),b (b) {}
};
int
main(int argc, char ** argv) {
    Test t (1,2);
    cout<<t;
    return 0;
}
#+END_EXAMPLE
** 类型转换
   假设需要一个X到Y的转换：

   - Y内定义 Y(const X &) ()构造函数
   - X内定义 operator Y() {return Y;}函数

   自定义的类型转换也可以被隐式调用，
   例如 Y实现了 friend ostream & operator <<(ostream &,const Y &) 使Y可以通过 cout<<Y的
   形式调用，如果在Y或X中定义了X到Y的转换，则cout<<X时，X会被隐式的转换为Y并调用operator<<(cout,Y)
   另外，自定义的类型转换也是static_cast能否成功的根据之一
** cast
   - 'reinterpret_cast' 只能用于指针或引用'reinterpret_cast' casts a pointer to
     any other type of pointer. It also allows casting from pointer to an
     integer type and vice versa. This operator can cast pointers between
     non-related classed. The operation results is a simple binary copy of the
     value from a pointer to the other. The content pointed does not pass any
     kind of check nor transformation between types. In the case that the copy
     is performed from a pointer to an integer, the interpretation of its
     content is system dependent and therefore any implementation is non
     portable. A pointer casted to an integer enough large to fully contain it
     can be casted back to a valid pointer.

     Code:

#+BEGIN_EXAMPLE
     class A {};
     class B {};

     A * a = new A;
     B * b = reinterpret_cast<B *>(a);
#+END_EXAMPLE

     'reinterpret_cast' treats all pointers exactly as traditional type-casting operators do.

   - 'dynamic_cast' 只能用于指针或引用

     'dynamic_cast' is exclusively used with pointers and references to
     objects. It allows any type-casting that can be implicitly performed as
     well as the inverse one when used with polymorphic classes, however, unlike
     static_cast, dynamic_cast checks, in this last case, if the operation is
     valid. That is to say, it checks if the casting is going to return a valid
     complete object of the requested type. Checking is performed during
     run-time execution. If the pointer being casted is not a pointer to a valid
     complete object of the requested type, the value returned is a 'NULL'
     pointer.

     dynamic_cast使用了RTTI来确定能否转换成功,而只有支持多态的类(有虚函数)才在
     vtbl中有相应的RTTI信息,所以:
#+BEGIN_EXAMPLE
     class Base {

     };
     class Derived:public Base {

     };

     Base * b=new Derived();
     dynamic_cast<Derived *>(b)不会成功,因为没有vtbl,即没有RTTI信息

#+END_EXAMPLE

     Code:
#+BEGIN_EXAMPLE
     class Base { virtual dummy() {} };
     class Derived : public Base {};

     Base* b1 = new Derived;
     Base* b2 = new Base;

     Derived* d1 = dynamic_cast<Derived *>(b1);          // succeeds
     Derived* d2 = dynamic_cast<Derived *>(b2);          // fails: returns 'NULL'
#+END_EXAMPLE

     If the type-casting is performed to a reference type and this casting is not possible an exception of type 'bad_cast' is thrown:

     Code:

#+BEGIN_EXAMPLE
     class Base { virtual dummy() {} };
     class Derived : public Base { };

     Base* b1 = new Derived;
     Base* b2 = new Base;

     Derived d1 = dynamic_cast<Derived &*>(b1);          // succeeds
     Derived d2 = dynamic_cast<Derived &*>(b2);          // fails: exception thrown
#+END_EXAMPLE

   - 'static_cast'

     'static_cast' allows to perform any casting that can be implicitly
     performed as well as also the inverse cast (even if this is not allowed
     implicitly). Applied to pointers to classes, that is to say that it allows
     to cast a pointer of a derived class to its base class (this is a valid
     conversion that can be implicitly performed) and can also perform the
     inverse: cast a base class to its derivated class. In this last case the
     base class that is being casted is not checked to determine wether this is
     a complete class of the destination type or not. Code:
#+BEGIN_EXAMPLE
     class Base {}; class
     Derived : public Base {};

     Base *a    = new Base;
     Derived *b = static_cast<Derived *>(a);
     'static_cast', aside from manipulating pointers to classes, can also be used to perform conversions explicitly defined in classes, as well as to perform standard conversions between fundamental types:
     Code:
     double d = 3.14159265;
     int    i = static_cast<int>(d);
#+END_EXAMPLE


   - 'const_cast'

     This type of casting manipulates the const attribute of the passed object, either to be set or removed:

     Code:
#+BEGIN_EXAMPLE
     class C {};
     const C *a = new C;
     C *b = const_cast<C *>(a);

#+END_EXAMPLE
     Neither of the other three new cast operators can modify the constness of an object.
     Notes:
     It is undefined behaviour if the pointer is used to write on an constant object (an object declared as 'const').
     The 'const_cast' operator can also change the 'volatile' qualifier on a type.

     总结:
     reinterpret_cast是不懂c++语法的,也不会使用rtti信息,这就决定了它不能解析c++的类结构,如多重继承,虚拟继承这些复杂的结构.
     指针的reinterpret_cast的过程中,值是不会变的,改变的只是对这个值的处理方式(当作c的指针还是当作d的指针)

     static_cast是懂c++的语法的,它能了解编译时的ctti信息,能够在处理多重继承,虚拟继承等复杂结构.
     B
     C1:virtual B
     C2:virtual B
     D:C1,C2
     D * d=new D()能成功static_cast到B*,C1*或C2*,因为static_cast了解继承的树

     static_cast是编译时的行为,它不能正确处理的情况是:
     B
     C1:virtual B
     C2:virtual B
     D:C1,C2
     void foo(B * b) {
     D * d=static_cast<D *>(b);
     }
     如果:
     B * b=new B();
     foo(b); 程序会出错,因为static_cast不知道foo的参数b到底是不是真的D*,编译时的static_cast只能假设它是了

     这时就需要dynamic_cast了,dynamic_cast的static_cast的功能基本相同,但它使用了
     rtti信息,可以正确处理从基类到派生类的转换,由于使用了rtti,只有有虚函数或虚基类的类才能使用.

     另外,c++中的(B *)d式的转换相当于编译器按
     const_cast,static_cast,dynamic_cast,reinterpret_cast的顺序挨个测试能否转换成
     功,reinterpret_cast是最后的选择

** RTTI与CTTI
   RTTI是在多态类的vtbl中存储的类型信息,非多态类没有RTTI信息
   dynamic_cast和typeid需要使用RTTI信息
   typeid可以得到类型信息,如typeid(1).name(),或typeid(myclass).name()
   但并非所有的typeid都是使用了RTTI,因为:
   - typeid是运算符,而不是函数,所以typeid的值可能在编译时就能确定
   - 对于非多态类型,如内置数据类型,或自定义的非多态的类,typeid使用的是CTTI,即编译时就确定类型
     而对于多态类型,typeid通过查询多态类的vtbl中的RTTI信息确定类型
** 重载 <<
#+BEGIN_EXAMPLE
#include <iostream>
using std::cout;
using std::endl;

struct foo {
    short a;
    char  b;
    char  c;
    int   d;
};

int
main(int argc, char ** argv) {
    int c=('A' << 16) + ('B' << 8) + 'C';
    foo f = {1234, 'x', 'y', ('D' << 24 )+('A' << 16) + ('B' << 8) + 'C'};
    cout<<&f.b<<endl;
    return 0;
}


#include <iostream>
#include <iostream>
using namespace std;


class foo {
    short a;
    char  b;
    char  c;
    int   d;
public:
    foo (short a,char b,char c,int d):a (a),b (b),c (c),d (d) {}
    friend ostream& operator<<(ostream& output,const foo & f);

};

ostream & operator<<(ostream& output,const foo & f) {
    output<<f.a<<endl;
}
int
main(int argc, char ** argv) {
    int c=('A' << 16) + ('B' << 8) + 'C';
    foo f (1234, 'x', 'y', ('D' << 24 )+('A' << 16) + ('B' << 8) + 'C');
    cout<<f;
    return 0;
}
#+END_EXAMPLE

** mask
#+BEGIN_EXAMPLE
   string mask (const string & ip, const string & mask) {
   //{{{
   struct sockaddr_in servaddr;
   bzero (&servaddr, sizeof (servaddr));
   servaddr.sin_family = AF_INET;
   inet_pton (AF_INET, ip.c_str (), &servaddr.sin_addr);
   in_addr_t ip_digit=servaddr.sin_addr.s_addr;
   inet_pton (AF_INET, mask.c_str (), &servaddr.sin_addr);
   in_addr_t mask_digit=servaddr.sin_addr.s_addr;
   in_addr_t tmp=ip_digit&mask_digit;
   servaddr.sin_addr.s_addr=tmp;
   char * ret=(char *)malloc (20);
   inet_ntop (AF_INET,&servaddr.sin_addr,ret,20);
   string rets=string (ret);
   free (ret);
   return rets;
   }
   //}}}
#+END_EXAMPLE
** copy构造函数与vtl

#+BEGIN_EXAMPLE
#include <iostream>
#include <string>
using namespace std;
class A {
    int a;
public:
    A () {}
    A (const A & a) {memcpy (this,&a,sizeof(a));}
    virtual void fun () {cout<<"A"<<endl;}

};

class B:public A {
public:
    B (){}
    void fun () {cout<<"B"<<endl;}

};
int
main(int argc, char ** argv) {
    B b;
    A a=b;
    A * ptra=&a;
    ptra->fun ();
    return 0;
}
#+END_EXAMPLE

** 类对象的几种声明方法：
使用构造函数和copy构造函数（但copy构造函数的调用通常被编译器优化掉）
- A a=A();
- A a=A(1);
没使用copy构造函数
- A a;
- A a(1);
使用了copy构造函数但被优化掉和没使用copy构造函数的区别是：当copy构造函数为private时....

指针形式
- A * a=new A()
- A * a=new A(1)

注意：
- A a() 并不等同于 A a=A(),虽然它和A a(1)很像，实际上 A a()是一个函数声明......a is a function returning A......

** virtual函数,vptr例子

#+BEGIN_EXAMPLE
#include <iostream>
#include <string>
using namespace std;
class A {

public:
    virtual void fun () {cout<<"A"<<endl;}
};
class B {

public:
    virtual void fun () {cout<<"B"<<endl;}
};

int
main(int argc, char ** argv) {
    A * a=new A;
    B * b=new B;
    void * ptra=reinterpret_cast<void *>(a);
    void * ptrb=reinterpret_cast<void *>(b);
    memcpy (ptrb,ptra,1);
    b->fun ();
    return 0;
}
#+END_EXAMPLE

** 成员函数的调用

#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

class AA {
    static int foo;
public:
    void fun ();
};
class AAA:public AA {
public:
};
void AA::fun() {
    cout<<"AA"<<endl;
}

int
main(int argc, char ** argv) {
    AA a;
    AAA aa;
    void (* f)(AA *)=reinterpret_cast<void (*)(AA *)>(0x080486d8);
    f (&a);
    return 0;
}
#+END_EXAMPLE

** virtual析构函数
#+BEGIN_EXAMPLE
<iostream>
using std::cout;
using std::endl;

class Base{
public:
virtual ~Base(){cout<<"~B"<<endl;}
};

class Derived:public Base{
public:
virtual ~Derived(){cout<<"~D"<<endl;}
};

void main (){
Base *b=new Derived();
delete b;
}
#+END_EXAMPLE
//执行结果
#+BEGIN_EXAMPLE
~D
~B
#+END_EXAMPLE
//解释
沿着程序执行流程，从main函数进入
首先，执行语句Base *b=new Derived();
结果是在堆中创建类Derived的一个对象，并且让类型为Base *的指针b指向这个对象；
其次，执行语句delete b;
运行结果是释放b指向对象的内存空间。按照C++的delete操作符的语义，编译器会指针b“对应类型”的对象的析构函数调用（你或许认为是Base::~Base()），但是由于类Base的析构函数声明为虚函数，因此实现方式具有多态特征（具体实现采用的技术请查看相关书籍，例如经典的Inside The C++ Object Model），因此运行时调用的析构函数是Derived::~Derived()。
第三，子类的析构函数Derived::~Derived()内部会调用父类的析构函数，因此执行结果如上！

基类中的虚析构函数使得派生类在使用多态性时也能被正确的析构。
** DONE c++ string literal的类型是什么?
   CLOSED: [2008-10-07 二 15:23]
   - State "DONE"       [2008-10-07 二 15:23]
   "abc"的类型为const char [4]

** DONE internal linkage , external linkage & no linkage
   CLOSED: [2008-10-06 一 15:51]
   - State "DONE"       [2008-10-06 一 15:51]
     http://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=41
 3.5 Program and linkage

 3 A name having namespace scope (3.3.5) has internal linkage
 if it is the name of
 - an object, reference, function or function template that
    is explicitly declared static or,
 - an object or reference that is explicitly declared const
 and neither explicitly declared extern nor previously
     declared to have external linkage; or
  - a data member of an anonymous union.

    4 A name having namespace scope has external linkage if it is
    the name of
  - an object or reference, unless it has internal linkage; or
  - a function, unless it has internal linkage; or
  - a named class (clause 9), or an unnamed class defined in
     a typedef declaration in which the class has the
     typedef name for linkage purposes (7.1.3); or
  - a named enumeration (7.2), or an unnamed enumeration defined
     in a typedef declaration in which the
     enumeration has the typedef name for linkage purposes
     (7.1.3); or
  - an enumerator belonging to an enumeration with external
     linkage; or
  - a template, unless it is a function template that has internal
     linkage (clause 14); or
  - a namespace (7.3), unless it is declared within an unnamed
     namespace.


     对不同linkage type的符号，ld需要做不同的处理：
   1. external linkage
      1.c: extern int a;
      2.c: extern int a;
      1.c 2.c被编译成目标文件时，1.o, 2.o中对a的引用地址都为0,ld将1.o, 2.o链接以后才能确定a的实际地址
   2. internal linkage
      1.c: static int a;
      1.c被编译成1.o时，对a的引用地址是a在.data段是的偏移量，1.o被链接后a的实际地址是.data基址+a的偏移量
   3. no linkage
      1.c: main () {int a;a=1;}
      1.o中a=1中对a的引用地址即是a在.text段中的偏移量,即不需要链接

1.c:
#+BEGIN_EXAMPLE
static int a;
static int b;
int c;
int d;
int
main(int argc, char *argv[]) {
    a=a+1;
    b=b+2;
    c=c+3;
    d=d+4;
    int e;
    e=e+5;
    return 0;
}
#+END_EXAMPLE

objdump -d 1.o:

#+BEGIN_EXAMPLE
1.o:     file format elf32-i386

Disassembly of section .text:

00000000 <main>:
   0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
   4:	83 e4 f0             	and    $0xfffffff0,%esp
   7:	ff 71 fc             	pushl  -0x4(%ecx)
   a:	55                   	push   %ebp
   b:	89 e5                	mov    %esp,%ebp
   d:	51                   	push   %ecx
   e:	83 ec 10             	sub    $0x10,%esp
  11:	a1 08 00 00 00       	mov    0x8,%eax                 对a的引用地址是a在.data段的offset 0x8,internal linkage
  16:	83 c0 01             	add    $0x1,%eax
  19:	a3 08 00 00 00       	mov    %eax,0x8
  1e:	a1 0c 00 00 00       	mov    0xc,%eax                 对b的引用地址是b在.data段的offset 0xc,internal linkage
  23:	83 c0 02             	add    $0x2,%eax
  26:	a3 0c 00 00 00       	mov    %eax,0xc
  2b:	a1 00 00 00 00       	mov    0x0,%eax                 对c的引用地址是0x0,extern linkage
  30:	83 c0 03             	add    $0x3,%eax
  33:	a3 00 00 00 00       	mov    %eax,0x0
  38:	a1 00 00 00 00       	mov    0x0,%eax                 对d的引用地址是0x0,extern linkage
  3d:	83 c0 04             	add    $0x4,%eax
  40:	a3 00 00 00 00       	mov    %eax,0x0
  45:	83 45 f8 05          	addl   $0x5,-0x8(%ebp)          对e的引用地址是栈上的地址,no linkage
  49:	b8 00 00 00 00       	mov    $0x0,%eax
  4e:	83 c4 10             	add    $0x10,%esp
  51:	59                   	pop    %ecx
  52:	5d                   	pop    %ebp
  53:	8d 61 fc             	lea    -0x4(%ecx),%esp
  56:	c3                   	ret
#+END_EXAMPLE

** 临时对象(右值)可被修改?
#+BEGIN_EXAMPLE
 #include <iostream>
 #include <stdlib.h>
 #include <string.h>
 using namespace std;
 class Test {
    char * p;
    int val;
 public:
    Test (int val) {p=(char *)malloc (10);this->val=val;}
    ~Test () {free (p);p=0;cout<<"dtor called for "<<val<<endl;}
 //    Test operator=(const Test & t) {cout<<"calling ="<<endl;memcpy (this->p,t.p,10);cout<<"= done"<<endl;return *this;}
 };

 Test foo (int val) {return Test (val);}

 int
 main (int argc, char * argv[]) {
    Test t (1);
    foo (2)=t;
    std::cout<<"here"<<std::endl;
    return 0;
 }
#+END_EXAMPLE

 foo(2)返回一个Test()临时对象,是一个 右值,但它却是可以调用自己的成员而被修改! 这是C++中类对象做为右值时的特例,对于标准类型如int,C++还是与C兼容的.
 临时对象做为右值却可以通过自己的成员函数被修改,这主要是为了方便以下的应用:
 临时对象也可以调用成员函数,如 getClassA().getVal(),而不用写成 Class A a=getClassA(), a.getVal()

 另外,foo(2)=t时,foo(2)返回的临时对象直到这条语句执行完后才被析构.
 http://www.9php.com/FAQ/cxsjl/c/2007/11/925528897440.html
** DONE 左值与右值
   [[*lval & rval][左值与右值]]
   - State "DONE"       [2008-08-21 四 11:19]
*** 函数返回引用
    foo & fun() 返回到foo的值用,是左值(当然决不能返回临时对象的引用)
    例如:
    - [[*prefrer%20i%20to%20i][prefer ++i to i++]]
    - [[*Decorator%20pattern][decorator pattern]]
*** *(void **)(&func_pointer)=...

#+BEGIN_EXAMPLE
    void *dlsym(void *handle, const char *symbol);
    int main(int argc, char **argv) {
    void *handle;
    double (*cosine)(double);
    char *error;

    handle = dlopen ("libm.so", RTLD_LAZY);
    if (!handle) {
    fprintf (stderr, "%s\n", dlerror());
    exit(1);
    }

    dlerror();
    //note the following line!
    *(void **) (&cosine) = dlsym(handle, "cos");
    //it is equal to cosine=(double (*) (double))dlsym(handle,"cos");, using
    //(void *)cosine=dlsym(..) is wrong, because (void *)cosine returns a rval
    if ((error = dlerror()) != NULL)  {
    fprintf (stderr, "%s\n", error);
    exit(1);
    }

    printf ("%f\n", (*cosine)(2.0));
    dlclose(handle);
    return 0;
    }
#+END_EXAMPLE

** DONE when does cast alter the pointer's address
   CLOSED: [2008-12-15 一 17:35]
   - State "DONE"       [2008-12-15 一 17:35]
   - 多重继承时
#+BEGIN_EXAMPLE
     class B1 {};
     class B2 {};
     class D:public B1,public B2 {};
     D * pd=new D();
     B1 * pb1=pd; //pb1=pd
     B2 * pb2=pd; //pb2!=pd
#+END_EXAMPLE

     图:
#+BEGIN_EXAMPLE
     +-----------------+
     | B1 subclass  -  |<-------pd,pb1 point to here
     +-----------------+
     | B2 subclass     |<-------pb2 point to here
     +-----------------+
     | D subclass      |
     +-----------------+
#+END_EXAMPLE

   - virtual继承时
#+BEGIN_EXAMPLE
     class B {};
     class D:public virtual B {};
     D * pd=new D();
     B * pb=pd;  //即使是单继承,pb也不等于pd
#+END_EXAMPLE
#+BEGIN_EXAMPLE
			 +--pd point to here
     图:		 |
			 |
     +------------+	 |
     |D subclass  |<-----+
     |_vptr of D  |--------->+---------------------+
     +------------+	     |offset to B subclasso|
     |B subclass  |<-----+   +---------------------+
     +------------+	 |   |RTTI and other virtua|
     			 |   |l funcs  	           |
     			 |   +---------+-----------+
	       	       	 |
     			 +--pb point to here,pb equals to pd+_vptr[0]

#+END_EXAMPLE
** c++弱化了data段还是bss段?
   和c一样,在c++里,main()之外的全局变量,函数中的static变量,类定义中的static变量都被自动初始化
   但与c不同的是,如果这些变量是类,会自动调用它们的ctor,看起来是bss被弱化了? 因为这些类不会被
   自动初始化为0
   实际上,是data被弱化了. 这些类被放在bss里,程序执行后,在main()之前,某些函数(如elf中的.init段)会调用
   它们的ctor来初始化这些类
** 除了ctor,在一个类的所有成员函数中调用虚函数都是通过vptr机制		:ATTACH:
   :PROPERTIES:
   :Attachments: 2.cpp
   :ID:       6b44moj04he0@sunway-lab.bupt.edu.cn
   :END:
   因为:
   1. test1的构造函数调用fun2时,test2还没建立起来,test1()首次将vptr指向自己的fun2,但test1()中对fun2的调用不通过vptr
   2. 任何时候,通过test1的其他成员函数如fun1调用fun2时,都是通过vptr,因为本质上函数调用都是通过this指针
      test1 t; t.fun2() 时编译器可以知道t是确定的类,所以不使用vptr.但当程序进入fun1后,编译器已无法确定fun1(this)里的this到底
      是什么类型
   因为成员函数都是通过this指针调用,属于指针调用,所以在成员函数中对虚函数的调用都是通过vptr

** DONE virtual inhereit in c++
   CLOSED: [2008-12-16 二 20:51]
   - State "DONE"       [2008-12-16 二 20:51]
#+BEGIN_EXAMPLE
   class B {int a;};
   class D1:public virtual B {}
   class D2:public virtual B {}
   class E:public D1,public D2 {}
#+END_EXAMPLE
   - memory layout
#+BEGIN_EXAMPLE
    D1:	         +----------------+
    +------+   /-+offset to B,ie,2|
    | vptr |---	 +----------------+
    +------+   	 |RTTI info of D1 |
    | int a|   	 +----------------|----------------------------+
    +------+	 |pointer to other virtual funcs if D1 has any |
       	       	 +---------------------------------------------+


    E:
    +------------+     	+----------	 --+
    | D1 subclass|   /--+ offset to B,ie,3 |
    | vptr     	 |---  	|------------------+-----------+
    +------------+	| RTTI and other virtual funcs |
    | D2 subclass|	+------------------------------+
    | vptr     	 |------ similar to vptr of D1, but offset to B is diff, ie,2
    +------------+
    | E subclass |
    +------------+
    | B subclass |
    | int a    	 |
    +------------+
#+END_EXAMPLE

   - why a offset to base class is needed
     在D1,D2和E中,都需要在vptr里指定一个到B的offset,虽然B存储的位置就在d1,d2,e附近
     如果是通过B的派生类(而不是通过派生类指针)使用B的成员,不需要通过vptr指定的offset,因为对于确定的类型,如E,它的内存布局在编译时就确定了,
     B的成员在E中的位置编译时就已经确定,直接使用即可.
     而如果是通过派生类的指针使用B的成员,必须通过vptr指定的offset,例如:
     D1 * dp=new D1(), B紧接dp
     D1 * dp=new E(),B和dp之间还间隔了一个sizeof(D2)的距离
     D2 * dp2=new E(), B紧接dp2
     所以必须通过D1的vptr中指定的offset才能找到B

   - difference when accessing base class member from pointer to derived class or from a derived class
     (something like access virtual function through pointer or not)
     http://www.phpcompiler.org/articles/virtualinheritance.html
** DONE c++ pointer-to-member variable and functions			:ATTACH:
   CLOSED: [2008-12-17 三 17:07]
   - State "DONE"       [2008-12-17 三 17:07]
   - what on earth a pointer-to-member pointer 'point' to?
     1. 到类的普通成员函数的指针是函数的真实物理地址
     2. 到类的虚成员函数的指针是虚函数在vtbl中的偏移量
     3. 到类的成员的指针是类成员在类中的偏移量
   :PROPERTIES:
   :Attachments: 1.cpp
   :ID:       41b8eg214he0@sunway-lab.bupt.edu.cn
   :END:
** DONE c++ inline function
   CLOSED: [2008-12-23 二 10:23]
   - State "DONE"       [2008-12-23 二 10:23]
#+BEGIN_EXAMPLE
   5.cpp
   #include <stdio.h>
   //typedef void (*fp) ();
   inline void fun () {
      //fp tmp=fun;
      printf ("test\n");
   }
   void f () {
      fun ();
   }

   6.cpp
   //typedef void (*fp) ();
   inline void fun ();
   int
   main(int argc, char *argv[]) {
   //    fp tmp=fun;
   //    (*tmp)();
      fun ();
      return 0;
   }
#+END_EXAMPLE

   - gcc默认不会inline,除非指定-O或-finline
     g++ 5.cpp -c
     nm -a 5.o|grep fun 显示 00000000 W _Z3funv
     g++ 5.cpp -c -O3 或 -finline
     nm -a 5.o|grep fun 无结果
   - 5.cpp中注释的两行(取inline函数的地址)会阻止compile inline
     取消注释后,
     g++ 5.cpp -c
     nm -a 5.o|grep fun 显示 00000000 W _Z3funv
   - inline函数和普通函数一样,具有external linkage
     如果inline函数通过取函数地址或不指定优化等手段使编译器不Inline它,则目标
     文件中包含这个函数,如W_Z3funv,这个函数具有external linkage,且这个函数在目标文件中是
     一个[[*weak%20symbol][weak symbol]]
     g++ 5.cpp 6.cpp -O3时,link出错,找不到fun
     g++ 5.cpp 6.cpp 时,编译成功,main()中调用的是5.cpp中的fun
   - 标准规定,每一个translation unit都要有inline函数的定义

     总结:每个translation unit都应该有inline函数的定义,如将inline函数的定义放在头文件中
     若不符合这个标准,也有可能编译通过,如将inline函数的定义放在某一个cpp文件中
     因为inline函数如果没有被inline就和普通函数一样,具有external linkage

** DONE static_cast<Derived *>(virtual base *) is not supported in C++
   CLOSED: [2008-12-29 一 09:18]
   - State "DONE"       [2008-12-29 一 09:18]

#+BEGIN_EXAMPLE
   class A {};
   class B : virtual public A {};
   class C : virtual public A {};
   class D : public B, public C {};
#+END_EXAMPLE

   来看B是什么样子(A是virtual的，所以放在底部)：

#+BEGIN_EXAMPLE
     +-----+
     | B   |
     | vptr|
     +-----+
     | A   |
     +--- -+
#+END_EXAMPLE

     这里我们假设A和B相差4

     再来看D是什么样子(B,C是基类，所以在开头，A是virtual的，所以放在底部)：
#+BEGIN_EXAMPLE
     +------+
     | B    |
     | vptr |
     +--- --+
     | C    |
     | vptr |
     +------+
     | D    |
     +--- --+
     | A    |
     +------+
#+END_EXAMPLE

     这里A和B就相差12了

     所以当compiler看到需要把一个A*转到B*的时候，她并不知道这个offset是4还是12，这个
     取决于你传过来的对象是B还是D。这就需要一些额外的runtime信息来做这件事。

     btw. reinterpret_cast<A*>(B*)是允许的,它假设是第一种情况


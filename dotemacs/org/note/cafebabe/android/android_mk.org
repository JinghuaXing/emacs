#+TITLE: Android.mk
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* Android.mk
** files
*** build/core/main.mk
*** build/core/config.mk
*** build/core/definitions.mk
*** build/core/base_rules.mk
*** build/core/package.mk
*** build/core/prebuilt.mk
*** build/core/multi_prebuilt.mk
*** ....
** LOCAL_MODULE_TAGS
** LOCAL_MODULE_PATH
** LOCAL_MODULE_NAME
** LOCAL_SRC_FILE
** LOCAL_MODULE_CLASS
** LOCAL_PATH:= $(call my-dir)
** include $(CLEAR_VARS)
** include $(BUILD_PREBUILT)
** ...
** ALL_MODULES
使用 ALL_MODULES 变量在 Android 中执行自定义命令, 因为 ALL_MODULES 变
量中的 target 最终都会被生成.

#+BEGIN_SRC makefile
  include $(CLEAR_VARS)
  my_phony_test:
          $(ACP) $(LOCAL_PATH)/files/test.dcf $(TARGET_OUT_DATA)/drm/test_phony.dcf
  ALL_MODULES += my_phony_test
#+END_SRC

But.... 以上代码并不完全工作... 因为 target 的动作里引用了 LOCAL_PATH
这个变量, 这个变量会在后面被修改, 导致 acp 出错. make 在扫描 makefile
里, 会按照 TARGET 信赖的顺序对变量进行多次赋值, 例如:

#+BEGIN_SRC makefile
dep := test.c
test: $(dep)
	$(info $(dep))
dep := test2.c
test2:$(dep)
	$(info $(dep))

#+END_SRC

假设 test.c 存在, 而test2.c不存在, make test 时 输出: 
#+BEGIN_EXAMPLE

~@sunway-x230> make test
test2.c
make: `test' is up to date.

#+END_EXAMPLE

即, 扫描 TARGET,信赖及变量的读取和赋值是按 makefile 里的顺序进行的, 但扫描完
毕真正执行动作时, 对变量的读取是按照最终扫描的结果!

因此, 如果动作里涉及到变量而变量会被后续代码修改时, 需要将变量反映到
TARGET或依赖中, 并在动作中使用 $<,$^及$@ 而不是直接使用变量, 例如:

#+BEGIN_EXAMPLE
  include $(CLEAR_VARS)
  my_phony_test: $(LOCAL_PATH)/files/test.dcf
          $(ACP)  $< $(TARGET_OUT_DATA)/drm/test_phony.dcf
  ALL_MODULES += my_phony_test
#+END_EXAMPLE

实际上, android 的 Android.mk 就是这样处理的, 因为 LOCAL_SRC_FILE,
LOCAL_PATH 等都会被频繁的重新赋值, 所以 base_rules.mk 会将所有变量反映
到 TARGET 或 依赖中.

ps. 关于变量赋值顺序的补充:
#+BEGIN_EXAMPLE
  dep := test.c
  test: test3 $(dep)
          $(info 1 $^)
  dep := test2.c
  test2:$(dep)
  # 这里 dep 是 test2.c, 而不是 test3.c
          $(info 2 $^)
  dep := test3.c
  test3:test3.c test2
          $(info 3 $(dep))
#+END_EXAMPLE
** dump the makefile
#+BEGIN_EXAMPLE
make --print-data-base --dry-run
#+END_EXAMPLE

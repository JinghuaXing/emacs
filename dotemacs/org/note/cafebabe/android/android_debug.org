#+TITLE: Android Debug
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* Android Debug Internals
** hierachyviewer
hierachyviewer 在 host 端通过 socket 与手机端的 ViewServer 通信.
ViewServer 并非开机启动, 而是需要由 host 端的 hierachyviewer 的
startViewServer 通过 "adb shell service call window 1 i32 port" 调用
WMS 的 startViewServer 来启动,

ViewServer 会负责调用 ViewDebug 的相关方法来 DUMP 或 CAPTURE 等
** ddms
ddms 通过 jdwp 控制 java 进程
*** method tracing
*** hprof
- 在代码中生成
  Debug.dumpHprofData()
- 使用信号on-demand生成
- 为了能让MAT识别android的hprof格式,需要用hprof-conv转换一下
*** gc
** adb
adb 通过 host 上的 adb 与手机端的 adbd 通信
*** logcat
adb shell setprop log.tag.mytag verbose
**** events log
- content_query_sample
*** logwrapper
*** am
*** pm
*** dumpsys
*** input
*** procrank
*** procmem
*** getprop
*** dumpstate
*** setprop
*** service
例如 hierachyviewer 启动 ViewServer 就是使用 "service call window 1
i32 port" 命令
** monkey
** uiautomator
** tombstone / debuggerd
tombstone 的生成由两方面配合: 
1. 一个 stand-alone 的基于 local socket 的 server: debuggerd.c
2. bionic 中通过 linker 嵌入到每一个可执行程序的代码: debugger.c

*** debuggerd.c

debuggerd 由 init 启动, 在一个 local socket 上监听, 每一个进程当收到
SIG_ABORT 等信号时, 会因为 debugger.c 的原因向 debuggerd.c 发送通知,
debuggerd.c 负责 dump tombstone 文件, dump 完成后向原进程再次发送同样
的信号, 这时进程才真正退出. 

*** debugger.cpp

debugger.cpp 由 bionic 的 linker 负责嵌入到每一个 elf 文件的 _start 段,
所以每一个进程都会自动执行该代码. 它的作用主要是 catch 住所有会导致退
出的信号, 例如 SIG_ABRT, SIG_SEGV 等 (但不包括 SIG_KILL). 对应的
signal handler 就是向 debuggerd.c 发送消息, 请求 dump tombstone, 同时,
为了收到 debuggerd 再次发送的信号能退出, debugger.c 会把这些信号的
handler 置为 default.

因为 SIG_KILL 无法被 catch, 所以 tombstone 无法处理 java crash, 因为
java crash 是通过 dalvik 向自己发送 SIG_KILL 实现的.

*** 手动生成 tombstone
通过 debuggerd -b <pid> 可以直接生成 pid 对应进程的 tombstone
** watchdog
** anr trace
*** AMS 发送 SIGQUIT (3)
#+BEGIN_SRC java
  AMS:appNotResponding
    // for the pid, or other related pids, send SIG_QUIT (3)
    Process.sendSignal(pid, Process.SIGNAL_QUIT);
#+END_SRC

*** SignalCatcher Thread
每个 java 进程初始时会启动一个 SignalCatcher Thread, 用来接收 SIG_QUIT
#+BEGIN_SRC java
  /* start signal catcher thread that dumps stacks on SIGQUIT */
  if (!gDvm.reduceSignals && !gDvm.noQuitHandler) {
      if (!dvmSignalCatcherStartup())
          return false;
  }
#+END_SRC

SIG_QUIT 的 handler 如下:

#+BEGIN_SRC java
  dvmSuspendAllThreads(SUSPEND_FOR_STACK_DUMP);
  dvmDumpLoaderStats("sig");
  dvmDumpJniStats(&target);
  dvmDumpAllThreadsEx(&target, true);
#+END_SRC

参考: dalvik thread suspend
*** 手动生成 trace
kill -3 <pid>
** UncaughtHandler 打印的 trace
除了 debuggerd/anr trace 外, java 程序因为 UncaughtHandler 退出时也会
打印 trace

#+BEGIN_SRC java
  try {
      // Bring up crash dialog, wait for it to be dismissed
      ActivityManagerNative.getDefault().handleApplicationCrash(
          mApplicationObject, new ApplicationErrorReport.CrashInfo(e));
  } catch (Throwable t2) {
  
  } finally {
      // Try everything to make sure this process goes away.
      Process.killProcess(Process.myPid());
      System.exit(10);
  }
#+END_SRC
可见, 在 killProcess 之前, AMS.handleApplicationCrash 会被调用, 而
handleApplicationCrash 会调用某些 controller 例如 monkey 的相应代码,
在进程被 kill 之前打印出异常的信息. 

** 程序中生成 c++ trace

C++也是支持异常处理的，异常处理库中，已经包含了获取backtrace的接口，
Android也是利用这个接口来打印堆栈信息的。在Android的C++中，已经集成了一
个工具类CallStack，在libutils.so中。使用方法：

#+BEGIN_SRC c++
  #include <utils/CallStack.h>  
  CallStack stack;  
  stack.update();  
  stack.dump();  
#+END_SRC
** 程序中使用 libcorkscrew 生成 c trace

http://blog.csdn.net/freshui/article/details/9456889

实际上 debuggerd 就是用 libcorkscrew 生成的 c trace

#+BEGIN_SRC c
  #define MAX_DEPTH                       31  
  #define MAX_BACKTRACE_LINE_LENGTH   800  
  #define PATH "/system/lib/libcorkscrew.so"  
    
  typedef ssize_t (*unwindFn)(backtrace_frame_t*, size_t, size_t);  
  typedef void (*unwindSymbFn)(const backtrace_frame_t*, size_t, backtrace_symbol_t*);  
  typedef void (*unwindSymbFreeFn)(backtrace_symbol_t*, size_t);  
    
  static void *gHandle = NULL;  
    
  static int getCallStack(void){  
      ssize_t i = 0;  
      ssize_t result = 0;  
      ssize_t count;  
      backtrace_frame_t mStack[MAX_DEPTH];  
      backtrace_symbol_t symbols[MAX_DEPTH];  
    
      unwindFn unwind_backtrace = NULL;  
      unwindSymbFn get_backtrace_symbols = NULL;  
      unwindSymbFreeFn free_backtrace_symbols = NULL;  
    
      // open the so.  
      if(gHandle == NULL) gHandle = dlopen(PATH, RTLD_NOW);  
    
      // get the interface for unwind and symbol analyse  
      if(gHandle != NULL) unwind_backtrace = (unwindFn)dlsym(gHandle, "unwind_backtrace");  
      if(gHandle != NULL) get_backtrace_symbols = (unwindSymbFn)dlsym(gHandle, "get_backtrace_symbols");  
      if(gHandle != NULL) free_backtrace_symbols = (unwindSymbFreeFn)dlsym(gHandle, "free_backtrace_symbols");  
    
      if(!gHandle ||!unwind_backtrace ||!get_backtrace_symbols || !free_backtrace_symbols  ){  
          ALOGE("Error! cannot get unwind info: handle:%p %p %p %p",  
                gHandle, unwind_backtrace, get_backtrace_symbols, free_backtrace_symbols );  
          return result;  
      }  
    
      count= unwind_backtrace(mStack, 1, MAX_DEPTH);  
      get_backtrace_symbols(mStack, count, symbols);  
    
      for (i = 0; i < count; i++) {  
          char line[MAX_BACKTRACE_LINE_LENGTH];  
    
          const char* mapName = symbols[i].map_name ? symbols[i].map_name : "<unknown>";  
          const char* symbolName =symbols[i].demangled_name ? symbols[i].demangled_name : symbols[i].symbol_name;  
          size_t fieldWidth = (MAX_BACKTRACE_LINE_LENGTH - 80) / 2;  
            
          if (symbolName) {  
              uint32_t pc_offset = symbols[i].relative_pc - symbols[i].relative_symbol_addr;  
              if (pc_offset) {  
                  snprintf(line, MAX_BACKTRACE_LINE_LENGTH, "#%02d  pc %08x  %.*s (%.*s+%u)",  
                           i, symbols[i].relative_pc, fieldWidth, mapName,  
                           fieldWidth, symbolName, pc_offset);  
              } else {  
                  snprintf(line, MAX_BACKTRACE_LINE_LENGTH, "#%02d  pc %08x  %.*s (%.*s)",  
                           i, symbols[i].relative_pc, fieldWidth, mapName,  
                           fieldWidth, symbolName);  
              }  
          } else {  
              snprintf(line, MAX_BACKTRACE_LINE_LENGTH, "#%02d  pc %08x  %.*s",  
                       i, symbols[i].relative_pc, fieldWidth, mapName);  
          }  
    
          ALOGD("%s", line);  
      }  
    
      free_backtrace_symbols(symbols, count);  
    
      return result;  
  }  
#+END_SRC

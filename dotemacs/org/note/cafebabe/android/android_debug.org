#+TITLE: Android Debug
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* Android Debug Internals
** hierachyviewer
hierachyviewer 在 host 端通过 socket 与手机端的 ViewServer 通信.
ViewServer 并非开机启动, 而是需要由 host 端的 hierachyviewer 的
startViewServer 通过 "adb shell service call window 1 i32 port" 调用
WMS 的 startViewServer 来启动,

ViewServer 会负责调用 ViewDebug 的相关方法来 DUMP 或 CAPTURE 等
** ddms
ddms 通过 jdwp 控制 java 进程
*** method tracing
*** hprof
- 在代码中生成
  Debug.dumpHprofData()
- 使用信号on-demand生成
- 为了能让MAT识别android的hprof格式,需要用hprof-conv转换一下
*** gc
** adb
adb 通过 host 上的 adb 与手机端的 adbd 通信
*** logcat
adb shell setprop log.tag.mytag verbose
**** events log
- content_query_sample
*** logwrapper
*** am
*** pm
*** dumpsys
*** input
*** procrank
*** procmem
*** getprop
*** dumpstate
*** setprop
*** service
例如 hierachyviewer 启动 ViewServer 就是使用 "service call window 1
i32 port" 命令
** monkey
** uiautomator
** tombstone / debuggerd
tombstone 主要包含以下信息:
1. stack trace
2. 部分内存和寄存器的值

但不包含 coredump 文件 (coredump 是由 kernel 自动生成的, 和 debuggerd
或 tombstone 无关)

tombstone 的生成由两方面配合: 
1. 一个 stand-alone 的基于 local socket 的 server: debuggerd.c
2. bionic 中通过 linker 嵌入到每一个可执行程序的代码: debugger.cpp

*** debuggerd.c

debuggerd 由 init 启动, 在一个 local socket 上监听, 每一个进程当收到
SIG_ABORT 等信号时, 会因为 debugger.c 的原因向 debuggerd.c 发送通知,
debuggerd.c 负责 dump tombstone 文件, dump 完成后向原进程再次发送同样
的信号, 这时进程才真正退出. 

*** debugger.cpp

debugger.cpp 由 bionic 的 linker 负责嵌入到每一个 elf 文件的 _start 段,
所以每一个进程都会自动执行该代码. 它的作用主要是 catch 住所有会导致退
出的信号, 例如 SIG_ABRT, SIG_SEGV 等 (但不包括 SIG_KILL). 对应的
signal handler 就是向 debuggerd.c 发送消息, 请求 dump tombstone, 同时,
为了收到 debuggerd 再次发送的信号能退出, debugger.c 会把这些信号的
handler 置为 default.

因为 SIG_KILL 无法被 catch, 所以 tombstone 无法处理 java crash, 因为
java crash 是通过 dalvik 向自己发送 SIG_KILL 实现的.

*** 手动生成 tombstone
通过 debuggerd -b <pid> 可以直接生成 pid 对应进程的 tombstone
** watchdog
** anr trace
*** AMS 发送 SIGQUIT (3)
#+BEGIN_SRC java
  AMS:appNotResponding
    // for the pid, or other related pids, send SIG_QUIT (3)
    Process.sendSignal(pid, Process.SIGNAL_QUIT);
#+END_SRC

*** SignalCatcher Thread
每个 java 进程初始时会启动一个 SignalCatcher Thread, 用来接收 SIG_QUIT
#+BEGIN_SRC java
  /* start signal catcher thread that dumps stacks on SIGQUIT */
  if (!gDvm.reduceSignals && !gDvm.noQuitHandler) {
      if (!dvmSignalCatcherStartup())
          return false;
  }
#+END_SRC

SIG_QUIT 的 handler 如下:

#+BEGIN_SRC java
  dvmSuspendAllThreads(SUSPEND_FOR_STACK_DUMP);
  dvmDumpLoaderStats("sig");
  dvmDumpJniStats(&target);
  dvmDumpAllThreadsEx(&target, true);
#+END_SRC

参考: dalvik thread suspend
*** 手动生成 trace
kill -3 <pid>
** UncaughtHandler 打印的 trace
除了 debuggerd/anr trace 外, java 程序因为 UncaughtHandler 退出时也会
打印 trace

#+BEGIN_SRC java
  try {
      // Bring up crash dialog, wait for it to be dismissed
      ActivityManagerNative.getDefault().handleApplicationCrash(
          mApplicationObject, new ApplicationErrorReport.CrashInfo(e));
  } catch (Throwable t2) {
  
  } finally {
      // Try everything to make sure this process goes away.
      Process.killProcess(Process.myPid());
      System.exit(10);
  }
#+END_SRC
可见, 在 killProcess 之前, AMS.handleApplicationCrash 会被调用, 而
handleApplicationCrash 会调用某些 controller 例如 monkey 的相应代码,
在进程被 kill 之前打印出异常的信息. 

** 程序中生成 c++ trace

C++也是支持异常处理的，异常处理库中，已经包含了获取backtrace的接口，
Android也是利用这个接口来打印堆栈信息的。在Android的C++中，已经集成了一
个工具类CallStack，在libutils.so中。使用方法：

#+BEGIN_SRC c++
  #include <utils/CallStack.h>  
  CallStack stack;  
  stack.update();  
  stack.dump();  
#+END_SRC
** 程序中使用 libcorkscrew 生成 c trace

http://blog.csdn.net/freshui/article/details/9456889

实际上 debuggerd 就是用 libcorkscrew 生成的 c trace

#+BEGIN_SRC c
  #define MAX_DEPTH                       31  
  #define MAX_BACKTRACE_LINE_LENGTH   800  
  #define PATH "/system/lib/libcorkscrew.so"  
    
  typedef ssize_t (*unwindFn)(backtrace_frame_t*, size_t, size_t);  
  typedef void (*unwindSymbFn)(const backtrace_frame_t*, size_t, backtrace_symbol_t*);  
  typedef void (*unwindSymbFreeFn)(backtrace_symbol_t*, size_t);  
    
  static void *gHandle = NULL;  
    
  static int getCallStack(void){  
      ssize_t i = 0;  
      ssize_t result = 0;  
      ssize_t count;  
      backtrace_frame_t mStack[MAX_DEPTH];  
      backtrace_symbol_t symbols[MAX_DEPTH];  
    
      unwindFn unwind_backtrace = NULL;  
      unwindSymbFn get_backtrace_symbols = NULL;  
      unwindSymbFreeFn free_backtrace_symbols = NULL;  
    
      // open the so.  
      if(gHandle == NULL) gHandle = dlopen(PATH, RTLD_NOW);  
    
      // get the interface for unwind and symbol analyse  
      if(gHandle != NULL) unwind_backtrace = (unwindFn)dlsym(gHandle, "unwind_backtrace");  
      if(gHandle != NULL) get_backtrace_symbols = (unwindSymbFn)dlsym(gHandle, "get_backtrace_symbols");  
      if(gHandle != NULL) free_backtrace_symbols = (unwindSymbFreeFn)dlsym(gHandle, "free_backtrace_symbols");  
    
      if(!gHandle ||!unwind_backtrace ||!get_backtrace_symbols || !free_backtrace_symbols  ){  
          ALOGE("Error! cannot get unwind info: handle:%p %p %p %p",  
                gHandle, unwind_backtrace, get_backtrace_symbols, free_backtrace_symbols );  
          return result;  
      }  
    
      count= unwind_backtrace(mStack, 1, MAX_DEPTH);  
      get_backtrace_symbols(mStack, count, symbols);  
    
      for (i = 0; i < count; i++) {  
          char line[MAX_BACKTRACE_LINE_LENGTH];  
    
          const char* mapName = symbols[i].map_name ? symbols[i].map_name : "<unknown>";  
          const char* symbolName =symbols[i].demangled_name ? symbols[i].demangled_name : symbols[i].symbol_name;  
          size_t fieldWidth = (MAX_BACKTRACE_LINE_LENGTH - 80) / 2;  
            
          if (symbolName) {  
              uint32_t pc_offset = symbols[i].relative_pc - symbols[i].relative_symbol_addr;  
              if (pc_offset) {  
                  snprintf(line, MAX_BACKTRACE_LINE_LENGTH, "#%02d  pc %08x  %.*s (%.*s+%u)",  
                           i, symbols[i].relative_pc, fieldWidth, mapName,  
                           fieldWidth, symbolName, pc_offset);  
              } else {  
                  snprintf(line, MAX_BACKTRACE_LINE_LENGTH, "#%02d  pc %08x  %.*s (%.*s)",  
                           i, symbols[i].relative_pc, fieldWidth, mapName,  
                           fieldWidth, symbolName);  
              }  
          } else {  
              snprintf(line, MAX_BACKTRACE_LINE_LENGTH, "#%02d  pc %08x  %.*s",  
                       i, symbols[i].relative_pc, fieldWidth, mapName);  
          }  
    
          ALOGD("%s", line);  
      }  
    
      free_backtrace_symbols(symbols, count);  
    
      return result;  
  }  
#+END_SRC
** debuggerd
以 abort 和 segment fault 为例, 说明 debuggerd 的工作过程.
*** segment fault
1. 当程序中执行到类似于 *((char*)0) = 'a' 的指令时, 会发生 SIG_SEGV 信号
2. debuggerd.cpp 中的 debuggerd_signal_handler 负责拦截这个信号, 并向
   debuggerd 发送 request, request 中包括以下内容:
   1) 当前线程的 tid, 表示哪个线程发生了异常, 后续 debuggerd 会通过
      ptrace  attach 到这个 tid 上来打印该 tid 相关的信息 (tombstone)
   2) request 的类型, 此处为 DEBUGGER_ACTION_CRASH
   3) abortMessage ()

   值得注意的是这里并不包括 signal 号, 而且 request 中虽然不包括 pid,
   uid 信息, 但 debuggerd 可能通过 socket 的 getsockopt 获得 pid, uid.
3. debuggerd 发送完 request 后, 在 socket 上通过 read 阻塞, 等待
   debuggerd 的反馈.
4. debuggerd 通过 handle_request 以及 read_request 获得 request 信息.
5. debuggerd 通过 ptrace(PTRACE_ATTACH, request.tid, 0, 0) attach 到
   tid 上.  tid 被 attach 后, 还会正常执行 (不会暂停), 但当它调用系统调
   用前会先通知 debuggerd, 或收到信号时也会通知 debuggerd, 而不会再对这
   些信号进行进行处理 (exit, core , 忽略或任何自定义动作), ptrace 本身
   会对 pid 发送一个 SIG_STOP 信号
6. debuggerd 通过 write(fd, "\0", 1) 使 tid 的 signal handler 继续执行
7. tid 收到 debuggerd 的反馈后会调用 signal(n, SIG_DFL). 然后对于
   SIG_ABRT 等信号, 会重新发送一次. 但对于 SIG_SEGV 没有重新发送.
8. debuggerd 通过 wait_for_signal 等待 tid 上报一个信号.
9. debuggerd 会收到第 5 步 ptrace attach 中发送的 SIG_STOP 信号. 通过
   这个信号, debuggerd 可以确保 tid 已经被 attach.
10. debuggerd 通过 ptrace(PTRACE_CONT, request.tid, 0, 0) 使 tid 继续
    执行.
11. 因为之前的 SIG_SEGV 被拦截, 导致 tid 继续执行时会再次发出 SIG_SEGV
12. 第 8 步的 wait_for_signal 收到第二次的 SIG_SEGV 信号, 开始 dump
    tombstone 信息
13. dump 完成后, debuggerd 通过 ptrace(PTRACE_DETACH) 从 tid detach,
    tid 继续运行, debuggerd 部分功能到底结束.
14. tid 继续运行, 会第三次发出 SIG_SEGV, 这个信息会最终导致 coredump
    及进程退出. 

总结:
发生 SIG_SEGV 时, 需要应用程序一共发生三次 SIG_SEGV 才能最终退出. 
1. 第一次, 通知 debuggerd
2. 第二次, 通知 debuggerd 的 wait_for_signal, 进行 tombstone 的 dump
3. 第三次导致应用异常退出
*** abort
abort 与 segment fault 不同, 它不是由于执行了非法指令导致的, 所以它不
会像 segment fault 那样重复的发出 SIG_SEGV 信号. 

abort() 是 libc 中的一个函数, 它的实现大约是这样的:
#+BEGIN_SRC text
  kill(pid, SIG_ABRT);
  signal(SIG_ABRT, SIG_DFL);
  kill(pid, SIG_ABRT);
#+END_SRC
即它会发两次 SIG_ABRT 而且第二次会强制的忽略任何 signal handler.

abort 与 segment fault 不同的地方在于:
1. 第七步中, debugger.cpp 会再发一次 SIG_ABRT, 这个信号的作用相当于第二次 SIG_SEGV
2. 第十四步中, abort 函数会发出第二次 SIG_ABRT (相当于第三次 SIG_SEGV), 导致进程退出.

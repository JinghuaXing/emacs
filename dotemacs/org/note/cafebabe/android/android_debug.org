#+TITLE: Android Debug
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* Android Debug Internals
** hierachyviewer
hierachyviewer 在 host 端通过 socket 与手机端的 ViewServer 通信.
ViewServer 并非开机启动, 而是需要由 host 端的 hierachyviewer 的
startViewServer 通过 "adb shell service call window 1 i32 port" 调用
WMS 的 startViewServer 来启动,

ViewServer 会负责调用 ViewDebug 的相关方法来 DUMP 或 CAPTURE 等
** ddms
ddms 通过 jdwp 控制 java 进程
*** method tracing
*** hprof
- 在代码中生成
  Debug.dumpHprofData()
- 使用信号on-demand生成
- 为了能让MAT识别android的hprof格式,需要用hprof-conv转换一下
*** gc
** adb
adb 通过 host 上的 adb 与手机端的 adbd 通信
*** logcat
adb shell setprop log.tag.mytag verbose
**** events log
- content_query_sample
*** logwrapper
*** am
*** pm
*** dumpsys
*** input
*** procrank
*** procmem
*** getprop
*** dumpstate
*** setprop
*** service
例如 hierachyviewer 启动 ViewServer 就是使用 "service call window 1
i32 port" 命令
** monkey
** uiautomator
** tombstone / debuggerd
tombstone 的生成由两方面配合: 
1. 一个 stand-alone 的基于 local socket 的 server: debuggerd.c
2. bionic 中通过 linker 嵌入到每一个可执行程序的代码: debugger.c

*** debuggerd.c

debuggerd 由 init 启动, 在一个 local socket 上监听, 每一个进程当收到
SIG_ABORT 等信号时, 会因为 debugger.c 的原因向 debuggerd.c 发送通知,
debuggerd.c 负责 dump tombstone 文件, dump 完成后向原进程再次发送同样
的信号, 这时进程才真正退出. 

*** debugger.c

debugger.c 由 bionic 的 linker 负责嵌入到每一个 elf 文件的 _start 段,
所以每一个进程都会自动执行该代码. 它的作用主要是 catch 住所有会导致退
出的信号, 例如 SIG_ABRT, SIG_SEGV 等 (但不包括 SIG_KILL). 对应的
signal handler 就是向 debuggerd.c 发送消息, 请求 dump tombstone, 同时,
为了收到 debuggerd 再次发送的信号能退出, debugger.c 会把这些信号的
handler 置为 default.

因为 SIG_KILL 无法被 catch, 所以 tombstone 无法处理 java crash, 因为
java crash 是通过 dalvik 向自己发送 SIG_KILL 实现的.

** watchdog
** anr trace
*** AMS 发送 SIGQUIT (3)
#+BEGIN_SRC java
  AMS:appNotResponding
    // for the pid, or other related pids, send SIG_QUIT (3)
    Process.sendSignal(pid, Process.SIGNAL_QUIT);
#+END_SRC

*** SignalCatcher Thread
每个 java 进程初始时会启动一个 SignalCatcher Thread, 用来接收 SIG_QUIT
#+BEGIN_SRC java
  /* start signal catcher thread that dumps stacks on SIGQUIT */
  if (!gDvm.reduceSignals && !gDvm.noQuitHandler) {
      if (!dvmSignalCatcherStartup())
          return false;
  }
#+END_SRC

SIG_QUIT 的 handler 如下:

#+BEGIN_SRC java
  dvmSuspendAllThreads(SUSPEND_FOR_STACK_DUMP);
  dvmDumpLoaderStats("sig");
  dvmDumpJniStats(&target);
  dvmDumpAllThreadsEx(&target, true);
#+END_SRC

其中 dvmSuspendAllThreads 会负责将每一个 thread 的 suspendCount 置 1,
导致:

1. status 为 RUNNING 的 thread 将来运行到 safepoint 时会调用
   dvmCheckSuspendPending(self), 进而被 suspend, 变为 SUSPEND 状态.

2. status 为 MONITOR, WAIT, SUSPEND  等的 thread 在从 monitor 返回, 从
   WAIT 返回等之前, 会调用 dvmChangeStatus 尝试将status 变成 RUNNING 状
   态, 此时会因为 suspendCount 为 1 而被 block,导致无法变为 RUNNING 状
   态 (注意只有 dvmChangeStatus 为 RUNNING 时才进行 suspendCount 的检查,
   因为这表示后续的代码将要操作 java 对象)

3. status 为 NATIVE 的 thread 的 suspendCount 检查主要有两个方面:
   - 整个 native 函数调用返回
     dvmCallJNIMethod 函数在调用完 jni 函数后, 要通过 dvmChangeStatus
     (RUNNING), 导致 suspendCount 检查

   - native 函数本身需要调用 env->xxx 等 jni 函数
     "
     All JNI methods must start by changing their thread status to
     THREAD_RUNNING, and finish by changing it back to THREAD_NATIVE
     before returning to native code.  The switch to "running"
     triggers a thread suspension check.
     "     
     即: native 函数要调用 env->xxx 如 env->NewObject 时, 需要先
     dvmChangeStatus(RUNNING), 这时会进行 suspendCount 检查, 当
     env->NewObject 返回时要调用 dvmChangeStatus(NATIVE)

     这说明了一个事实: 若 native 函数正在做一些不需要导致
     dvmChangeStatus 的动作, 例如没有调用 env->xxx, 则 suspendCount 并
     不会导致该 thread 被 suspend.

除了 dump trace (SignalCatcher),  dvmSuspendAllThreads 在以下情况下也
会被调用:

1. GC
2. jdwp


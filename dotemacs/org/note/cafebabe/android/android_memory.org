#+TITLE: Android Memory
* Android Memory
** tools
*** mat
*** valgrind / callgrind / kcachegrind
*** dumpsys meminfo
*** cat /proc/pid/smaps
*** procmem
*** procrank
** xss
- vss
  虚拟地址
- rss
  占用的物理内存, 包含和其他进程共享的 mmap 区域
- pss
  物理内存, 但共享的部分会按比例分配
- uss
  物理内在, 不包含共享的部分

所谓`共享'的部分, 不仅仅包含共享库,实际上,页表上所有物理页只要被多个进
行共享 (包含 cow 这种情况) 就不会被计入 uss.

例如:
#+BEGIN_SRC c
  int main(int argc, char *argv[]) {
      fork();
      sleep (1000);
      return 0;
  }
#+END_SRC

以上的代码, 

当没有 fork 时, procrank 显示为:
#+BEGIN_EXAMPLE
1905    1396K    1392K     582K     556K  test_sqlite
#+END_EXAMPLE

当有 fork 时, procrank 显示为:

#+BEGIN_EXAMPLE
1975    1328K    1324K     323K      24K  test_sqlite
1974    1404K    1400K     313K      12K  test_sqlite
#+END_EXAMPLE

注意看 uss 的差别. 

** allocation
** recycle
[[http://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/index.html][Android 操作系统的内存回收机制]]
*** oom adj
java 层定义的 oom adj 和 low memory killer 及 oom killer 使用的 oom
adj 是对应的, framework 会通过 /proc 将上层设定的 oom adj 传递给
kernel.

low memory killer 会维护一个 oom adj 与 系统最低内存的 threshold 的关系,
当系统内存少于此 threshold 时, 所有高于该 oom adj 的进程都会成为可能
的 victim, low memory killer 会从这些 victim 中选择一个杀掉

#+BEGIN_SRC c
  static int lowmem_adj[6] = { 
      0, 
      1, 
      6, 
      12, 
  }; 
  static int lowmem_adj_size = 4; 
  static size_t lowmem_minfree[6] = { 
      3 * 512,      /* 6MB */ 
      2 * 1024,     /* 8MB */ 
      4 * 1024,     /* 16MB */ 
      16 * 1024,    /* 64MB */ 
  }; 
  static int lowmem_minfree_size = 4; 
#+END_SRC

可见, 进程的 oom adj 小于 0 的话, 是不可能被 lmk 杀掉的, 这类的 oom
adj 只有两种:

- PERSISTENT_PROC_ADJ = -12;
  对应 persist 进程

- SYSTEM_ADJ = -16;
  对应 system 进程

**** ProcessRecord adj
#+BEGIN_SRC java
  static int HIDDEN_APP_MAX_ADJ = 15;
  static int HIDDEN_APP_MIN_ADJ = 9;
  
  // The B list of SERVICE_ADJ -- these are the old and decrepit
  // services that aren't as shiny and interesting as the ones in the A list.
  static int SERVICE_B_ADJ = 8;
  
  // This is the process of the previous application that the user was in.
  // This process is kept above other things, because it is very common to
  // switch back to the previous app.  This is important both for recent
  // task switch (toggling between the two top recent apps) as well as normal
  // UI flow such as clicking on a URI in the e-mail app to view in the browser,
  // and then pressing back to return to e-mail.
  static int PREVIOUS_APP_ADJ = 7;
  
  // This is a process holding the home application -- we want to try
  // avoiding killing it, even if it would normally be in the background,
  // because the user interacts with it so much.
  static int HOME_APP_ADJ = 6;
  
  // This is a process holding an application service -- killing it will not
  // have much of an impact as far as the user is concerned.
  static int SERVICE_ADJ = 5;
  
  // This is a process currently hosting a backup operation.  Killing it
  // is not entirely fatal but is generally a bad idea.
  static int BACKUP_APP_ADJ = 4;
  
  // This is a process with a heavy-weight application.  It is in the
  // background, but we want to try to avoid killing it.  Value set in
  // system/rootdir/init.rc on startup.
  static int HEAVY_WEIGHT_APP_ADJ = 3;
  
  // This is a process only hosting components that are perceptible to the
  // user, and we really want to avoid killing them, but they are not
  // immediately visible. An example is background music playback.
  static int PERCEPTIBLE_APP_ADJ = 2;
  
  // This is a process only hosting activities that are visible to the
  // user, so we'd prefer they don't disappear.
  static int VISIBLE_APP_ADJ = 1;
  
  // This is the process running the current foreground app.  We'd really
  // rather not kill it!
  static int FOREGROUND_APP_ADJ = 0;
  
  // This is a system persistent process, such as telephony.  Definitely
  // don't want to kill it, but doing so is not completely fatal.
  static final int PERSISTENT_PROC_ADJ = -12;
  
  // The system process runs at the default adjustment.
  static final int SYSTEM_ADJ = -16;
  
#+END_SRC

#+BEGIN_SRC java
  int maxAdj;                 // Maximum OOM adjustment for this process
  int hiddenAdj;              // If hidden, this is the adjustment to use
  int curRawAdj;              // Current OOM unlimited adjustment for this process
  int setRawAdj;              // Last set OOM unlimited adjustment for this process
  int nonStoppingAdj;         // Adjustment not counting any stopping activities
  int curAdj;                 // Current OOM adjustment for this process
  int setAdj;                 // Last set OOM adjustment for this process
  static final int TMP_CUR_ADJ_DEFAULT = 100;
  int tmpCurRawAdj = TMP_CUR_ADJ_DEFAULT; // Set by application to change it's oom_adj tempropraly
  int tmpCurAdj = TMP_CUR_ADJ_DEFAULT;    // Set by application to change it's oom_adj tempropraly
#+END_SRC

*** trimApplications
**** activityIdle
当 resumeActivity 完成后, 新启动的 activity 会在自己的 MessageQueue 上
注册一个 idler, 该 idler 会执行 ams.activityIdle, 以便 finish 之前的
activity, 并做一些清理的动作. 

#+BEGIN_SRC text
  activityIdleInternal()
    // 调用之前的 activity 的 onStop
    for (i=0; i<NS; i++):
        ActivityRecord r = (ActivityRecord)stops.get(i);
        stopActivityLocked(r);
    // 调用之前 activity 的 onDestroy      
    for (i=0; i<NF; i++):
        ActivityRecord r = (ActivityRecord)finishes.get(i);
        destroyActivityLocked(r, true, false, "finish-idle");
    mService.trimApplications();
      // First remove any unused application processes whose package 
      // has been removed. 
      for (i=mRemovedProcesses.size()-1; i>=0; i--):
        // kill process;
        // mRemovedProcesses 是之前通过 handleAppCrashLocked, 或者
        // killAllBackgroundProcesses, 或者 killPackageProcessesLocked
        // 等被标记为 kill 的进程.
        Process.killPackageProcessesLocked()
        cleanUpApplicationRecordLocked()
  
      // Now update the oom adj for all processes.
      // 最关键的代码, 包括计算 oom adj, trim memory, 关闭过多的后台
      // 进程等 ...
      updateOomAdjLocked();
       foreach process:
         updateOomAdjLocked();
           computeOomAdjLocked();
         if (!app.killedBackground):
           // 若当前进程的 adj 为后台, 则台台进程过多, 则 kill 该进程
           // 其中 MAX_HIDDEN_APPS 定义为 15
            if (app.curAdj >= ProcessList.HIDDEN_APP_MIN_ADJ) {
                numHidden++;
                if (numHidden > MAX_HIDDEN_APPS):
             app.killedBackground = true;
             Process.killProcessQuiet(app.pid);
         // fi app.killedBackground  
        // foreach end
        // 然后根据 numHidden 计算一个 trim level, 然后根据 adj, trim level
        // 等决定向哪些 app 发送 onTrimMemory(level) 调用.
        // TODO: how to calculate trim level
#+END_SRC
**** To summaries
在适当的时候, updateOomAdj 会被调用, 主要作用是:
1. 修改所有进程的 adj, 并通知 kernel
2. 根据 MAX_HIDDEN_APPS kill 某些后台应用
3. 对剩下来的某些应用调用 onTrimMemory, 并指定不同的 trim level
*** low memory killer
** java memory
*** GC
android GC 不使用逐代回收(即不区分 young, old, perm gen), 默认情况下使
用 mark and sweep 算法, 可以在编译时选择使用 copying 算法.
** misc
*** bionic optimization for malloc ?
#+BEGIN_SRC c
  char * buffer = (char *) malloc(1024*1024*50);
  int i=0;
  for (i=0;i<1024*1024*50; ++i) {
      buffer[i]=1;
  }
#+END_SRC

above code in linux will consume 50MB rss as expected, but under
androd, rss is not consumed at all? Seems there is a kind of
optimization ? 

#+BEGIN_SRC c
  char * buffer = (char *) malloc(1024*1024*50);
  int i=0;
  for (i=0;i<1024*1024*50; ++i) {
      buffer[i]=random();
  }
#+END_SRC

But if we fill the memory will `random', both linux and android will
consume 50MB rss.

** Reference
- [[http://stackoverflow.com/questions/2298208/how-to-discover-memory-usage-of-my-application-in-android][how-to-discover-memory-usage-of-my-application-in-android]]
- [[http://stackoverflow.com/questions/131303/linux-how-to-measure-actual-memory-usage-of-an-application-or-process][linux-how-to-measure-actual-memory-usage-of-an-application-or-process]]
** About GC heap, growthLimit and OOM
一直以来 android 都流传着一个说法:
`android 的 GC heap 有一个 growthLimit 参数, 可以控制 GC heap 的大小,
而且 external 分配的内存也会算在 growthLimit 里, 当 GC heap 大小到达
growthLimit 时, 会 OOM`

我觉得这有些不可思议: 难道我在 jni 里 mmap 的内存也会受 growthLimit 的
限制? 以下是我的调查:
*** 第一阶段 ...
- 为什么 OOM?
  - 代码抛出来的 ...
    - 用户自己故意通过 java 代码或 jni 抛出 OOM 异常
    - dalvik 自己抛出 OOM 异常
      - dvmMalloc
        dalvik在构造一切 java 对象时都会使用 dvmMalloc 在 GC heap 上分
        配内存.
        - Heap.tryMalloc
          - dvmHeapSourceAlloc
          - dvmHeapSourceAllocAndGrow
            当 grow 完了还是分配失败 dalvik 会主动抛出 OOM
      - malloc/mmap/...
        dalvik 有时有会需要使用 malloc/mmap 直接从 GC heap 之外分配内存,
        例如 jni 里的 GetStringUTFChars:
        #+BEGIN_EXAMPLE
          GetStringUTFChars
            char* newStr = (char*) malloc(byteLen+1);            
            convertUtf16ToUtf8(newStr, data, len);
            if (newStr == NULL):
              /* assume memory failure */
              dvmThrowOutOfMemoryError("native heap string alloc failed");
        #+END_EXAMPLE

- OOM 不一定是 GC heap 不足, dalvik 可以把任何形式的内存分配失败上报 为
  OOM, 可以说某些 mmap/malloc/brk 操作会导致 OOM, 但不能说这些 OOM 是因
  为 growthLimit 导致的. growthLimit 只会导致 dvmMalloc 抛出 OOM

- ps
  - GC heap 实际上是使用 mmap 一次性从 ashmem map 出 growthLimit 大小
    的内存区域, 然后每次 dvmMalloc 是在这块大的区域上使用 ptmalloc 再
    分配.
  - 我看了一眼 ByteBuffer.allocateDirect 方法, 在 dalvik 里它是分配在
    GC heap 上的...但在 hotspot 是用 mmap 分配的, 不太一样.
  - bitmap 是分配在 GC heap 里, 但通过 binder 传输时会使用 ashmem, 因
    为直接传的话 binder 放不下.
  - CursorWindow 直接就是放在 ashmem 里的, 原因同 bitmap
  - heapGrowthLimit 真的可以影响非 dvmMalloc 分配的内存(或者说非 GC
    heap) 么?  求代码求真相, 反正我是没找到...
*** 第二阶段 ...

2.3.5 的代码中除了一个类似于 growthLimit 的 absoluteMaxSize 外, 还维护
了一个 externalBytesAllocated 的变量, 初始为0.

2.3.5 代码创建 bitmap 时使用的是 HeapAllocator (现在都改成
JavaAllocator 了), 它会先调用 malloc 分配内存, 然后调用
GraphicsJNI::setJavaPixelRef, 这个函数最终会调到 davlik 的 HeapSource里
的 externalAlloc(), 这个 externalAlloc 实际上并不分配内存, 只是更新了一
个 externalBytesAllocated 的值.

当 dalvik 调用 dvmAlloc 从 GC heap 分配 java 对象时, 会有一个额外的判断:

#+BEGIN_SRC java
  if (max > hs->externalBytesAllocated) {
      max -= hs->externalBytesAllocated;
  
      mspace_set_max_allowed_footprint(heap->msp, max);
      ptr = dvmHeapSourceAlloc(n);
      ...
#+END_SRC
   
可见, 虽然 bitmap 并没有分配在 GC heap, 却可以通过
externalBytesAllocated 这个值影响 GC heap 能使用的大小 ... Orz

同样的情况还出现在 ByteBuffer.allocateDirect 方法中:

ByteBuffer.allocateDirect() 分配内存时使用以下方法:

#+BEGIN_SRC java
  static jint OSMemory_malloc(JNIEnv* env, jclass, jint size) {
      jboolean allowed = env->CallBooleanMethod(gIDCache.runtimeInstance,
                                                gIDCache.method_trackExternalAllocation, static_cast<jlong>(size));
      if (!allowed) {
          LOGW("External allocation of %d bytes was rejected\n", size);
          jniThrowException(env, "java/lang/OutOfMemoryError", NULL);
          return 0;
      }
  
      LOGV("OSMemory alloc %d\n", size);
      void* block = malloc(size + sizeof(jlong));
      ...
  
#+END_SRC

综上, 在 2.3.5, 分配 bitmap 和 ByteBuffer 时确实会影响可用的 GC heap,
但到了现在 (4.x), 以上两种情况都已经不成立了:

1. bitmap 改成在 GC heap 上分配了.
2. DirectBuffer 也改成 GC heap 上分配了.
3. HeapSource 中 external allocation 相关的代码都已经不存在了.



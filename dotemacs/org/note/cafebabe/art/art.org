#+TITLE: ART
#+AUTHOR: Wei Sun (孙伟)
#+EMAIL: wei.sun@spreadtrum.com
* ART
** ART 启动
ART 的启动与 dalvik 是相同的, 都是通过 dalvikvm.cc 中的 dalvikvm 启动,
不同的是, JniInvocation 会通过 dlopen(libart.so) 从 libart.so 中找到
ART 版本的 JNI_CreateJavaVM 等函数, 进而再对通过这个函数的调用找到 ART
版本的 JNIEnv 和 JavaVM 实现, 进而找到这两个类中定义的各种 JNI 回调函数.
*** JNICreateJavaVM
#+BEGIN_SRC text
  JNI_CreateJavaVM @ jni_internal.cc
    Runtime::Create(options, ignore_unrecognized) @ runtime.cc
      Runtime::Init
        // 解析各种 options
        options(ParsedOptions::Create(raw_options,ignore_unrecognized));
        heap_ = new gc::Heap(options->heap_initial_size_,
              options->heap_growth_limit_,
              // ..
              options->is_concurrent_gc_enabled_,
              // art 的 gc 采用的是 m 个 parrallel gc thread 负责 paused
              // 阶段的 gc + n 个 concurrent gc thread 负责 unpaused 阶
              // 段的 gc
              options->parallel_gc_threads_,
              options->conc_gc_threads_,
              // ..);
        // heap 初始化时会负责初始化 mark_bitmap_, live_bitmap_,
        // card_table_, mark_stack_, live_stack_, 以及各种 collector
        // 通过 sigprocmask 阻止当前进程的所有线程收到 SIGPIPE 和 SIGUSER1
        // 后面 signal catcher 线程会负责处理这两个信号
        BlockSignals();
        // 从 oat 文件中创建 ClassLinker
        class_linker_ = ClassLinker::CreateFromImage(intern_table_);
    runtime->Start();
      InitNativeMethods()
      if (is_zygote_):
        InitZygote()
      else:
        DidForkFromZygote();
          heap_->CreateThreadPool();
          StartSignalCatcher();
          Dbg::StartJdwp();
      StartDaemonThreads();
      system_class_loader_ = CreateSystemClassLoader();
#+END_SRC
*** InvokeMain
dalvikvm 启动 ART 时, 与启动 dalvik 相同, 最终都会调用到
CallStaticObjectMethod

#+BEGIN_SRC text
  jobject CallStaticObjectMethod @ jni_internal.cc
#+END_SRC

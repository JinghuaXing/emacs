#+TITLE: JVM
* Java VM
** String.intern()
see also [[constant pool]]

String.intern()与constant pool的关系?
VM 运行后, VM 本身会维护一个 internedStrings<char *, String> 的 HashMap, String.intern() 的作用是:
- 从 internedStrings 中查找是否已存在, 若不存在, 向 map 中插入一条记录, 最后返回 map的value,
- 所以 assert(new String("abc").intern() == new String("abc").intern());

  String.intern() 使用的 internedStrings 本身和 constant pool 并没有直接关系, 但:
#+BEGIN_EXAMPLE
    String s1="abc";
    String s2=new String("abc");
    assert(s1==s2.intern());
#+END_EXAMPLE
有两种可能:
1. VM 在 resolve class (resolve constant pool) 时, 一次性的将所有
     CONSTANT_String_info 全通过 intern() 放到 internedStrings 中, 然后
     CONSTANT_String_info的 data 为 生成的 String 对象
  
2. LAZY initialization: 如 [[constant pool]] 所述, 访问
     CONSTANT_String_info 使用 `ldc` 指令, 而 `ldc` 指令可以隐式的调用
     String.intern(), 并返回 intern() 的结果

   To summarize:
    - 对于 string literal, 再显式调用 intern() 没有意义
    - 对于 运行时 string, 若 string 经常重复, 可以通过 intern() 做 cache
** Constant Pool
see also [[String.intern()]]
see also [[autoboxing]]
see also [[valueOf]]

#+BEGIN_EXAMPLE
    String s1="abc";
    String s2="abc";
    assert(s1==s2);
    String s3=new String("abc");
    String s4=new String("abc");
    assert(s3!=s4);

    Integer i1=100;
    Integer i2=100;
    assert(i1==i2);  // see autoboxing & valueOf
    Integer i3=200;
    Integer i4=200;
    assert(i3!=i4);  // see autoboxing & valueOf
#+END_EXAMPLE

    Constant pool plays an important role in the dynamic linking of Java program. In addition to constant values (String, integer, float literal),
    the constant pool contains the following kinds of symbolic references:
     - fully qualified names of classes and interfaces
     - field names and descriptors (type...)
     - method names and descriptors (params,type,...)

    Constant pool can contain the following variety entries:
     - CONSTANT_Utf8
     - CONSTANT_Integer
     - CONSTANT_Float
     - CONSTANT_Long
     - CONSTANT_Double
     - CONSTANT_Class
     - CONSTANT_String
     - CONSTANT_FieldRef
     - CONSTANT_MethodRef
     - CONSTANT_NameAndType

    To summarize:
    Constant pool works in 3 varieties:
      1. save constant literal (and class static field), much like DATA section in ELF
      2. help dynamic linking resolution
      3. name cache
**** class, method, field..
java code:
#+BEGIN_EXAMPLE
   public class Test {
     int x;
     public static void main(String args[]) {
	Test t=new Test ();
	t.x=100;
	t.foo ();
     }
     void foo () {

     }
   }
#+END_EXAMPLE
byte code:
#+BEGIN_EXAMPLE
   const #1 = Method	#6.#18;	//  java/lang/Object."<init>":()V
   const #2 = class	#19;	//  Test
   const #3 = Method	#2.#18;	//  Test."<init>":()V
   const #4 = Field	#2.#20;	//  Test.x:I
   const #5 = Method	#2.#21;	//  Test.foo:()V
   const #6 = class	#22;	//  java/lang/Object
   const #7 = Asciz	x;
   const #8 = Asciz	I;
   const #9 = Asciz	<init>;
   const #10 = Asciz	()V;
   const #11 = Asciz	Code;
   const #12 = Asciz	LineNumberTable;
   const #13 = Asciz	main;
   const #14 = Asciz	([Ljava/lang/String;)V;
   const #15 = Asciz	foo;
   const #16 = Asciz	SourceFile;
   const #17 = Asciz	Test.java;
   const #18 = NameAndType	#9:#10;//  "<init>":()V
   const #19 = Asciz	Test;
   const #20 = NameAndType	#7:#8;//  x:I
   const #21 = NameAndType	#15:#10;//  foo:()V
   const #22 = Asciz	java/lang/Object;

   {
   int x;

   public Test();
   Code:
   Stack=1, Locals=1, Args_size=1
   0:	aload_0
   1:	invokespecial	#1; //Method java/lang/Object."<init>":()V
   4:	return
   LineNumberTable:
   line 2: 0

   public static void main(java.lang.String[]);
   Code:
   Stack=2, Locals=2, Args_size=1
   0:	new	#2; //class Test
   3:	dup
   4:	invokespecial	#3; //Method "<init>":()V
   7:	astore_1
   8:	aload_1
   9:	bipush	100
   11:	putfield	#4; //Field x:I
   14:	aload_1
   15:	invokevirtual	#5; //Method foo:()V
   18:	return
   LineNumberTable:
   line 5: 0
   line 6: 8
   line 7: 14
   line 8: 18

   void foo();
   Code:
   Stack=0, Locals=1, Args_size=1
   0:	return
   LineNumberTable:
   line 11: 0

   }
#+END_EXAMPLE
**** put/set static field
     java code:
#+BEGIN_EXAMPLE
     class Test {
        static float x=1.1f;
	public static void main(String args[]) {
	    x=1.2f;
	  }
      }
#+END_EXAMPLE
     byte code:
#+BEGIN_EXAMPLE
     ...
     const #3 = Field        #5.#20; //  Test.x:F
     ...
     0:   ldc     #2; //float 1.2f
     2:   putstatic       #3; //Field x:F
     ...
#+END_EXAMPLE
**** literal
***** String literal
      java code:
      #+BEGIN_EXAMPLE
      public class Test {
      public static void main(String args[]) {
      String s1="abc";
      }
      }
      #+END_EXAMPLE
      byte code:
      #+BEGIN_EXAMPLE
      ~@mbjswglx56> javap -verbose Test
      Compiled from "Test.java"
      public class Test extends java.lang.Object
      SourceFile: "Test.java"
      minor version: 0
      major version: 49
      Constant pool:
      const #1 = Method       #4.#13; //  java/lang/Object."<init>":()V
      const #2 = String       #14;    //  abc
      const #3 = class        #15;    //  Test
      const #4 = class        #16;    //  java/lang/Object
      const #5 = Asciz        <init>;
      const #6 = Asciz        ()V;
      const #7 = Asciz        Code;
      const #8 = Asciz        LineNumberTable;
      const #9 = Asciz        main;
      const #10 = Asciz       ([Ljava/lang/String;)V;
      const #11 = Asciz       SourceFile;
      const #12 = Asciz       Test.java;
      const #13 = NameAndType #5:#6;//  "<init>":()V
      const #14 = Asciz       abc;
      const #15 = Asciz       Test;
      const #16 = Asciz       java/lang/Object;

      {
      public Test();
      Code:
      Stack=1, Locals=1, Args_size=1
      0:   aload_0
      1:   invokespecial   #1; //Method java/lang/Object."<init>":()V
      4:   return
      LineNumberTable:
      line 2: 0

      public static void main(java.lang.String[]);
      Code:
      Stack=1, Locals=2, Args_size=1
      0:   ldc     #2; //String abc
      2:   astore_1
      3:   return
      LineNumberTable:
      line 4: 0
      line 5: 3

      }
      #+END_EXAMPLE
      可见,"abc"这个string literal被保存在constant pool #14/#2 的位置, java代码使用 `ldc #2` 从 constant pool中获得这个string, 并放到栈顶.

      ldc pushes a one-word constant from the constant pool onto the operand stack. the following java types can be pushed using ldc:
       - int
       - float
       - String

      Pushing a String causes a reference to a java.lang.String object to be constructed and pushed onto the operand stack. Pushing an int or float causes
      a primitive value to be pushed;

      String literal总是放在constant pool中, 并通过 ldc 加载.

***** int, float literal
     java code:
#+BEGIN_EXAMPLE
     Integer i=100;
#+END_EXAMPLE
     byte code:
#+BEGIN_EXAMPLE
     0:   bipush  100
     2:   invokestatic    #2; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     5:   astore_1
#+END_EXAMPLE
     java code:
#+BEGIN_EXAMPLE
     Integer i=100000;
#+END_EXAMPLE
     byte code:
#+BEGIN_EXAMPLE
     0:   ldc     #2; //int 100000
     2:   invokestatic    #3; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     5:   astore_1
#+END_EXAMPLE
     - 对于int常量, >short时放在constant pool, <short时直接写到代码中
     - ldc 对于 int 只是放 primitive 值放在 stack中, Integer的 autoboxing 实际就是隐式的调用了 Integer.valueOf
     - float常量始终存放在constant pool中
** Class Loader
*** class unloading
** invokeXXX
*** invokevirtual vs. invokespecial
similar with c++'s call-by-reference and call-by-value; that is, `invokespecial` will prohibit polymorphism.
*** invokestatic
direct addressing
*** invokeinterface
contant-pool would be iterated to find the interface method, since an object can inhereit multiply interface;
** GC
*** 分代 GC
**** young gen
***** eden
***** survior
**** old gen
大对象直接进入 old gen
**** perm gen
*** GC 算法
**** mark and sweep
young gen 通常使用 copy 算法
**** copy
old gen 通常使用 mark and sweep 算法
*** Finalizer And Reference
**** finalize() 导致两次 GC
http://www.fasterj.com/articles/finalizer1.shtml

1. 对于有 finalize() 的类, jvm 会给每个类生成一个 FinalizerReference
2. GC 时, 每个 FinalizerReference 会被检查, 若 referent 已经被
   unmarked, 则
   1. 将 referent 重新置为 marked
   2. 将 referent enqueue 到 FinalizerQueue 中, 后面 Finalizer Thread
      会负责调用 finalize(), 并再次 unmark 该 referent
   3. 再次 GC 时, referent 才会真正被 GC

Finalizer 的具体实现和使用 PhantomReference 避免 finalizer 非常类似, 只
不过是由 jvm 维护着一个 FinalizerReference 以及一个 FinalizerQueue,并且
调度 Finalizer Thread 在 FinalizerQueue 上阻塞(通过 remove) 以便调用
finalizer

***** FinalizerReference
***** Finalizer Thread (HeapWorker)
**** 使用 PhantomReference 避免 finalize()
http://java.dzone.com/articles/finalization-and-phantom

***** 使用 WeakReference 是否也可以?
好像不行, dvm 里 GC 时处理各处 reference 的代码:
#+BEGIN_SRC java
  // clearWhiteReferences 是将 references 数组中每个 reference
  // 进行如下处理: 若 referent 为 unmarked, 则将 reference enqueue 到
  // 相应的 queue 中
  clearWhiteReferences(softReferences);
  clearWhiteReferences(weakReferences);
  
  // enqueueFinalizerReferences 会负责将 finalizerReferences 中 unmarked
  // 的 reference 置于 FinalizerQueue 中, 以调度 finalize()
  enqueueFinalizerReferences(finalizerReferences);
  
  /*
   * Clear all f-reachable soft and weak references with white
   * referents.
   */

  clearWhiteReferences(softReferences);
  clearWhiteReferences(weakReferences);
  
  // 清理 phantomReferences
  clearWhiteReferences(phantomReferences);
    
#+END_SRC
由以上代码可知, weakReferences, softReferences 在 enqueue 时, 后续的
enqueueFinalizerReferences 有可能导致 weakReferences 的 referent 重新
变为 marked, 结果就是 weakReferences 的 queue 读取出来的
weakReferences 有可能其 referent 并没有被 finalize .... 不过, 若
referent 本身并不是 finalizable, 则 enqueueFinalizerReferences 并不能
对其产生影响, 所以这时 weakReferences, phantomReferences 应该是一样的

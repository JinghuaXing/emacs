* Single/Double/Multiple Dispatching
  Dispatching, 指的是调用一个函数时, 因为存在多个同名的函数,仅仅靠函数的名字无法
  确定究竟要调用哪个, 这时函数参数的个数和类型就需要被考虑; Dispatching就是指: 根
  据函数的参数的个数和类型选择具体要执行的函数.

  看起来 Dispatching 和 Overloading 很像, 实际上从我个人的理解来看, 这里讨论的
  Dispatching属于 *运行时行为*, 则 Overloading 属于 *编译时行为* , 所以两者并没有关系.

** Single Dispatching
   Single Dispatching, 即只能根据函数的某一个参数进行dispatch, 多态就是一个
   single Dispatching, 因为每一个虚函数都隐含着一个this参数, 程序在运行时可以根据
   this具体类型的不同, 选择不同的函数.

** Double Dispatching / Multiple Dispatching
   Double Dispatching 和 Multiple Dispatching, 顾名思义, 就是根据函数的两个或多个
   参数的运行时类型进行dispatch.大部分编译型的面向对象的语言,如C++,Java, 都不支持
   Multiple/Double Dispatching, 例如:
#+BEGIN_HTML
<pre lang="java" line="1">
    public class Test {
        static void foo (Throwable e) {

	}
	static void foo (Error e) {
	    
	}
	public static void main(String[] args) {
	    Throwable e=new Error ();
	    foo (e);
	}
    }
</pre>
#+END_HTML

对应的byte code:

#+BEGIN_HTML
<pre lang="java" line="1">
  public static void main(java.lang.String[]);
  Code:
   Stack=2, Locals=2, Args_size=1
   0:	new	#2; //class java/lang/Error
   3:	dup
   4:	invokespecial	#3; //Method java/lang/Error."<init>":()V
   7:	astore_1
   8:	aload_1
        // 编译时就确定为使用 Method foo:(Ljava/lang/Throwable;)V  
   9:	invokestatic	#4; //Method foo:(Ljava/lang/Throwable;)V  
   12:	return
}
</pre>
#+END_HTML

   在编译时 foo(e)就已经被确定为 foo(Throwable e) 这个函数, 而不会在运行时根据e的
   具体类型选择 foo(Error). 所以函数重载不是Multiple Dispatching

   虽然C++,Java等不支持Multiple/Double Dispatching, 但可以使用其他方法来模拟,因为
   C++和Java都支持Single Dispatching和运行时类型识别 (C++的RTTI和Java的Reflection)
** 使用运行时类型识别模拟Double Dispatching
#+BEGIN_HTML
<pre lang="java" line="1">
   public class Test {
      static void foo (Throwable e) {
  	if (e instanceof Exception) {

	} else if (e instanceof Error) {

	}
      }
      public static void main(String[] args) {
	Throwable e=new Error ();
	foo (e);
      }
   }
</pre>
#+END_HTML
** 使用Single Dispatching来模拟Double Dispatching
   见 Visitor Pattern
* Visitor Pattern
** 使用Visitor Pattern模拟Double Dispatching
  Visitor Pattern定义了两类对象: Element和Visitor, 其中Element需要定义一个accept方法, 而
  visitor需要定义一个visit方法. 

  一个简单的Visitor Pattern的例子:
#+BEGIN_HTML
<pre lang="java" line="1">
interface Element {
    void accept (Visitor v);
}

class AElement implements Element {
    public void accept (Visitor v) {
	v.visit (this);
    }
}

class BElement implements Element {
    public void accept (Visitor v) {
	v.visit (this);
    }
}

interface Visitor {
    void visit (AElement e);
    void visit (BElement e);
}

class AVisitor implements Visitor {
    public void visit (AElement ae) {
	System.out.println("AVisitor visit AElement");
    }
    public void visit (BElement ae) {
	System.out.println("AVisitor visit BElement");
    }
}

class BVisitor implements Visitor {
    public void visit (AElement ae) {
	System.out.println("BVisitor visit AElement");
    }
    public void visit (BElement ae) {
	System.out.println("BVisitor visit BElement");
    }
}

public class Test {
    public static void main(String[] args) {
	Element ae=new BElement ();
	Visitor av=new AVisitor ();
	ae.accept (av);
    }
}
</pre>
#+END_HTML

这个例子模拟了Double Dispatching, 因为对于Visitor来说, 首先, 根据Visitor的具体类
型 (AVisitor) 找到Avisitor的方法, 然后AVisitor又根据Element的具体类型(BElement)找
到了最终的AVisitor.visit(BElement)方法. 

这里的关键有两点:
1. 借助了Element类对自己的accept方法的Single Dispatching.
2. 借助了Overloading 
其中第一点是主要的,第二点可有可无, 大不了将程序改成这样:

#+BEGIN_HTML
<pre lang="java" line="1">
class AElement implements Element {
    public void accept (Visitor v) {
	v.visitAElement (this);
    }
}

class BElement implements Element {
    public void accept (Visitor v) {
	v.visitBElement (this);
    }
}

interface Visitor {
    void visitAElement (AElement e);
    void visitBElement (BElement e);
}
</pre>
#+END_HTML


** Visitor Pattern
   Visitor Pattern的目的是将数据结构与算法分离, 当需要对对象添加新的方法时, 不需要修改对象, 只需要修改算法. 
   在上面的例子中, Element指数据结构, Visitor指算法. 

   举例来说, 动物这类对象做为Element, 其子类包括阿猫阿狗之类；动物能做的具体的动
   作做为Visitor, 例如叫,跑,被人吃掉...

   最传统的实现方法是:
#+BEGIN_HTML
<pre lang="java" line="1">
interface Animal {
    void run () 
}

class Dog implements Animal {
    void run () {
	// concrete implmentation
    }
}
</pre>
#+END_HTML

但这种实现方法带来的问题是: 具体的算法 (如run) 和对象是绑定在一起的, 而且如果要添
加一个新的 bark 方法,必须修改接口类和实现类, 而修改接口类是不可接受的.

若使用Visitor Pattern, 则可以把run方法封装到的一个RunVisitor类中, 然后调用
Animal.accept(runVisitor())即可, 所有的算法都只包含在各个Visitor中.

如果要添加一个bark方法,只需要实现一个BarkVisitor即可.  

* Visitor Pattern的具体应用 
** ASM
   [[http://asm.ow2.org][ASM Homepage]]

   ASM (一个动态生成或修改java class的库) 使用 Visitor Pattern 来实现
   其基于事件的模型.

   它在解析class时会触发一系列事件, 如解析到一个class, 解析到一个method等, 这些事
   件被做为Element; 对这些事件的处理, 如打印log, 保存到目标class等被做为
   Visitor.在ASM中, Element被看作是事件的提供者, 而Visitor被看作事件的处理者.
** MultiJava
   [[http://multijava.sf.net][MultiJava Homepage]]
#+begin_quote
MultiJava is an extension to the Java programming language that adds open classes
and symmetric multiple dispatch. Multiple dispatch allows the code invoked by a 
method call to depend on the run-time type of all the arguments, instead of just
the receiver, this is useful for event handlers and for binary methods, like
equals in Java.

The MultiJava project provides `mjc`, a MultiJava compiler, that translate MultiJava
programs to regular Java bytecode. 
#+end_quote   

使用MultiJava进行event dispatching的例子:

#+BEGIN_HTML
<pre lang="java" line="1">
  public abstract class AbstractHandler {
      public abstract void handleEvent (Event e);
  }
  
  public class MyJavaHandler extends AbstractHandler {
      public void handleEvent (Event@Event1 e) {
          // handle Event1
      }
      public void handleEvent (Event@Event2 e) {
          // handle Event2
      }
  }
</pre>
#+END_HTML


因为`Event@Event1`不是合法的Java语法,所以MultiJava需要使用`mjc`工具对源码进来转换,
转换的过程实际就是解析这种`Event@Event1`, 然后使用Visitor Pattern生成相应的Element和
Visitor

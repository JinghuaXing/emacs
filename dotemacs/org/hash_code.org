#+POSTID: 87
#+DATE: [2011-09-12 一 14:03]
#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil TeX:nil
#+CATEGORY: java
#+TAGS: java,android,jvm,hotspot,dalvik,gc
#+DESCRIPTION:
#+TITLE: Object.hashCode()
* PUBLISHED Object.hashCode()
  CLOSED: [2011-09-12 一 14:46]
    众所周知, Object.hashCode()和对象的地址有很大关系,而某些GC算法(如Copying, mark-sweep-compact...)会改变对象的地址,而hashCode是要保证对同一个对象永远不变 (否则HashMap会很崩溃),那么hashCode如何保证对
    不同的对象 *尽可能* 的不同, 而对于同一个对象一定保持不变? 

    不同的jvm在处理Object.hashCode()有不同的方法,但基本原理是相同的:

    *若对象没移动过,则返回对象的地址做为hashCode；对象移动时,若发现hashCode已经被调用过了,为了使后续对该对象的hashCode仍返回相同的值,保存该hashCode (即对象移动之前的地址)*

    - Hotspot JVM:
      Hotspot JVM中一个对象在内存中的layout大致是:

      |-----------+--------+---------|
      | Mark Word | Object | Padding |
      |-----------+--------+---------|

      - Mark Word:
        HashCode, lock, thread_id 等都保存在 Mark Word中
      - Object: 
        真正的对象
      - Padding:
        JVMS规定需要8字节对齐

      OpenJdk是关于HashCode的代码:
#+BEGIN_HTML
<pre lang="java" line="1">
      mark=ReadStableMark(obj);
      if (mark->is_neutral()) {
        hash=mark->hash();
        if (hash) {
          return hash;
        }
        hash=get_next_hash(Self,obj);
        temp=mark->copy_set_hash(hash);
        test=cmpxchg(temp,obj->mark_addr(),mark); // 使用CAS保证操作是原子的
        if (test==mark) {
          return hash;
        }
      }
      ...
</pre>
#+END_HTML
    - Dalvik VM
      
      Dalvik与Hotspot类似, 不过它把HashCode保存在真正的对象数据之后 

      dalvik/vm/Sync.c:dvmIdentityHashCode
#+BEGIN_HTML
<pre lang="java" line="1">
      if (hashState == LW_HASH_STATE_HASHED) {
         // The object has been hashed but has not had its hash code
         // relocated by the garbage collector.  Use the raw object
         // address.
        return (u4)obj >> 3; // >>3 means 8 bytes alligned
      } else if (hashState == LW_HASH_STATE_HASHED_AND_MOVED) {
         // The object has been hashed and its hash code has been
         // relocated by the collector.  Use the value of the naturally
         // aligned word following the instance data.
        if (IS_CLASS_FLAG_SET(obj->clazz, CLASS_ISARRAY)) {
            length = arrayObjectLength((ArrayObject *)obj);
            length = (length + 3) & ~3;
        } else {
            length = obj->clazz->objectSize;
        }
        return *(u4 *)(((char *)obj) + length);
      } else if (hashState == LW_HASH_STATE_UNHASHED) {
        self = dvmThreadSelf();
        if (self->threadId == lockOwner(obj)) {
             // We already own the lock so we can update the hash state
             // directly.
            *lw |= (LW_HASH_STATE_HASHED << LW_HASH_STATE_SHIFT);
            return (u4)obj >> 3;
        } 
        ...
      }
</pre>
#+END_HTML
    
    dalvik vm 中导致对象地址变化的GC部分代码:
    
    android:vm/alloc/Copying.c:transportObject(fromObj)
#+BEGIN_HTML
<pre lang="java" line="1">
    if (LW_HASH_STATE(fromObj->lock)==LW_HASH_STATE_HASHED_AND_MOVED) {
      copySize+=sizeof(u4); // make sure the hashCode at the `END` of the obj is also copied.
    }
    if (LW_HASH_STATE(fromObj->lock)==LW_HASH_STATE_HASHED) {
      // save the raw address to the END of obj, >>3 means 8 bytes alligned     
      *(u4*)(((char *)toObj)+copySize)=(u4)fromObj>>3;  
      toObj->lock|=LW_HASH_STATE_HASHED_AND_MOVED<<LW_HASH_STATE_SHIFT;
    }
    ..
</pre>
#+END_HTML
    考虑这种情况:

    obj1初始时(GC之前)被放在addr1, 然后用户调用obj1.hashCode(), 然后obj1因为GC被移动到addr3;
    然后obj2刚好被在初始化到addr1 (因为这个地址已经是空闲的了), 这对用户调用obj2.hashCode(), 
    最终导致obj1.hashCode()==obj2.hashCode(); 虽然这种情况不是我们想要的, 但hash算法本身决定了这种情况上是允许的




* Tasks
#+CATEGORY:Task
** TODO PIM: 18811046790:084906
** TODO [#A] never rebase from tracking branch
** TODO add batch unstage and revert for magit
** TODO handleSmsReceived @ SmsReceiverService
** TODO javacc
** TODO [#B] Programmer Dvorak Keyboard Layout
   - http://www.kaufmann.no/roland/dvorak/index.html
   - dvorak7min
** TODO magit
   http://zagadka.vm.bytemark.co.uk/magit/magit.html
** TODO db index
** TODO StringBuffer vs. StringBuilder
** TODO Unicode Normalize
** TODO [#A] Android Search
** TODO URI
** TODO [#B] Android eng-mode vs. user-mode
** TODO android apk signature
** TODO Android coredump
** TODO Android IMF
** TODO [#B] adjustPan/adjustResize
** TODO android MTD, memory,NAND...etc
** TODO Android Span
** TODO android tombstone
** TODO bash `source` usage
** TODO browser通过代理访问ftp?
** TODO can apk for 2.2 be installed on 2.3? and vice-vesa
** TODO Canvas
** TODO Code snippet to dump message queue
** TODO dex & apk & jar 文件格式
** TODO How IME is triggered
** TODO invokeinterface vs. invokevirtual / vtable vs. itable / _klass 
** TODO [#C] org-mode manual
** TODO PowerManagment, WakeLock
** TODO PreferenceScreen nesting & notify
** TODO res/menu sub-folder
** TODO shebang
** TODO Webview
** TODO WindowManager, layoutWindow
** TODO bugzilla 4.0
   http://dev.spreadst.com/lion/
** TODO some funcy notification for `compilation`?
   
   SCHEDULED: <2012-03-25 Sun>
** TODO ImportVCardActivity use NIO?
   
   SCHEDULED: <2012-03-21 Wed>
** TODO activity orientation change?
   
   SCHEDULED: <2012-03-22 Thu>
** TODO sqlite single-thread model
   
   SCHEDULED: <2012-03-23 Fri>
** TODO fast swith window in emacs?
   
   SCHEDULED: <2012-03-21 Wed>
** TODO 线段树
   
   SCHEDULED: <2012-03-22 Thu>
* Linux App
#+CATEGORY:Linux app
** indent && astyle
** auditd							      :sysadmin:
** htop
   交互式 top
** basename与dirname							 :shell:
** bash
*** get file name extension and get main file name
    echo ${fi e##*.}
    echo.${file%.*}
*** echo -e
    echo -e "\n" == echo $'\n'
*** environment variable
**** $RANDOM
**** $SECONDS
**** $!
**** $?
**** $$
**** $PP ID
**** $PWD
**** $LOGNAME
**** $@ $* $#
**** $UID
**** $IFS  +-+
**** $BASH_+-+SHELL
***  $TMO+-------+
*** u tim|       |
*** type |       |
*** wait |       |
*** $! $$+-------+
*** trap
*** eval
*** size
*** []
*** [[]]
*** (())
    a=$((a+1))
*** ()
    子shell
*** {;}
    非子shell
*** test
*** typeset
    typeset -i a
    a=16#e
    echo $a  #14
*** >&- <&-
*** unset
*** reset
*** alias
*** unalias
*** pushd popd
*** jobs fg bg
*** exec
     exec - execute commands and open, close, or copy file descriptors
     e.g:
     - 1.sh
         exec &>/dev/null
	 ....
	 ;;redirect stdin and stdout to /dev/null in 1.sh
     - exec ls
       replacing the current shell with `ls`

*** log
    - last
    - lastlog
    - fingure
** convmv
** dnotify
** expect
** gdb
   http://sourceware.org/gdb/current/onlinedocs/gdb_toc.html
*** gcc -g3
*** j
*** gcore
*** core
*** file
*** r
*** set
**** args
**** follow-fork-mode
**** detach-on-fork,fork
*** until
    execute until the program reached a source line greater than the current
*** fin,ret
*** c
*** call
*** corefile
    corefile core.1982
*** catch
*** tb,rb,b,en,dis
*** w,rw
*** d
*** n,s
*** catchpoint,restart
*** ni,si
*** f,up,down,bt
*** p,x
** git
*** magit
    The best emacs git extension
    http://philjackson.github.com/magit/magit.html
*** topgit
    git extension for patch queue management
*** ref
    - Git Community Book
    - Pro Git
** grep
*** grep/egrep 中如何匹配tab					       :grep:
    - input tab with ^v^i(control-v control-i)
    - grep $'\t' file
*** grep常用的选项						       :grep:
    - C NUM 显示出匹配行附近的 NUM 行上下文。
    - n 显示行号。
    - H 显示文件名。这两个选项对于在一大堆文件里面搜索东 西非常有用。
    - o 只显示匹配的部分，这对于从一大堆东西中提取某些特殊信息非常有用。
    - i 忽略大小写
    - v 反向匹配，即显示不匹配的行。
** hdparm							      :sysadmin:
** hostname /etc/hostname
** iconv
** inittab
   http://publib.boulder.ibm.com/infocenter/systems/index.jsp?topic=/com.ibm.aix.files/doc/aixfiles/inittab.htm
   - 使一个程序cmd运行,并且程序退出后自动重启
     mycmd:2:respawn:cmd && telinit q
** ion
*** 修改mod_query.warn()和mod_query.message()使warn和message过一段时间自动cancel
    [[file:~/setup/ion-3-20080207/mod_query/mod_query.lua::function%20mod_query%20warn%20mplex%20str][mod_query.warn]]
** ion3									  :util:
** lsof								      :sysadmin:
** mc									  :util:
** meld
** mutt
*** mutt中用search命令(/,M-b,l..)时经常segment fault?
    ./configure --with-regex
** nc
** rename								 :shell:
** screen								  :util:
*** 改变encoding
    C-o : encoding utf8
*** 保存screen的输出
    C-o [进入scroll模式，用C-p,C-n移动到要保存的区域的开始，按SPACE，然后移动到要保   存的区域的结束，按Y，区域被保存到paste buffer中,按C-o ]就可以调出paste buffer的   内容

** shc
   shc -- generic shell script compiler
** ssh
** tac
** tex
** tilda								  :util:
** ulimit							      :sysadmin:
** watch
   make any command has top-like output
** wmctrl								  :util:
** x remote display
   默认情况下X server不会在tcp上监听,需要修改/etc/X11/xinit/xserverrc
   将其中的 -nolisten tcp删掉

** xmodmap								  :util:
   查询系统有哪些可用的keysym: /usr/share/X11/xkb/symbols
** xset
** 画图
*** ditaa
*** rrdtool
*** gimp
*** graphivz 静态图,适合图拓朴图,调用图等
*** imagemagick
**** display
**** import
**** import全屏截图
     import -window root -pause 2 1.jpg
*** ubigraph
* Emacs
** align
** c-macro-expand C-c C-e
** check-parens
** Completion
*** AutoComplelete & AutoJavaComplete
*** YASnippet
** cua-mode & column-edit mode
** delete-blank-lines
   C-x C-o
** delete-trailing-whitespace
** dired
   - A 对m的文件进行查找，按M-,找下一个,可以用来代替 find-grep-dired
   - Q 对m的文件执行C-M-%,按M-,替换下一个
   - find-grep-dired
   - grep-find
** ediff
   - ediff-suspend && eregistry
** eim
   可以在EMACS中使用的输入法
** eshell
** fill
   - fill-column
     C-x f
   - fill-prefix
     C-x i
   - fill-paragraph
   - auto-fill-mode
   - refill-mode
** find-file时的默认起始路径？
   M-x cd
** flush-lines keep-lines
** flyspell-mode
** foo_bar 如何作为两个word?
   默认情况下"_"被看作是word的一部分,用 modify-syntax-entry可以告诉emacs把某些字
   符做为word分隔符,做为注释的开始,做为 parenthesis的开始等.
   (modify-syntax-entry ?_ "_") 告诉emacs把 _ 做为 symbol constituent 就可以了
** highlight-changes-mode
** highlight-regexp
** how to replace \n
   query-replace C-q C-j
** ibuffer
** ido
** list-colors-display
** M-spc M-\
** occur
   M-s o
** org-mode
   - org-edit-src-code C-c '
** re-builder
** rectangle操作
   C-x r t,C-x r k,C-x r o
   C-x r x,C-x r i 剪贴板
** reverse-region,sort-lines,sort-columns
** scroll-all-mode
** toggle-truncate-lines
** undo-tree-mode
** unix2dos & dos2unix
  - dos2unix
   C-x RET f unix
  - unix2dos
   C-x RET f dos
** untabify
** 如何把2,3,4替换成3,4,5..
   Q:
   比如
   xxx 1 xx
   xxx 2 xxx
   替换成
   xxx 2 xx
   xxx 3 xx
    
   A:
   C-M-% [0-9]+ RET \,(+ \#& 1) RET
    
   ps:C-h f query-replace-regexp
    
   In interactive calls, the replacement text can contain `\,'
   followed by a Lisp expression.  Each
   replacement evaluates that expression to compute the replacement
   string.  Inside of that expression, `\&' is a string denoting the
   whole match as a string, `\N' for a partial match, `\#&' and `\#N'
   for the whole or a partial match converted to a number with
   `string-to-number', and `\#' itself for the number of replacements
   done so far (starting with zero).

** 寄存器操作
   C-x r SPC,C-x r j 保存位置，跳回
   C-x r m,C-x r b 保存bookmark,打开bookmark
   C-x r w,C-x r j 保存window配置，恢复window配置
** 插入行号
   C-u M-|
   cat -n

* lisp及函数式语言						    :ARCHIVE:
** 严格的函数式语言的特点
   http://en.wikipedia.org/wiki/Functional_program
   - 没有副作用 (no side effect) (没有IO,赋值语句等)
   - 词法闭包 (lexical closure)
   - 高阶函数 (返回函数的函数,high order function) 或者 first class function (函数作为一级对象)
   - 惰性求值 (lazy evaluation)
** 函数式编程的优点
    [[file:why-fp-matters-zh.pdf][file:~/why-fp-matters-zh.pdf]]
    使用惰性求值求解平方根:
#+BEGIN_EXAMPLE
    (defun within (N sq eps)
    (if (< (- N (expt (car sq) 2)) eps)
    (car sq)
    (within (N (cdr sq) eps))
    )
    )
    (defun repeat (N sq)
    (setq sq (/ (+ sq (/ N sq)) 2))
    (cons sq (repeat N sq))
    )
    (within 4.0 (repeat 4.0 1) 0.1)
#+END_EXAMPLE
    可惜这段代码在emacs不能工作,因为elisp不支持惰性求值...

** what is lexical closure(词法闭包)?
   http://www.ibm.com/developerworks/cn/linux/l-cn-closure/?ca=drs-tp2808
   http://en.wikipedia.org/wiki/Lexical_closure

   elisp不支持词法闭包!
#+BEGIN_EXAMPLE
   (defun make-add (n)
   (function (lambda (m) (+ n m))))  ; Return a function.

   (fset 'add2 (make-add 2))  ; Define function add2
   (add2 4)  =>  error: (void-variable n)

#+END_EXAMPLE
* Perl
** script name
   $0
** argv
   @ARGV[0] is the first command line argument
** match
#+BEGIN_EXAMPLE
   @all_matches=($string=~/(match_pattern)/g);
   my ($match1,$match2)=($string=~/(match_pattern1)(match_pattern2)/);
#+END_EXAMPLE
** file
#+BEGIN_EXAMPLE
   open LOG,"<log_file";
   for (<LOG>) {
     print "$_";
   }
#+END_EXAMPLE
* C								    :ARCHIVE:
#+CATEGORY:C
** static变量不要写在头文件中
   通常static变量在头文件中是错误的, 除非多个编译单元真的想各自使用独立的该变量
** void参数与空参数
   引用网址：http://david.tribble.com/text/cdiffs.htm#C99-func-vararg

   “
   Empty parameter lists

   C distinguishes between a function declared with an empty parameter list and
   a function declared with a parameter list consisting of only void. The former
   is an unprototoped function taking an unspecified number of arguments, while
   the latter is a prototyped function taking no arguments.

    // C code

#+BEGIN_EXAMPLE
    extern int  foo();          // Unspecified parameters
    extern int  bar(void);      // No parameters

    void baz()
    {
        foo(0);         // Valid C, invalid C++
        foo(1, 2);      // Valid C, invalid C++

        bar();          // Okay in both C and C++
        bar(1);         // Error in both C and C++
    }
#+END_EXAMPLE
    C++, on the other hand, makes no distinction between the two declarations
    and considers them both to mean a function taking no arguments.

    // C++ code

#+BEGIN_EXAMPLE
    extern int  xyz();
    extern int  xyz(void);  // Same as 'xyz()' in C++,
                            // Different and invalid in C
    For code that is intended to be compiled as either C or C++, the best solution to this problem is to always declare functions taking no parameters with an explicit void prototype. For example:

    // Compiles as both C and C++
    int bosho(void)
    {
        ...
    }
#+END_EXAMPLE
    Empty function prototypes are a deprecated feature in C99 (as they were in C89).

    即 在c中,void f()表示参数个数未指定,而不是表示无参数,表示无参数要使用void f(void)
    在c++中,void f()和void f(void)是一样的.

    即 尽量使用void f(void) 而不要使用void f()

    --
    发信人: sunway (sunway), 信区: CPP
    标  题: Re: 关于函数参数个数的问题
    发信站: 北邮人论坛 (Wed Oct 14 13:01:02 2009), 站内

    gcc确实能编译过去...神奇
    一般情况下不会错误,gcc默认使用cdecl调用约定,调用者会负责清理栈上的参数,但如果使
    用了stdcall,被调用的f不知道有参数要清理,而调用者又认为f会清理参数...然后就有问题
    了,比如:

#+BEGIN_EXAMPLE
    void  __attribute__((stdcall)) f (int a,int b) {
        f (1,2);
    }

    int main()
    {
        f(1,2);
	return 0;
    }
#+END_EXAMPLE

    【 在 SuperBrother (xiaohui) 的大作中提到: 】
    : 标  题: 关于函数参数个数的问题
    : 发信站: 北邮人论坛 (Wed Oct 14 11:29:31 2009), 站内
    :
    : void f() {}
    : void g(int a) {}
    :
    : int main()
    : {
    :     f(1);
    :     //g(1, 1);  编译不过，提示参数个数过多
    :     return 0;
    : }
    :
    : 用的是GCC 4.2.4
    : 想问问为啥f(1)能过，而g(1, 1)不能？
    : 另外，假设f()不用参数就能完成相应功能，调用f(1)会引起运行时错误吗？
    : --
    :
    ※ 修改:·sunway 于 Oct 14 13:02:34 修改本文·[FROM: 2001:da8:215:1800:211:11ff:
    : ※ 来源:·北邮人论坛 http://forum.byr.edu.cn·[FROM: 2001:da8:215:5200:0:5efe:
** switch与跳转表
#+BEGIN_EXAMPLE
int
main (int argc, char * argv[]) {
    int a=0;
    switch (a) {
    case 1:
	printf ("%d\n",a);
	break;
    case 2:
	printf ("%d\n",a);
	break;
    case 3:
	printf ("%d\n",a);
	break;
    case 11:
	printf ("%d\n",a);
	break;
    case 100:
	printf ("%d\n",a);
	break;
    case 13:
	printf ("%d\n",a);
	break;
    case 4:
	printf ("%d\n",a);
	break;
    case 5:
	printf ("%d\n",a);
	break;
    case 6:
	printf ("%d\n",a);
	break;
    case 7:
	printf ("%d\n",a);
	break;
    case 8:
	printf ("%d\n",a);
	break;

    default:
	printf ("%d\n",a);
	break;
    }
    return 0;
}
#+END_EXAMPLE
当case分支较少时,和if..else一样,通过一系列cmp,je..跳转.
当case分支较多时,会根据情况生成一个跳转表,如:
#+BEGIN_EXAMPLE
        movl    -24(%ebp), %edx
        movl    .L14(,%edx,4), %eax
        jmp     *%eax
        .section        .rodata
        .align 4
        .align 4
.L14:
        .long   .L2
        .long   .L3
        .long   .L4
        .long   .L5
        .long   .L6
        .long   .L7
        .long   .L8
        .long   .L9
        .long   .L10
        .long   .L2
#+END_EXAMPLE
.L14就是跳转表的入口, %eax是分支在表中的偏移,如case为100,则其偏移量为100*4(因为每个表项为4字节)
这时存在一个问题是:如果case值范围过大,比如一共100个case,但有一个case的值为1000,则表中有900个项需要用default分支的地址去填充,浪费空间.
所以gcc在这种情况下又会转而使用原始的cmp,je..跳转.

** volatile keyword in C
#+BEGIN_EXAMPLE
   int main(int args, char **argv)  {
       char x, y, z;
       int i;
       int a[16];

       for(i=0; i<=16; i++) {
           a[i] = 0;
           printf("%d\n", i);
       }
       return 0;
   }
#+END_EXAMPLE

   1. 程序正常终止,打印出0-16
   2. 在 int i; 前加上 volatile, 死循环

   Volatile is an ANSI C type modifier that is frequently needed in C code that
   is part of signal/interrupt handlers, threaded code, and other kernel code,
   including device drivers. In general, any data that may be undated
   asynchronously should be declared to be volatile. Incidentally, this issue is
   not related to CPU caches except that re-loading of variables into registers
   may involve cache hits or misses.

   Why Use Volatile?  The reason to use volatile is to insure that the compiler
   generates code to re-load a data item each time it is referenced in your
   program. Without volatile, the compiler may generate code that merely re-uses
   the value it already loaded into a register.

   Volatile advises the compiler that the data may be modified in a manner that
   may not be determinable by the compiler. This could be, for example, when a
   pointer is mapped to a device's hardware registers. The device may
   independently change the values unbeknownst to the compiler.


   With gcc the -O2 option is normally required to see the effect of not using
   volatile. Without -O2 or greater optimization, the compiler is likely to
   re-load registers each time a variable is referenced, anyway. Don't blame the
   optimizer if a program gets incorrect results because the program does not
   use volatile where required.

   For example, if two threads share a variable, sum, and one or both threads
   modify it, then the other thread may use a stale value in a register instead
   of going back to memory to get the new value. Instead, each time the thread
   references sum, it must be re-loaded. The way to insure this occurs in ANSI C
   is to declare sum to be volatile.

   Example: The use of volatile can be required to get correct answers. For
   example the program wrong will give incorrect results when it is compiled -O2
   and without volatile. This slightly obtuse program is designed to stop after
   100 ticks of an interval timer that ticks at 100Hz and print the value of the
   variable total. The tick count is incremented in the signal handler. When the
   count gets to 100, the program should terminate. If the tick count does not
   get to 100 within 10 seconds then an alarm goes off and the program
   terminates.

   By compiling the program as: gcc -O2 -DVOLATILE=volatile wrong.c -o wrong_v
   you will see, (unless your program is preempted for quite a while), that the
   count gets to 100 and the program terminates as designed. With the program
   compiled as gcc -O2 wrong.c -o wrong_nv you will see, that the count becomes
   greater than 100 as shown when the handler prints it, but, the while loop
   does not terminate.

   Incidentally, attempts to determine what is happening may thwart your
   efforts. For example, a function call, such as to printf(), or the use of a
   breakpoint, in the loop, will likely spill and re-load the registers.


   http://en.allexperts.com/q/C-1587/volatile.htm
   http://www.netrino.com/node/80

** 栈对齐 stack align
#+BEGIN_EXAMPLE
  int
  main (int argc, char * argv[]) {
     int a=9;
     double b=0;
     char * c=&b;
     printf ("%d\n",*(int *)(c+8));
     return 0;
  }
#+END_EXAMPLE
  c+8后才是a的地址,而不是c+4

  gcc保证,对于8 bytes的类型如double,在栈上是8字节对齐的

  On the Pentium and subsequent x86 processors, there is a substantial
  performance penalty if double-precision variables are not stored 8-byte
  aligned; a factor of two or more is not unusual. Unfortunately, the stack (the
  place that local variables and subroutine arguments live) is not guaranteed by
  the Intel ABI to be 8-byte aligned.

  Recent versions of gcc (as well as most other compilers, we are told, such as
  Intel's, Metrowerks', and Microsoft's) are able to keep the stack 8-byte
  aligned; gcc does this by default (see -mpreferred-stack-boundary in the gcc
  documentation). If you are not certain whether your compiler maintains stack
  alignment by default, it is a good idea to make sure.

  Unfortunately, gcc only preserves the stack alignment—as a result, if the
  stack starts off misaligned, it will always be misaligned, with a disastrous
  effect on performance (in double precision).

  http://www.fftw.org/doc/Stack-alignment-on-x86.html

** gcc -E
** 结构体的 struct A a={.a=1,.b=2};形式的初始化
   gcc扩展:

#+BEGIN_EXAMPLE
   struct A {
     int a;
     int b;
   };

   int
   main(int argc, char *argv[]) {
     struct A a={.b=1,.a=2}; //或者 struct A a={2,1};
     printf ("%d %d\n",a.a,a.b);
     return 0;
   }
#+END_EXAMPLE

** do {} while (0)
   http://c2.com/cgi/wiki?TrivialDoWhileLoop
** char * str[MAXSIZE]
   当打算将strlen是n的字符串存入str时，要分配n+1个char的空间，因为结尾的'\0'不包括在strlen里
** scanf
*** %n
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%d%n",&a,&b)
    #>./a.out
    1234
    a=1234 b=4
#+END_EXAMPLE
*** %[]

*** %*
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%*d%n",&a);
    #>./a.out
    1234
    a=4
#+END_EXAMPLE
*** 空白字符的处理
    空白字符包括 空格,tab,\n
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%d",&a);
    scanf("%d",&b);
    #>./a.out
    1234 123
    a=1234,b=123
#+END_EXAMPLE
    实际上,第一个scanf执行后,输入流里还有一个\n,但是,下一句scanf用%d做参数时,会忽略输入流开头的空白字符.
    大多数%..会忽略开头的空白字符,但以下几个除外:
    %c,%[]
    所以:
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%d",&a);
    scanf("%c",&b);
    #>./a.out
    1234
    a=1234,b=134513674
#+END_EXAMPLE
    b没有要求输入值,而是直接用的流中剩余的\n,对于%c,%[]这种情况,需要手工用%s忽略开头的空白字符,如:
#+BEGIN_EXAMPLE
    int a,b;
    scanf("%d",&a);
    scanf("%*[ \t\n]%c",&b);
#+END_EXAMPLE

*** 回车的作用
    回车用来表示将输入提交到输入流中,但回车本身也会被正常放在输入流中,所以
    scanf("%d\n",&a) 也是可以被匹配的
*** scanf类型不匹配时死循环?
#+BEGIN_EXAMPLE
    int a;
    label:
    scanf("%d",&a);
    goto label;
#+END_EXAMPLE
    若输入不为整数,如'a',则后面的scanf会被跳过,死循环
    原因:
    scanf类型不匹配时,scanf失败,不匹配的数据仍然留在输入流中,必须用%*..丢弃这些错误的数据.
#+BEGIN_EXAMPLE
    int a;
    label:
    scanf("%d",&a);
    scanf("%*s");
    goto label;
#+END_EXAMPLE

** scanf中的%s与%[]
scanf ("%s,%d",a,&b);
然后输入 abc,2,打印a的值是 abc,2 ,不是abc,就是说%s会贪婪的吞掉它后面所有的输入,
除非你输入空格让它停止

s

Matches  a sequence of non-white-space characters; the next pointer must be
a pointer to character array that is long enough to hold the input sequence
and  the  terminating  null character ('\0'), which is added automatically.
The input string stops at white  space  or  at  the  maximum  field  width,
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[ \t\n]+
whichever occurs first.


如果你确实喜欢用abc,2这种形式输入,可以试试这个:
scanf("%[^,]%d",a,&b);
比较爽

我觉得%s可能就是%[^ \t\n]吧

** c中的声明与定义
   在1.c和2.c两个文件中,

以下情形时编译正确:
#+BEGIN_EXAMPLE
   |----------------+----------------|
   | 1.c            | 2.c            |
   |----------------+----------------|
   | int a          | int a          |
   | int a          | char a         |
   | int a          | extern int a   |
   | int a          | extern char a  |
   | int a=2        | char a         |
   | int a=2        | int a          |
   | static int a=2 | static int a=1 |
   |----------------+----------------|
#+END_EXAMPLE

以下情形时出错:
#+BEGIN_EXAMPLE
   |---------+----------|
   | 1.c     | 2.c      |
   |---------+----------|
   | int a=2 | int a=3  |
   | int a=2 | char a=3 |
   | int a=2 | int a=2  |
   |---------+----------|
#+END_EXAMPLE
结论:
   没有赋值的定义如 int a 和 声明 extern int a 一样,可以声明多次,类型也可以不同(虽然这是个错误)
   赋值的定义只能定义一次
   static的定义和声明不干扰
即:没赋值的可以随便写,赋值的只能写一次.extern关键字没有用.
** DONE compile time assert						:ATTACH:
   CLOSED: [2008-11-03 一 16:13]
   - State "DONE"       [2008-11-03 一 16:13]
   :PROPERTIES:
   :Attachments: compile-time-assertions_1.pdf
   :ID:       7xl4i9z0ife0@sunway-lab.bupt.edu.cn
   :END:
   #define ASSERT_STATIC(e) char UXXX[(e)-1]

** DONE C Preprocessor -- the whole story
   CLOSED: [2008-11-03 一 16:15]
   - State "DONE"       [2008-11-03 一 16:15]
   http://developer.apple.com/documentation/DeveloperTools/gcc-4.0.1/cpp/
   http://en.wikipedia.org/wiki/C_preprocessor
   http://blog.chinaunix.net/u1/41845/showart_446562.html

* C++
#+CATEGORY:C++
** c++容器当pop元素时元素如果被自动析构
   Test t;
   vector<Test> v;
   v.push_back(t);
   v.pop_back();
   v pop_back时,容器中相应的元素(t的拷贝)被自动析构.
   但
   Test * t=new Test;
   v.push_back(t);
   v.pop_back()时,t指向的元素却并不会被析构.
   同样,若vector中元素为其它内置类型也,也不可能被自动析构

   vector的源码中,
   pop_back() {
   __M_content;
   destroy(..);
   }
   而destroy(p)只是简单的调用 p->~T()

   为了容器的一致,C++规定,内置类型的析构也能编译通过,但这些析构实际上什么也不做,
   即当T为int时,p->~int()也能编译通过,指针也属于内置类型,所以容器中为指针时,也能
   编译通过,但析构时实际上什么也不做.

   从上面vector的代码中也可以看到,vector pop_back时并不释放内存,而list与此不同:
   list的pop_back大致为:
   destroy();
   deallocate();
   ..
   其中deallocate负责释放内存

   上面提到的destroy,deallocate,还有allocate,construct都是容器的allocator的功能,
   可以自己重写一个allocator,实现不同的allocate,deallocate,construct,destroy行为,然后把
   新的allocator做为容器的模板参数

** c++引入引用的最根本原因
   c++引入引用,是因为容器的存在.

   对比C语言中经典的容器:数组. 数组可以保存各种类型,包括内置类型,自定义struct等,
   如array[0]=structA,则后面array[0].value1=1时,即是修改structA,数组的[]是C内置运
   算符,不存在array[0]取得的是structA的拷贝的问题

   但在c++中,容器类的[],at,get...都是函数,如vector<struct> v; v[0]=structA;
   v[0].value=1;若operator[]直接返回struct类型,而不是引用或指针,则v[0].value=1修
   改的实际上是structA的拷贝.所以C++的容器类的getter,为了与c语义上的一致,都是返回
   引用.如果没有引用,C++容器只能设计成必须存储指针类型

   另外,用c写的glib中容器,如garray,getter都是使用宏来完成的,宏可以认为是
   return-by-name, 和引用的效果类似.如 #define g_array_index(a,t,i) (((t*) (void
   *) (a)->data) [(i)]), a是array,t是容器中成员类型,i是偏移量

   综上:容器类的getter方法都是函数调用,为了避免return-by-value,使用了 return-by-name

** operator->()								:ATTACH:
   :PROPERTIES:
   :Attachments: 1.cpp
   :ID:       shn19b504ie0@sunway-lab.bupt.edu.cn
   :END:
   operator->()用来使某个类像指针,如iteraotr

** [23.11] How can I set up my class so it won't be inherited from?	:ATTACH:
   :PROPERTIES:
   :Attachments: virtual.cpp
   :ID:       4to2d6y03ge0@sunway-lab.bupt.edu.cn
   :END:
   This is known as making the class "final" or "a leaf." There are three ways
   to do it: an easy technical approach, an even easier non-technical approach,
   and a slightly trickier technical approach.

   The (easy) technical approach is to make the class's constructors private and
   to use the Named Constructor Idiom to create the objects. No one can create
   objects of a derived class since the base class's constructor will be
   inaccessible. The "named constructors" themselves could return by pointer if
   you want your objects allocated by new or they could return by value if you
   want the objects created on the stack.

   The (even easier) non-technical approach is to put a big fat ugly comment
   next to the class definition. The comment could say, for example, // We'll
   fire you if you inherit from this class or even just /*final*/ class Whatever
   {...};. Some programmers balk at this because it is enforced by people rather
   than by technology, but don't knock it on face value: it is quite effective
   in practice.

   A slightly trickier technical approach is to exploit virtual
   inheritance. Since the most derived class's ctor needs to directly call the
   virtual base class's ctor, the following guarantees that no concrete class
   can inherit from class Fred:

#+BEGIN_EXAMPLE
   class Fred;

   class FredBase {
   protected:
     FredBase() { }
   };

   class Fred : private virtual FredBase {
   public:
   ...
   };
#+END_EXAMPLE

   Class Fred can access FredBase's ctor, since Fred is deprived from FredBase,
   but no class derived from Fred can access FredBase's ctor (note 1),and therefore no
   one can create a concrete class derived from Fred.

   note 1:
   'no class derived from Fred can access FredBase's ctor' need 3 constrains be considered:
   1. FredBase() must be
      case1: protected and Fred derives from Fred or
      case2: FredBase() is private , Fred derived from FredBase and is a friend of Fred
   2. Fred must private inherits from FredBase on case 1 or protected inherits from FredBase on case 2
   3. virtual inherits is a must for Fred, because:

      When a base class is inherited virtualy, it is up to the *most derived*
      class to initialize it.

      in our case, if class F deprived from Fred, it's F's duty to initialize Fred, which is impossible since
      Fred's ctor is not accessable.

      about virtual inheritance, check attached virtual.cpp

#+BEGIN_EXAMPLE
      ~@sunway-lab> ./a.out
      ctor for FredBase called
      ctor for Fred called
      ctor for Fred2 called
#+END_EXAMPLE

** never throw exceptions in dtor
[17.3] How can I handle a destructor that fails?

Write a message to a log-file. Or call Aunt Tilda. But do not throw an exception!
Here's why (buckle your seat-belts):

The C++ rule is that you must never throw an exception from a destructor that is
being called during the "stack unwinding" process of another exception. For
example, if someone says throw Foo(), the stack will be unwound so all the stack
frames between the throw Foo() and the } catch (Foo e) { will get popped. This
is called stack unwinding.

During stack unwinding, all the local objects in all those stack frames are
destructed. If one of those destructors throws an exception (say it throws a Bar
object), the C++ runtime system is in a no-win situation: should it ignore the
Bar and end up in the } catch (Foo e) { where it was originally headed? Should
it ignore the Foo and look for a } catch (Bar e) { handler? There is no good
answer — either choice loses information.

So the C++ language guarantees that it will call terminate() at this point, and
terminate() kills the process. Bang you're dead.

The easy way to prevent this is never throw an exception from a destructor. But
if you really want to be clever, you can say never throw an exception from a
destructor while processing another exception. But in this second case, you're
in a difficult situation: the destructor itself needs code to handle both
throwing an exception and doing "something else", and the caller has no
guarantees as to what might happen when the destructor detects an error (it
might throw an exception, it might do "something else"). So the whole solution
is harder to write. So the easy thing to do is always do "something else". That
is, never throw an exception from a destructor.

Of course the word never should be "in quotes" since there is always some
situation somewhere where the rule won't hold. But certainly at least 99% of the
time this is a good rule of thumb.

** what is type-safe and strong type
   http://hi.baidu.com/chenfalei/blog/item/f33ac0133500ac21dd540186.html
   没有绝对的类型安全与强类型语言。类型安全都是相对的。
   比如C/C++基本的类型检查保证了一部分的类型安全，但它的 union/指针/强制转换/数组 却破坏了类型安全。
   绝对的类型安全是指：一旦程序通过编译，即不再存在除逻辑错误外的其他错误。
** why pop_back returns void instead of the removed object?
   - The SGI's docs contain the reasoning - it's from queue's documentation
     but it also applies for deque:
     "One might wonder why pop() returns void, instead of value_type. That
     is, why must one use front() and pop() to examine and remove the
     element at the front of the queue, instead of combining the two in a
     single member function? In fact, there is a good reason for this
     design. If pop() returned the front element, it would have to return
     by value rather than by reference: return by reference would create a
     dangling pointer. Return by value, however, is inefficient: it
     involves at least one redundant copy constructor call. Since it is
     impossible for pop() to return a value in such a way as to be both
     efficient and correct, it is more sensible for it to return no value
     at all and to require clients to use front() to inspect the value at
     the front of the queue."
   - exception safety
     假设 pop_back()定义为：
#+BEGIN_EXAMPLE
     T topValue=vector1.pop();

     T pop_back() {
         T temp=vec[top];
	 --top;
	 return temp; // what about if the copy assignment or copy constructor of temp->topValue fails?
     }
#+END_EXAMPLE

** 数组蜕化为指针及数组引用做为函数参数

#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

void f (int (& a) [10]) {
    cout<<a[0]<<endl;
    cout<<sizeof(a)<<endl;
}
void g (int a []) {
    f (a);
}
int
main(int argc, char *argv[]) {
    int a[10]={9};
    g (a);
    return 0;
}
#+END_EXAMPLE
编译错误

#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

void f (int (& a) [10]) {
    cout<<a[0]<<endl;
    cout<<sizeof(a)<<endl;
}
int
main(int argc, char *argv[]) {
    int a[10]={9};
    f (a);
    return 0;
}
#+END_EXAMPLE
编译正确

可见,数组作为参数会蜕化为指针,但数组引用做为参数不会
** c++ template 链接问题					   :template:模板:
   or 为什么c++ template的声明和定义通常在同一个文件,而不把定义单独编译成目标文件
   因为c++ template is instantiated at compile time.
   http://en.wikibooks.org/wiki/C%2B%2B_Programming/Template
** The Standard Librarian: Containers of Incomplete Types
   http://www.ddj.com/database/184403814
** 临时对象的const引用						   :引用:const:常量:
   string foo() {return string("abc");}
   const string & a=foo();
   是合法的,这是C++对大量存在的 foo (const & T) 类型的函数的折衷
   string & a=foo()是非法的
   类似的,对于foo("abc")的调用,void foo(const string & s)是合法的,void foo(string & s)是非法的,除非
   string a("abc");string & b=a; foo(b);

   虽然c++要求返回的临时对象的引用必须是const,但在gcc里,复杂对象通常都是用
   named-return-value,所以返回的临时对象实际上必然在调用者的栈中,所以

#+BEGIN_EXAMPLE
   main (int argc, char * argv[]) {
    const T & t=fun ();
    T & tt=const_cast<T &>(t);
    tt.a=19;
    printf ("%d\n",t.a);
    return 0;
    }
#+END_EXAMPLE
    并没有问题
    main的栈:
    临时对象a
    引用t的指针,指向临时对象a

** bitwise copy
   http://blogs.msdn.com/slippman/archive/2004/01/20/60655.aspx
   http://www.cppblog.com/jerysun0818/archive/2006/05/05/6632.html

   In practice, a good compiler can generate bitwise copies for most class objects since they
   have bitwise copy semantics….
   That is, a copy constructor is not automatically generated by the compiler for each class that
   does not explicitly define one.

   Default constructors and copy constructors…are generated (by the compiler) where needed.
   Needed in this instance means when the class does not exhibit bitwise copy semantics
   When are bitwise copy semantics not exhibited by a class? There are four instances:

   1. When the class contains a member object of a class for which a copy constructor exists
      (either explicitly declared by the class designer, as in the case of the previous String
      class, or synthesized by the compiler, as in the case of class Word)
   2. When the class is derived from a base class for which a copy constructor exists (again,
      either explicitly declared or synthesized)
   3. When the class declares one or more virtual functions
   4. When the class is derived from an inheritance chain in which one or more base classes are virtual


   如果一个类的成员中有指针成员，如果它又有bitwise copy semantics(如无虚函数，成
   员类没有定义copy constructor..),默认会使用bitwise copy,但是对指针做shadow
   copy在对象析构时指针成员可能会被多次delete,所以对于这个类要自定义copy
   constructor使其丧失bitwise copy semantics

** 可怜的bool
发信人: Oversense (空), 信区: CPlusPlus
标  题: 可怜的bool
发信站: BBS 水木清华站 (Mon Oct 21 17:53:11 2002), 转信

可怜的bool

作者: Jim Hyslop 和 Herb Sutter
翻译：oversense <17:33 2002-10-21>
出处: http://www.cuj.com/experts/2011/hyslop.htm?topic=experts

嘿嘿...今天的活比较爽！前几天写了点破程序，今天改改就搞定了。
哎，真困！喝点咖啡，靠在我的小椅子上，看看我的代码...

神奇，这是啥？
void f()
{
 TextHandler t;
 t.sendText("Hello, world", true);
// ...
}

后面那个true是什么东东？翻翻定义:
class TextHandler
{
public:
 void sendText( const std::string & msg,
                bool sendNewLine );
//...
};

喝点coffee，我想起来了，true表示sendText函数自动加上一个回车换行，我怎
么忘了？难道是我笨？我陷入迷茫的沉思...

砰！！！的一声巨响，我一慌张，嘴里的咖啡差点喷出来，还好我嘴紧。一定是Guru合上
了她的什么大头书。我转向她，挤出一点微笑。她手里拿着一本不到一百页的小册子。
神奇，这么小的书弄得这么响，她是怎么弄得？

显然，她什么都知道了。

"我的宝贝！如果你这么快就忘了参数的含义，那么当其他程序员第一次看你的代
码的时候，他怎么明白你要表达的意思呢？"

"嗯，是啊" 我咕噜道 "但是在IDE里面，他只要把鼠标移到函数上，他就可以看
到参数说明了啊！"

"有些IDE如此，并非全部，甚至不是大多数！我说过很多次，源代码最主要的用途
是用来交流，对意图的交流。我手中这本古老的，令人尊敬的卷册阐述了交流的艺术。
在这儿，它写道，'使用明确，详细，具体的语言'[1]，你代码中的bool与此无缘，
他不能传递任何有用的信息给读者。 "

"不哈，一旦他知道这个bool是什么意思，就很容易记住了哈！"我中气不足的说。

Guru用她美丽而坚定的蓝眼睛盯着我，我心里扑通扑通跳起来。

"你多久以前写的这段代码？"Guru很温柔的说道--那种我喜欢的温柔。
"嗯，好，嗯，那如何改正呢？"我巧妙的回避她的问题。
"你不能另外想一种方式去表达你的意图吗？"她也不直接回答我，我们就好像在
煎鸡蛋。

"我可以不要第二个参数，让用户自己加 '\n' 好了。"我边说边写:
{
 t.sendText("Hello, world\n");
}
"如果传递给sendText是一个变量呢？" Guru问。
"那就这样好了"
{
 t.sendText( variable );
 t.sendText( "\n" );
}
我抬头看到Guru脸色不善，赶紧说道:
"那就这样，我提供两个函数"
void sendText( const std::string & );
void sendTextWithNewLine( const std::string & );

"没有其他的办法了吗？"Guru思考的时候，微微皱眉。
哎，看来我今天不要想轻松溜走了，我一阵猛想......什么也没想出来，我投降
了，"就这样吧！"

"关于你的问题，你还要认识一点" Guru写道:
void displayText( const std::string &,
                  bool applyItalics,
                  bool applyBold );
void f(){
    displayText( "This is bold but not italic",true, false );
}
"如果一个程序员要用斜体显示文字，但是弄错了参数顺序，那么这些文字就要用
粗体显示了，而且显然编译器无法发现这个错误。"

"如果Bob拿到了这段代码，改变了参数的顺序，一种叫做'Permute And Baffle'
的技术[2]。会怎样？"

"显然，问题多多的displayText不能得到 '明确，详细，具体' 的参数。"

"现在来看你的问题，你的第一个方案，因为displayText需要其他参数而没法用
。你的第二个方案，
可以工作，但是如果displayText需要很多信息，比如颜色，字体等，你是不是要
提供如此多的函数呢？"

"所以，我们可以用enumerated."
"Enumerations?"我奇怪的说。

"是的，Enumerations在这儿能得到很好的应用，看，"
class TextHandler
{
public:
 enum NewLineDisposition { sendNewLine, noNewLine };
 void sendText( const std::string &, NewLineDisposition );
};
void f()
{
 TextHandler t;
 t.sendText( "Hello, ", TextHandler::noNewLine );
 t.sendText( "world", TextHandler::sendNewLine );
}
"这种写法很好，这段代码现在self-documenting了，不需要注释，意图和结果都
很清楚。看得人不需要去查找函数的定义了。"
"而且，这种写法有很好的扩展性，如果你需要只加一个回车，你只需要在enume
ration中加上prependNewLine就可以了，现有的代码无需任何改变。"

"不要抛弃你第一个方案，宝贝。在有的情况下，他是最优的。"Guru转过身，重
新打开那本书，优雅而轻快的走开，消失在拐角处。

注解:
[1] William Strunk Jr. and E.B. White. The Elements of Style (MacMilla
n Publishing Co. Ltd,
1979).
[2] From Roedy Green's "How To Write Unmaintainable Code,"
<http://mindprod.com/unmaindesign.html>. (Primarily aimed at Java prog
rammers, it still has
lots of relevance for C++ programmers.)

** operator new							    :new:delete:
   http://www.scs.cs.nyu.edu/~dm/c++-new.html
#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

class Test {
    int val;
public:
    Test (int v):val (v) {cout<<val<<endl;}
    void * operator new (size_t size,int count) {cout<<__LINE__<<endl;return malloc (size);}
    void operator delete( void * p,size_t size ) {cout<<size<<endl;free (p);}
    //new和delete只负责分配释放内存，不负责ctor和dtor调用
};

int
main(int argc, char ** argv) {
    Test * t=new (10) Test (20);
    Test tt; //局部变量不使用operator new和operator delete
    return 0;
}
#+END_EXAMPLE
** prefrer ++i to i++
   For builtin types, it really doesn't matter. But in C++, you can write
   and operator++ for your own class. And then it might matter, becaure
   postfix ++ has to create a copy of the object so that the old value can
   be returned. If you don't need the return value, that copy is
   unnecessary. If the compiler doesn't do named return value
   optimization, that copy might even need to be copied again, and all
   that just to throw the result away. The postfix operator++ for an own
   class might look something like this:

#+BEGIN_EXAMPLE
   MyClass MyClass::operator++(int)
   {
   MyClass retval(*this); // copy the object
   // do whatever is needed to "increment" the object
   reutrn retval; // return the copy by value
   }
#+END_EXAMPLE

   while prefix ++ might look like:

#+BEGIN_EXAMPLE
   MyClass& MyClass::operator++()
   {
   // do whatever is needed to "increment" the object
   return *this; // return a refernce to the object
   }
#+END_EXAMPLE

   Therefore, it's considered a good habit to always use prefix ++ if the
   return value is not needed.

** Decorator pattern
http://en.wikipedia.org/wiki/Decorator_pattern

#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

class B {
public:
    virtual void fun () {cout<<"C"<<endl;}
};

class Dec:public B {
    B * pbase;
public:
    Dec (B * b):pbase(b) {}
    virtual void fun () {cout<<"Dec"<<endl;pbase->fun ();}
};

int
main(int argc, char ** argv) {
    B * b=new Dec(new Dec (new B));
    b->fun ();

    return 0;
}
#+END_EXAMPLE

** 一个Printable类
#+BEGIN_EXAMPLE
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
class Printable {
    virtual string to_str () const=0;
public:
    friend ostream & operator<<(ostream &,const Printable &);
};

ostream & operator<<(ostream & o,const Printable & p) {
    return o<<p.to_str ()<<endl;
}

class Test:public Printable {
    int a;
    int b;
private:
    string to_str () const {
	stringstream ss;
	ss<<a<<" ";
	ss<<b<<endl;
	return ss.str ();
    }
public:
    Test (int a,int b):a (a),b (b) {}
};
int
main(int argc, char ** argv) {
    Test t (1,2);
    cout<<t;
    return 0;
}
#+END_EXAMPLE
** 类型转换
   假设需要一个X到Y的转换：

   - Y内定义 Y(const X &) ()构造函数
   - X内定义 operator Y() {return Y;}函数

   自定义的类型转换也可以被隐式调用，
   例如 Y实现了 friend ostream & operator <<(ostream &,const Y &) 使Y可以通过 cout<<Y的
   形式调用，如果在Y或X中定义了X到Y的转换，则cout<<X时，X会被隐式的转换为Y并调用operator<<(cout,Y)
   另外，自定义的类型转换也是static_cast能否成功的根据之一
** cast
   - 'reinterpret_cast' 只能用于指针或引用'reinterpret_cast' casts a pointer to
     any other type of pointer. It also allows casting from pointer to an
     integer type and vice versa. This operator can cast pointers between
     non-related classed. The operation results is a simple binary copy of the
     value from a pointer to the other. The content pointed does not pass any
     kind of check nor transformation between types. In the case that the copy
     is performed from a pointer to an integer, the interpretation of its
     content is system dependent and therefore any implementation is non
     portable. A pointer casted to an integer enough large to fully contain it
     can be casted back to a valid pointer.

     Code:

#+BEGIN_EXAMPLE
     class A {};
     class B {};

     A * a = new A;
     B * b = reinterpret_cast<B *>(a);
#+END_EXAMPLE

     'reinterpret_cast' treats all pointers exactly as traditional type-casting operators do.

   - 'dynamic_cast' 只能用于指针或引用

     'dynamic_cast' is exclusively used with pointers and references to
     objects. It allows any type-casting that can be implicitly performed as
     well as the inverse one when used with polymorphic classes, however, unlike
     static_cast, dynamic_cast checks, in this last case, if the operation is
     valid. That is to say, it checks if the casting is going to return a valid
     complete object of the requested type. Checking is performed during
     run-time execution. If the pointer being casted is not a pointer to a valid
     complete object of the requested type, the value returned is a 'NULL'
     pointer.

     dynamic_cast使用了RTTI来确定能否转换成功,而只有支持多态的类(有虚函数)才在
     vtbl中有相应的RTTI信息,所以:
#+BEGIN_EXAMPLE
     class Base {

     };
     class Derived:public Base {

     };

     Base * b=new Derived();
     dynamic_cast<Derived *>(b)不会成功,因为没有vtbl,即没有RTTI信息

#+END_EXAMPLE

     Code:
#+BEGIN_EXAMPLE
     class Base { virtual dummy() {} };
     class Derived : public Base {};

     Base* b1 = new Derived;
     Base* b2 = new Base;

     Derived* d1 = dynamic_cast<Derived *>(b1);          // succeeds
     Derived* d2 = dynamic_cast<Derived *>(b2);          // fails: returns 'NULL'
#+END_EXAMPLE

     If the type-casting is performed to a reference type and this casting is not possible an exception of type 'bad_cast' is thrown:

     Code:

#+BEGIN_EXAMPLE
     class Base { virtual dummy() {} };
     class Derived : public Base { };

     Base* b1 = new Derived;
     Base* b2 = new Base;

     Derived d1 = dynamic_cast<Derived &*>(b1);          // succeeds
     Derived d2 = dynamic_cast<Derived &*>(b2);          // fails: exception thrown
#+END_EXAMPLE

   - 'static_cast'

     'static_cast' allows to perform any casting that can be implicitly
     performed as well as also the inverse cast (even if this is not allowed
     implicitly). Applied to pointers to classes, that is to say that it allows
     to cast a pointer of a derived class to its base class (this is a valid
     conversion that can be implicitly performed) and can also perform the
     inverse: cast a base class to its derivated class. In this last case the
     base class that is being casted is not checked to determine wether this is
     a complete class of the destination type or not. Code:
#+BEGIN_EXAMPLE
     class Base {}; class
     Derived : public Base {};

     Base *a    = new Base;
     Derived *b = static_cast<Derived *>(a);
     'static_cast', aside from manipulating pointers to classes, can also be used to perform conversions explicitly defined in classes, as well as to perform standard conversions between fundamental types:
     Code:
     double d = 3.14159265;
     int    i = static_cast<int>(d);
#+END_EXAMPLE


   - 'const_cast'

     This type of casting manipulates the const attribute of the passed object, either to be set or removed:

     Code:
#+BEGIN_EXAMPLE
     class C {};
     const C *a = new C;
     C *b = const_cast<C *>(a);

#+END_EXAMPLE
     Neither of the other three new cast operators can modify the constness of an object.
     Notes:
     It is undefined behaviour if the pointer is used to write on an constant object (an object declared as 'const').
     The 'const_cast' operator can also change the 'volatile' qualifier on a type.

     总结:
     reinterpret_cast是不懂c++语法的,也不会使用rtti信息,这就决定了它不能解析c++的类结构,如多重继承,虚拟继承这些复杂的结构.
     指针的reinterpret_cast的过程中,值是不会变的,改变的只是对这个值的处理方式(当作c的指针还是当作d的指针)

     static_cast是懂c++的语法的,它能了解编译时的ctti信息,能够在处理多重继承,虚拟继承等复杂结构.
     B
     C1:virtual B
     C2:virtual B
     D:C1,C2
     D * d=new D()能成功static_cast到B*,C1*或C2*,因为static_cast了解继承的树

     static_cast是编译时的行为,它不能正确处理的情况是:
     B
     C1:virtual B
     C2:virtual B
     D:C1,C2
     void foo(B * b) {
     D * d=static_cast<D *>(b);
     }
     如果:
     B * b=new B();
     foo(b); 程序会出错,因为static_cast不知道foo的参数b到底是不是真的D*,编译时的static_cast只能假设它是了

     这时就需要dynamic_cast了,dynamic_cast的static_cast的功能基本相同,但它使用了
     rtti信息,可以正确处理从基类到派生类的转换,由于使用了rtti,只有有虚函数或虚基类的类才能使用.

     另外,c++中的(B *)d式的转换相当于编译器按
     const_cast,static_cast,dynamic_cast,reinterpret_cast的顺序挨个测试能否转换成
     功,reinterpret_cast是最后的选择

** RTTI与CTTI
   RTTI是在多态类的vtbl中存储的类型信息,非多态类没有RTTI信息
   dynamic_cast和typeid需要使用RTTI信息
   typeid可以得到类型信息,如typeid(1).name(),或typeid(myclass).name()
   但并非所有的typeid都是使用了RTTI,因为:
   - typeid是运算符,而不是函数,所以typeid的值可能在编译时就能确定
   - 对于非多态类型,如内置数据类型,或自定义的非多态的类,typeid使用的是CTTI,即编译时就确定类型
     而对于多态类型,typeid通过查询多态类的vtbl中的RTTI信息确定类型
** 重载 <<
#+BEGIN_EXAMPLE
#include <iostream>
using std::cout;
using std::endl;

struct foo {
    short a;
    char  b;
    char  c;
    int   d;
};

int
main(int argc, char ** argv) {
    int c=('A' << 16) + ('B' << 8) + 'C';
    foo f = {1234, 'x', 'y', ('D' << 24 )+('A' << 16) + ('B' << 8) + 'C'};
    cout<<&f.b<<endl;
    return 0;
}


#include <iostream>
#include <iostream>
using namespace std;


class foo {
    short a;
    char  b;
    char  c;
    int   d;
public:
    foo (short a,char b,char c,int d):a (a),b (b),c (c),d (d) {}
    friend ostream& operator<<(ostream& output,const foo & f);

};

ostream & operator<<(ostream& output,const foo & f) {
    output<<f.a<<endl;
}
int
main(int argc, char ** argv) {
    int c=('A' << 16) + ('B' << 8) + 'C';
    foo f (1234, 'x', 'y', ('D' << 24 )+('A' << 16) + ('B' << 8) + 'C');
    cout<<f;
    return 0;
}
#+END_EXAMPLE

** mask
#+BEGIN_EXAMPLE
   string mask (const string & ip, const string & mask) {
   //{{{
   struct sockaddr_in servaddr;
   bzero (&servaddr, sizeof (servaddr));
   servaddr.sin_family = AF_INET;
   inet_pton (AF_INET, ip.c_str (), &servaddr.sin_addr);
   in_addr_t ip_digit=servaddr.sin_addr.s_addr;
   inet_pton (AF_INET, mask.c_str (), &servaddr.sin_addr);
   in_addr_t mask_digit=servaddr.sin_addr.s_addr;
   in_addr_t tmp=ip_digit&mask_digit;
   servaddr.sin_addr.s_addr=tmp;
   char * ret=(char *)malloc (20);
   inet_ntop (AF_INET,&servaddr.sin_addr,ret,20);
   string rets=string (ret);
   free (ret);
   return rets;
   }
   //}}}
#+END_EXAMPLE
** copy构造函数与vtl

#+BEGIN_EXAMPLE
#include <iostream>
#include <string>
using namespace std;
class A {
    int a;
public:
    A () {}
    A (const A & a) {memcpy (this,&a,sizeof(a));}
    virtual void fun () {cout<<"A"<<endl;}

};

class B:public A {
public:
    B (){}
    void fun () {cout<<"B"<<endl;}

};
int
main(int argc, char ** argv) {
    B b;
    A a=b;
    A * ptra=&a;
    ptra->fun ();
    return 0;
}
#+END_EXAMPLE

** 类对象的几种声明方法：
使用构造函数和copy构造函数（但copy构造函数的调用通常被编译器优化掉）
- A a=A();
- A a=A(1);
没使用copy构造函数
- A a;
- A a(1);
使用了copy构造函数但被优化掉和没使用copy构造函数的区别是：当copy构造函数为private时....

指针形式
- A * a=new A()
- A * a=new A(1)

注意：
- A a() 并不等同于 A a=A(),虽然它和A a(1)很像，实际上 A a()是一个函数声明......a is a function returning A......

** virtual函数,vptr例子

#+BEGIN_EXAMPLE
#include <iostream>
#include <string>
using namespace std;
class A {

public:
    virtual void fun () {cout<<"A"<<endl;}
};
class B {

public:
    virtual void fun () {cout<<"B"<<endl;}
};

int
main(int argc, char ** argv) {
    A * a=new A;
    B * b=new B;
    void * ptra=reinterpret_cast<void *>(a);
    void * ptrb=reinterpret_cast<void *>(b);
    memcpy (ptrb,ptra,1);
    b->fun ();
    return 0;
}
#+END_EXAMPLE

** 成员函数的调用

#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

class AA {
    static int foo;
public:
    void fun ();
};
class AAA:public AA {
public:
};
void AA::fun() {
    cout<<"AA"<<endl;
}

int
main(int argc, char ** argv) {
    AA a;
    AAA aa;
    void (* f)(AA *)=reinterpret_cast<void (*)(AA *)>(0x080486d8);
    f (&a);
    return 0;
}
#+END_EXAMPLE

** virtual析构函数
#+BEGIN_EXAMPLE
<iostream>
using std::cout;
using std::endl;

class Base{
public:
virtual ~Base(){cout<<"~B"<<endl;}
};

class Derived:public Base{
public:
virtual ~Derived(){cout<<"~D"<<endl;}
};

void main (){
Base *b=new Derived();
delete b;
}
#+END_EXAMPLE
//执行结果
#+BEGIN_EXAMPLE
~D
~B
#+END_EXAMPLE
//解释
沿着程序执行流程，从main函数进入
首先，执行语句Base *b=new Derived();
结果是在堆中创建类Derived的一个对象，并且让类型为Base *的指针b指向这个对象；
其次，执行语句delete b;
运行结果是释放b指向对象的内存空间。按照C++的delete操作符的语义，编译器会指针b“对应类型”的对象的析构函数调用（你或许认为是Base::~Base()），但是由于类Base的析构函数声明为虚函数，因此实现方式具有多态特征（具体实现采用的技术请查看相关书籍，例如经典的Inside The C++ Object Model），因此运行时调用的析构函数是Derived::~Derived()。
第三，子类的析构函数Derived::~Derived()内部会调用父类的析构函数，因此执行结果如上！

基类中的虚析构函数使得派生类在使用多态性时也能被正确的析构。
** DONE c++ string literal的类型是什么?
   CLOSED: [2008-10-07 二 15:23]
   - State "DONE"       [2008-10-07 二 15:23]
   "abc"的类型为const char [4]

** DONE internal linkage , external linkage & no linkage
   CLOSED: [2008-10-06 一 15:51]
   - State "DONE"       [2008-10-06 一 15:51]
     http://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=41
 3.5 Program and linkage

 3 A name having namespace scope (3.3.5) has internal linkage
 if it is the name of
 - an object, reference, function or function template that
    is explicitly declared static or,
 - an object or reference that is explicitly declared const
 and neither explicitly declared extern nor previously
     declared to have external linkage; or
  - a data member of an anonymous union.

    4 A name having namespace scope has external linkage if it is
    the name of
  - an object or reference, unless it has internal linkage; or
  - a function, unless it has internal linkage; or
  - a named class (clause 9), or an unnamed class defined in
     a typedef declaration in which the class has the
     typedef name for linkage purposes (7.1.3); or
  - a named enumeration (7.2), or an unnamed enumeration defined
     in a typedef declaration in which the
     enumeration has the typedef name for linkage purposes
     (7.1.3); or
  - an enumerator belonging to an enumeration with external
     linkage; or
  - a template, unless it is a function template that has internal
     linkage (clause 14); or
  - a namespace (7.3), unless it is declared within an unnamed
     namespace.


     对不同linkage type的符号，ld需要做不同的处理：
   1. external linkage
      1.c: extern int a;
      2.c: extern int a;
      1.c 2.c被编译成目标文件时，1.o, 2.o中对a的引用地址都为0,ld将1.o, 2.o链接以后才能确定a的实际地址
   2. internal linkage
      1.c: static int a;
      1.c被编译成1.o时，对a的引用地址是a在.data段是的偏移量，1.o被链接后a的实际地址是.data基址+a的偏移量
   3. no linkage
      1.c: main () {int a;a=1;}
      1.o中a=1中对a的引用地址即是a在.text段中的偏移量,即不需要链接

1.c:
#+BEGIN_EXAMPLE
static int a;
static int b;
int c;
int d;
int
main(int argc, char *argv[]) {
    a=a+1;
    b=b+2;
    c=c+3;
    d=d+4;
    int e;
    e=e+5;
    return 0;
}
#+END_EXAMPLE

objdump -d 1.o:

#+BEGIN_EXAMPLE
1.o:     file format elf32-i386

Disassembly of section .text:

00000000 <main>:
   0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
   4:	83 e4 f0             	and    $0xfffffff0,%esp
   7:	ff 71 fc             	pushl  -0x4(%ecx)
   a:	55                   	push   %ebp
   b:	89 e5                	mov    %esp,%ebp
   d:	51                   	push   %ecx
   e:	83 ec 10             	sub    $0x10,%esp
  11:	a1 08 00 00 00       	mov    0x8,%eax                 对a的引用地址是a在.data段的offset 0x8,internal linkage
  16:	83 c0 01             	add    $0x1,%eax
  19:	a3 08 00 00 00       	mov    %eax,0x8
  1e:	a1 0c 00 00 00       	mov    0xc,%eax                 对b的引用地址是b在.data段的offset 0xc,internal linkage
  23:	83 c0 02             	add    $0x2,%eax
  26:	a3 0c 00 00 00       	mov    %eax,0xc
  2b:	a1 00 00 00 00       	mov    0x0,%eax                 对c的引用地址是0x0,extern linkage
  30:	83 c0 03             	add    $0x3,%eax
  33:	a3 00 00 00 00       	mov    %eax,0x0
  38:	a1 00 00 00 00       	mov    0x0,%eax                 对d的引用地址是0x0,extern linkage
  3d:	83 c0 04             	add    $0x4,%eax
  40:	a3 00 00 00 00       	mov    %eax,0x0
  45:	83 45 f8 05          	addl   $0x5,-0x8(%ebp)          对e的引用地址是栈上的地址,no linkage
  49:	b8 00 00 00 00       	mov    $0x0,%eax
  4e:	83 c4 10             	add    $0x10,%esp
  51:	59                   	pop    %ecx
  52:	5d                   	pop    %ebp
  53:	8d 61 fc             	lea    -0x4(%ecx),%esp
  56:	c3                   	ret
#+END_EXAMPLE

** 临时对象(右值)可被修改?
#+BEGIN_EXAMPLE
 #include <iostream>
 #include <stdlib.h>
 #include <string.h>
 using namespace std;
 class Test {
    char * p;
    int val;
 public:
    Test (int val) {p=(char *)malloc (10);this->val=val;}
    ~Test () {free (p);p=0;cout<<"dtor called for "<<val<<endl;}
 //    Test operator=(const Test & t) {cout<<"calling ="<<endl;memcpy (this->p,t.p,10);cout<<"= done"<<endl;return *this;}
 };

 Test foo (int val) {return Test (val);}

 int
 main (int argc, char * argv[]) {
    Test t (1);
    foo (2)=t;
    std::cout<<"here"<<std::endl;
    return 0;
 }
#+END_EXAMPLE

 foo(2)返回一个Test()临时对象,是一个 右值,但它却是可以调用自己的成员而被修改! 这是C++中类对象做为右值时的特例,对于标准类型如int,C++还是与C兼容的.
 临时对象做为右值却可以通过自己的成员函数被修改,这主要是为了方便以下的应用:
 临时对象也可以调用成员函数,如 getClassA().getVal(),而不用写成 Class A a=getClassA(), a.getVal()

 另外,foo(2)=t时,foo(2)返回的临时对象直到这条语句执行完后才被析构.
 http://www.9php.com/FAQ/cxsjl/c/2007/11/925528897440.html
** DONE 左值与右值
   [[*lval & rval][左值与右值]]
   - State "DONE"       [2008-08-21 四 11:19]
*** 函数返回引用
    foo & fun() 返回到foo的值用,是左值(当然决不能返回临时对象的引用)
    例如:
    - [[*prefrer%20i%20to%20i][prefer ++i to i++]]
    - [[*Decorator%20pattern][decorator pattern]]
*** *(void **)(&func_pointer)=...

#+BEGIN_EXAMPLE
    void *dlsym(void *handle, const char *symbol);
    int main(int argc, char **argv) {
    void *handle;
    double (*cosine)(double);
    char *error;

    handle = dlopen ("libm.so", RTLD_LAZY);
    if (!handle) {
    fprintf (stderr, "%s\n", dlerror());
    exit(1);
    }

    dlerror();
    //note the following line!
    *(void **) (&cosine) = dlsym(handle, "cos");
    //it is equal to cosine=(double (*) (double))dlsym(handle,"cos");, using
    //(void *)cosine=dlsym(..) is wrong, because (void *)cosine returns a rval
    if ((error = dlerror()) != NULL)  {
    fprintf (stderr, "%s\n", error);
    exit(1);
    }

    printf ("%f\n", (*cosine)(2.0));
    dlclose(handle);
    return 0;
    }
#+END_EXAMPLE

** DONE when does cast alter the pointer's address
   CLOSED: [2008-12-15 一 17:35]
   - State "DONE"       [2008-12-15 一 17:35]
   - 多重继承时
#+BEGIN_EXAMPLE
     class B1 {};
     class B2 {};
     class D:public B1,public B2 {};
     D * pd=new D();
     B1 * pb1=pd; //pb1=pd
     B2 * pb2=pd; //pb2!=pd
#+END_EXAMPLE

     图:
#+BEGIN_EXAMPLE
     +-----------------+
     | B1 subclass  -  |<-------pd,pb1 point to here
     +-----------------+
     | B2 subclass     |<-------pb2 point to here
     +-----------------+
     | D subclass      |
     +-----------------+
#+END_EXAMPLE

   - virtual继承时
#+BEGIN_EXAMPLE
     class B {};
     class D:public virtual B {};
     D * pd=new D();
     B * pb=pd;  //即使是单继承,pb也不等于pd
#+END_EXAMPLE
#+BEGIN_EXAMPLE
			 +--pd point to here
     图:		 |
			 |
     +------------+	 |
     |D subclass  |<-----+
     |_vptr of D  |--------->+---------------------+
     +------------+	     |offset to B subclasso|
     |B subclass  |<-----+   +---------------------+
     +------------+	 |   |RTTI and other virtua|
     			 |   |l funcs  	           |
     			 |   +---------+-----------+
	       	       	 |
     			 +--pb point to here,pb equals to pd+_vptr[0]

#+END_EXAMPLE
** c++弱化了data段还是bss段?
   和c一样,在c++里,main()之外的全局变量,函数中的static变量,类定义中的static变量都被自动初始化
   但与c不同的是,如果这些变量是类,会自动调用它们的ctor,看起来是bss被弱化了? 因为这些类不会被
   自动初始化为0
   实际上,是data被弱化了. 这些类被放在bss里,程序执行后,在main()之前,某些函数(如elf中的.init段)会调用
   它们的ctor来初始化这些类
** 除了ctor,在一个类的所有成员函数中调用虚函数都是通过vptr机制		:ATTACH:
   :PROPERTIES:
   :Attachments: 2.cpp
   :ID:       6b44moj04he0@sunway-lab.bupt.edu.cn
   :END:
   因为:
   1. test1的构造函数调用fun2时,test2还没建立起来,test1()首次将vptr指向自己的fun2,但test1()中对fun2的调用不通过vptr
   2. 任何时候,通过test1的其他成员函数如fun1调用fun2时,都是通过vptr,因为本质上函数调用都是通过this指针
      test1 t; t.fun2() 时编译器可以知道t是确定的类,所以不使用vptr.但当程序进入fun1后,编译器已无法确定fun1(this)里的this到底
      是什么类型
   因为成员函数都是通过this指针调用,属于指针调用,所以在成员函数中对虚函数的调用都是通过vptr

** DONE virtual inhereit in c++
   CLOSED: [2008-12-16 二 20:51]
   - State "DONE"       [2008-12-16 二 20:51]
#+BEGIN_EXAMPLE
   class B {int a;};
   class D1:public virtual B {}
   class D2:public virtual B {}
   class E:public D1,public D2 {}
#+END_EXAMPLE
   - memory layout
#+BEGIN_EXAMPLE
    D1:	         +----------------+
    +------+   /-+offset to B,ie,2|
    | vptr |---	 +----------------+
    +------+   	 |RTTI info of D1 |
    | int a|   	 +----------------|----------------------------+
    +------+	 |pointer to other virtual funcs if D1 has any |
       	       	 +---------------------------------------------+


    E:
    +------------+     	+----------	 --+
    | D1 subclass|   /--+ offset to B,ie,3 |
    | vptr     	 |---  	|------------------+-----------+
    +------------+	| RTTI and other virtual funcs |
    | D2 subclass|	+------------------------------+
    | vptr     	 |------ similar to vptr of D1, but offset to B is diff, ie,2
    +------------+
    | E subclass |
    +------------+
    | B subclass |
    | int a    	 |
    +------------+
#+END_EXAMPLE

   - why a offset to base class is needed
     在D1,D2和E中,都需要在vptr里指定一个到B的offset,虽然B存储的位置就在d1,d2,e附近
     如果是通过B的派生类(而不是通过派生类指针)使用B的成员,不需要通过vptr指定的offset,因为对于确定的类型,如E,它的内存布局在编译时就确定了,
     B的成员在E中的位置编译时就已经确定,直接使用即可.
     而如果是通过派生类的指针使用B的成员,必须通过vptr指定的offset,例如:
     D1 * dp=new D1(), B紧接dp
     D1 * dp=new E(),B和dp之间还间隔了一个sizeof(D2)的距离
     D2 * dp2=new E(), B紧接dp2
     所以必须通过D1的vptr中指定的offset才能找到B

   - difference when accessing base class member from pointer to derived class or from a derived class
     (something like access virtual function through pointer or not)
     http://www.phpcompiler.org/articles/virtualinheritance.html
** DONE c++ pointer-to-member variable and functions			:ATTACH:
   CLOSED: [2008-12-17 三 17:07]
   - State "DONE"       [2008-12-17 三 17:07]
   - what on earth a pointer-to-member pointer 'point' to?
     1. 到类的普通成员函数的指针是函数的真实物理地址
     2. 到类的虚成员函数的指针是虚函数在vtbl中的偏移量
     3. 到类的成员的指针是类成员在类中的偏移量
   :PROPERTIES:
   :Attachments: 1.cpp
   :ID:       41b8eg214he0@sunway-lab.bupt.edu.cn
   :END:
** DONE c++ inline function
   CLOSED: [2008-12-23 二 10:23]
   - State "DONE"       [2008-12-23 二 10:23]
#+BEGIN_EXAMPLE
   5.cpp
   #include <stdio.h>
   //typedef void (*fp) ();
   inline void fun () {
      //fp tmp=fun;
      printf ("test\n");
   }
   void f () {
      fun ();
   }

   6.cpp
   //typedef void (*fp) ();
   inline void fun ();
   int
   main(int argc, char *argv[]) {
   //    fp tmp=fun;
   //    (*tmp)();
      fun ();
      return 0;
   }
#+END_EXAMPLE

   - gcc默认不会inline,除非指定-O或-finline
     g++ 5.cpp -c
     nm -a 5.o|grep fun 显示 00000000 W _Z3funv
     g++ 5.cpp -c -O3 或 -finline
     nm -a 5.o|grep fun 无结果
   - 5.cpp中注释的两行(取inline函数的地址)会阻止compile inline
     取消注释后,
     g++ 5.cpp -c
     nm -a 5.o|grep fun 显示 00000000 W _Z3funv
   - inline函数和普通函数一样,具有external linkage
     如果inline函数通过取函数地址或不指定优化等手段使编译器不Inline它,则目标
     文件中包含这个函数,如W_Z3funv,这个函数具有external linkage,且这个函数在目标文件中是
     一个[[*weak%20symbol][weak symbol]]
     g++ 5.cpp 6.cpp -O3时,link出错,找不到fun
     g++ 5.cpp 6.cpp 时,编译成功,main()中调用的是5.cpp中的fun
   - 标准规定,每一个translation unit都要有inline函数的定义

     总结:每个translation unit都应该有inline函数的定义,如将inline函数的定义放在头文件中
     若不符合这个标准,也有可能编译通过,如将inline函数的定义放在某一个cpp文件中
     因为inline函数如果没有被inline就和普通函数一样,具有external linkage

** DONE static_cast<Derived *>(virtual base *) is not supported in C++
   CLOSED: [2008-12-29 一 09:18]
   - State "DONE"       [2008-12-29 一 09:18]

#+BEGIN_EXAMPLE
   class A {};
   class B : virtual public A {};
   class C : virtual public A {};
   class D : public B, public C {};
#+END_EXAMPLE

   来看B是什么样子(A是virtual的，所以放在底部)：

#+BEGIN_EXAMPLE
     +-----+
     | B   |
     | vptr|
     +-----+
     | A   |
     +--- -+
#+END_EXAMPLE

     这里我们假设A和B相差4

     再来看D是什么样子(B,C是基类，所以在开头，A是virtual的，所以放在底部)：
#+BEGIN_EXAMPLE
     +------+
     | B    |
     | vptr |
     +--- --+
     | C    |
     | vptr |
     +------+
     | D    |
     +--- --+
     | A    |
     +------+
#+END_EXAMPLE

     这里A和B就相差12了

     所以当compiler看到需要把一个A*转到B*的时候，她并不知道这个offset是4还是12，这个
     取决于你传过来的对象是B还是D。这就需要一些额外的runtime信息来做这件事。

     btw. reinterpret_cast<A*>(B*)是允许的,它假设是第一种情况

* Android
#+CATEGORY:android
** ActivityManagerService
   :PROPERTIES:
   :ID:       ams
   :END:
*** Intent and IntentFilter					     :intent:
**** Intent.setPackage(pkg)
     only match Activities in this `pkg`
**** Intent.component
**** IntentFilter.priority
     candidates ARE sorted by IntentFilter.priority when resolving intent, but
     - when resolve activity, ResolveActivity will reorder candidates in alphabet order....so nothing
     - when resolve service, only candidate with the highest priority are selected
     - when resolve broadcast, candidate priority are considered for OrderedBroadcast
**** DONE [#A] IntentFilter matching
     CLOSED: [2011-01-19 Wed 16:07]
     - State "DONE"       [2011-01-19 Wed 16:07]
     how startActivity(or startService, sendBrocast) use Intent.{category,action,data} to find the correct intent receiver?
     AMS use [[PackageManager][PackageManager]] to resolve intent to get intent's component
***** startActivity
#+BEGIN_EXAMPLE lang:c
      AMS:startActivity()
          AMS:startActivityMayWait()
	      PM:resolveIntent()
	          PM:queryIntentActivities()
		      // explicit intent
		      if (intent.getCommponent())
		          return the component
		      // implicit intent
		      if (intent.getPackage()==null)
		          PM:mActivities.queryIntent()
			      foreach activity:
			       	buildResolveList()
			           foreach IntentFilter:
                                     filter.match()
                                     make sure filter has DEFAULT category
		      else
		          PM:mActivities.queryIntentForPackage()
                            foreach activity:
			       	buildResolveList()
			           foreach IntentFilter:
                                     filter.match()
                                     make sure filter has DEFAULT category
		  PM:chooseBestActivity()
		      // candidates here are sorted by [[IntentFilter.priority][IntentFilter.priority]]
                      if (candidates.size() == 1)
		          return it;
		      if we have saved a preference for a preferred activity
		          return findPreferredActivity()
		      else
                          return ResolverActivity // although candidates are sorted by IntentFilter.priority, ResolverActivity will
			                          // reorder them in alphabet order...weired~~
	      Intent.setComponent()
	      AMS:startActivityLocked()
	        checkComponentPermission();
	      ...
#+END_EXAMPLE
      - PM:resolveIntent
       	when PackagetManager need to detect whether there are activities in a certain package matching the Intent, it will resolve the inent as:
       	1) PM calls queryIntentForPackage, which will take a List of activities in the package as param
       	2) for every activity, call buildResolveList, which take a List of all IntentFilters of the activity as param
       	3) for every IntentFilter, call filter.match( intent.getAction(), resolvedType, scheme, intent.getData(), categories, TAG); to determine whether
	   the IntentFilter matches the Intent, if so, add the activity to the candidates.  Note that categories is a list of Category in the intent, since
	   intent can call addCategory() to add serveral categories requirement
       	4) filter.match() will check
	   1) action
	      intent action mustn't be null and must be in the IntentFilter's actions list
	   2) data
	      data must be a subset of IntentFilter's data list
	   3) category
	      if intent's categories is a subset of filter's categories, or intent's category is null , return ok
       	5) if filter.match() match, there is still one last check:
	   1) if the defaultOnly flag is set (in fact, startActivity will always set the flag when resolveIntent), and the candidate intentFilter also
	      has the DEFAULT category, returns ok.  this is just as if the Intent has added the DEFAULT category by default. BUT, since it is restriction
	      imposed by AMS, we can't override the behaviour by calling intent.removeCategory(DEFAULT)
	   2) note: the DEFAULT_ONLY flag and intentFilter's default category is mainly used by startActivity, use PM standalone (e.g. resolveActivity) doesn't
	      impose this restriction.
      - PM:chooseBestActivity
       	after PM:resolveIntent, a list of candidates are available, PM will choose the best activity
       	1) if there is only ONE candidates, return it
       	2) else, call findPreferredActivity to find if we have saved a preference for a preferred activity for this intent
       	3) else, return a ResolverActivity, which will show a ResolverActivity and promp user for the prefered activity. ResolverActivity will sort candidates
	   in alphabet order, regardless of IntentFilter's priority.
      - At last, if PM returns a ResolverActivity, AMS will actually start ResolverActivity, ResolverActivity's onClick will call startActivity() to start the real user prefered activity.

***** startService
#+BEGIN_EXAMPLE
      AMS:startServiceLocked()
        AMS:retrieveServiceLocked()
	    if ret=mServicesByIntent.get(intent)
	        return ret; //      * All currently running services indexed by the Intent used to start them.
	    else
                PM:resolveService()  // just like resolveActivity
		    PM:queryIntentServices()
		        if intent.getComponent()
			    use it;
			else
			    PM:queryIntent() // return a list of candidates, note that the list is sorted according to [[IntentFilter.priority][IntentFilter.priority]]
		    if candidates>1      // more than ONE candidate
		        use candidate.get(0)  // pick the first one. because the candidates are sorted according
			                         // to IntentFilter.priority, so the candidate with the highest priority is selected.
            checkComponentPermission()
#+END_EXAMPLE

***** sendBroadcast
      just as startService, priority are considered, and a list of all candidates are return to support OrderedBroadcast
*** Activity							   :activity:
**** AMS side
***** finishedActivityLocked
      finishCurrentActivity eventually will not stop and destroy activity at once, it will pose it in an array, when idle, it will call activityIdle to purge the activities.
      When is idle? There are 2 scen:
      1) thread.scheduleResumeActivity will pose one 'Idler' in the msg queue after onResume is finished. Idler will invoke AMS.activityIdle
	 2)AMS is smart enough to pose on one delayed IDLE_TIMEOUT_MSG to the handler in case there is no Idler since onResume hangs. The delayed timeout is 10s.

	 That is, onStop and onDestroy may be delayed for 10s after another activity's onResume is called.
	 11/23/10 11:40 am
	 finishActivityLocked
	 startPausing

	 ...

	 activityPaused
	 finishCurrentActivity --> mark the activity for destroy
	 resumeTopActivity
	 ...
	 activity resumed --> pose idler timer to destroy activity marked befored

	 11/17/10 6:46 pm
	 assume that when A is finished and B will be resumed: first, A is paused, then B is resumed, and A is stopped and destroyed at last


	 11/17/10 6:37 pm
	 To prevent if activity.onPause doesn't return in a period of time(500ms), AMS will call sendMessageDelayed() in startPausingLocked() to send itself one PAUSE_TIMEOUT msg to force itself call activityPaused().

	 That is, although activity.onPause() may block, AMS is assured to resume	next activity in 500ms.

	 11/17/10 5:47 pm
      1. activity.finish() will call AMS's finishActivity() through AIDL, providing activity's IBinder as parameter so that AMS can recognize the corresponding HistoryRecord in AMS.

      2. AMS calls
	 finishActivityLocked()
	 startPausingLocked()
	 thread.schedulePauseActivity()

      3. thread.schedulePauseActivity() will call activity.onPause(), then notify AMS that activity is paused through AMS.activityPaused()

      4. activityPaused()
	 completePauseActivity()
	 mark activity for stop when idle
	 resumeTopActivity()
***** attachApplication

attachApplication is the 3rd step to start a new activity. (1. startPausing, 2. activityPaused.)
When one new activityThread is created, after calling onCreate, activityThread will invoke AMS.attachApplication to notify AMS that process is OK, then AMS can call realStartActivity to launch the activity.

***** activityPaused
activityPaused is called by ActivityThread to notity AMS that the mResumed activity is paused(or onPause is timeout)
after that, if prev should be finished (when finish activity), it will call finishCurrentActivity to finish prev activity. Then resumeTopActivity will be called again to really resume another activity.

***** startActivityLocked

11/22/10 2:08 pm
AMS.startActivityLocked() is the very begining  entry to start activity.

Stack trace:
AMS side:
#+BEGIN_EXAMPLE
startActivity
  startActivityUnchecked
     moveTaskToFront
        finishTaskMoved
            resumeTopActivity
#+END_EXAMPLE

when resumeTopActivity, it will firstly call startPausing to pause mResumedActivity A.

after A's onPause return, ActivityThread will notify AMS through AMS.ActivityPaused, which will then call resumeTopActivity again to resume  activity.

When invoked for the 2nd time, it will try call r.app.thread.scheduleResumeActivity to resume our activity,  then return. but before calling onResume, AMS
will firstly invoke mWindowManager.setAppVisibility(next, true) if the activity is invisible, which will call onRestart and onStart before onResume.

If exception occurs, it means the activity is already finished, or it's process is not started at all, it will call
#+BEGIN_EXAMPLE
startSpecificActivityLocked,
  realStartActivityLocked
    thread.scheduleLaunchActivity

or
startSpecificActivityLocked,
  startProcessLocked
#+END_EXAMPLE

for the 2nd scenero, when activityThread is started in startProcessLocked, it will call AMS.attachApplication to notify AMS that the process is ready, attachApplication will then call realStartActivity again to real kaunch the activity.

***** resumeTopActivityLocked

11/22/10 6:38 pm
resumeTopActivity will firstly call startPausing to pause the mResumedActivity, then return directory.

When mResumedActivity is paused or timeout (500ms), AMS.activityPaused will be called, which will invoke resumeTopActivity again to finally resume(or launch) the activity.

***** Timeout
****** Pause timeout
****** Idle timeout
       11/23/10 3:49 pm
       idle timeout is the timeout to stop and destroy activity A after activity B is resumed.
       in the normal case, B's scheduleResumeActivity will pose an Idler after onResume to ensure that A will be finish via activityIdle.
       Howerer, if B's onResume hangs, a delay IDLE_TIMEOUT_MSG is a must for AMS to make sure A will be finished in 10s.

***** HistoryRecord
      HistoryRecord is used in two ways:
      - it is the shadow structure of `Activity` in AMS
      - it is used as a IBinder token by AMS, e.g. when AMS want to resume activity, it will send the activity's corresponding HistoryRecord as a token to
	ActivityThread, so that ActivityThread knows which activity to resume.
	- r.app.thread
	- r.resultRecord
	- r.sourceRecord
	- r.intent
****** AMS.mHistory stores all the HistoryRecord of AMS.
***** startPausingLocked
11/22/10 6:43 pm
startPausing is called in resumeTopActivity to pause the mResumed activity before resume or launch the target activity
***** startSpecificActivity
11/23/10 1:06 pm
it is called when resumeTopActivity (2nd time when prev is paused) to start (instead of resume) target activity.

It may call realStartActivity to start the activity or call startProcess to start a new process.
****** startProcess
****** realStartActiviry
11/23/10 1:10 pm
real start an activity instead of resume or start a new process.

This is called in 2 scen:
1) startSpecificActivity in resumeTopActivity
2) attachApplication, since when attachApplication, the process definitly exist and activity is surely not started yet. resumeTopActivity is redunctant, calling realStartActivity is enough.
**** ActivityThread side
***** ActivityRecord
      12/28/10 7:50 pm
      ActivityRecord will save the real Activity instance and some other info.  It corresponds to AMS::HistoryRecord.
      ActivityRecord use one Map<IBinder,ActivityRecord> to save process's all activities.
      Evey ActivityThread.scheduleXxx ()  takes  an 'Token' (an IBinder)  as para so that ActivityThread can get the corres ActivityRecord from the map.
***** IApplicationThread
****** schedulePausingActivity
       schedulePausingActivity will firstly call activity.onPaused, and wait for
       return, then it will notify AMS through AMS.activityPaused that the
       activity is paused.
****** scheduleResumeActivity
       it will call onResume, when onResume returns, it will add one Idler to
       AMS's queue, to make sure AMS will be norified when queue is idle to stop
       and destroy pending need-to-finish act ivies
****** scheduleLaunchActivity
       when called by AMS.realStartActivity, scheduleLaunchActivity will
       sequencially call onCreate, onStart,
       onRestoreInstanceState,onPostCreate,onResume.
**** Activity side
     - onStop, onRestart is only related to activity visibility. they are invoked by mWindowManager.setAppVisibility() due to visibility change.
     - onStart may be called due to visibility change or life cycle change.
     - onPause, onDestroy, onResume is the core concept related to activity life cycle, they are called only when life cycle is changed.
***** finish
***** onPause
      only when starting another *Activity*, will the former activity's  onPause be called;
      that is, Dialog, PopupWindow will not trigger activity's onPause
***** onStop
      may only be called after onPause
      if the paused activity is totally invisible to the user, onStop will be called
      that is, if the resumed activity is opaque, the paused activity's onStop would not be called

      resumeTopActivity will call mWindowManager.setAppVisibility(prev, false); // cause prev.onStop be called
      to stop prev activity

***** onDestroy
***** onResume
***** onRestart
      resumeTopActivity will cal  mWindowManager.setAppVisibility(next, true);  // cause next.onRestart and next.onStart be called
      to call onRestart and onStart
***** onStart
***** onCreate
**** Task stack
**** NativeActivity
**** Activity Result

**** TODO [#A] Launcher
     see also [[Launcher & Task]]
**** Task
***** why relaunch an activity A from launcher will bring the task to foreground
       note that: startActivity from launcher will always use Intent flags of NEW_TASK

#+BEGIN_EXAMPLE
       startActivityUnchecked()
         if NEW_TASK && ((MULTIPLE_TASK not set)||...): // see MULTIPLE_TASK flag later, true
	   taskTop = findTaskLocked(intent, r.info)
	     // findTaskLocked will return the top activity in any existing task matching the given intent
	     // typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered
	     // How taskAffinity is null? if activity's taskAffinity property is set to "" (see [[Notification]]), then it's taskAffinity will be set to null

           if (taskTop != null): // there is already an existing task for the activity A, true
	     if (r.realActivity.equals(taskTop.task.realActivity)): // activity A is the same as the matching task's root activity, true
	       if FLAG_ACTIVITY_SINGLE_TOP is set:
	         deliverNewIntentLocked(taskTop, r.intent);  // onNewIntent is called
		 resumeTopActivityLocked(null);
		   mWindowManager.setAppVisibility(prev, false); // cause onStop be called
		   mWindowManager.setAppVisibility(next, true);  // cause onRestart and onStart be called
                 return START_DELIVERED_TO_TOP;
	       else if r.intent.filterEquals(taskTop.task.intent):  // if activity A's calling intent is equal with the intent used to start
	                                                            // the task's root activity, intent equality will consider intent action,category,
								    // data,type,component..., but *excluding any intent extra*, true
                 resumeTopActivity()
		   if resumedActivity == topRunningActivity:        // need not resume, in this case, resumedActivity is launcher, while topRunningActivity
		                                                    // is Activity A, false
		     return;
		   else:
		     pause resumeActivity and resume topRunningActivity  // true
		     mWindowManager.setAppVisibility(prev, false); // cause onStop be called
		     mWindowManager.setAppVisibility(next, true);  // cause onRestart and onStart be called

		 return START_TASK_TO_FRONT;                        // move the task to foreground
         else: // if NEW_TASK
	   if (top.realActivity.equals(r.realActivity)):
	     if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
               or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
               or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
	       resumeTopActivityLocked(null);
               deliverNewIntentLocked(top, r.intent);
               return START_DELIVERED_TO_TOP;
	   create or start the activity                           // false

#+END_EXAMPLE

      To summarize:
      when relaunching an activity from launcher, because the intent used to relaunch the activity is the same as the former task's root activity's intent
      (both are MAIN & LAUNCHER..), AMS will try to resume the activity instead of relaunching it.
      startActivity with *NEW\_TASK* and the *same* intent as the task's intent will bring the task to foreground (through resumeTopActivity) instead of
      launching it. this behavior is similar with that the task's top activity has the SINGLE\_TOP launchMode.

      Note about MULTIPLE\_TASK intent flag:
      Used in conjunction with FLAG\_ACTIVITY\_NEW_TASK to disable the behavior of bringing an existing task to the foreground.  When set,
      a new task is always started to host the Activity for the Intent, regardless of whether there is already an existing task running
      the same thing.

***** DONE [#A] startActivityUnchecked & affinity, launchMode, intentFlags
      SCHEDULED: <2011-05-13 Fri> CLOSED: [2011-05-13 Fri 15:05]
      - State "DONE"       [2011-05-13 Fri 15:05]
      *FLAG\_ACTIVITY\_NEW\_TASK* is defininitly the most important property related to android task management.
****** source code comment
#+BEGIN_EXAMPLE
     1	       private final int startActivityUncheckedLocked(HistoryRecord r,
     2	            HistoryRecord sourceRecord, Uri[] grantedUriPermissions,
     3	            int grantedMode, boolean onlyIfNeeded, boolean doResume) {
     4		Slog.e("sunway","flag");
     5	        final Intent intent = r.intent;
     6	        final int callingUid = r.launchedFromUid;
     7	        int launchFlags = intent.getFlags();
     8
     9	        // We'll invoke onUserLeaving before onPause only if the launching
    10	        // activity did not explicitly state that this is an automated launch.
    11	        mUserLeaving = (launchFlags&Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
    12	        if (DEBUG_USER_LEAVING) Slog.v(TAG,
    13	                "startActivity() => mUserLeaving=" + mUserLeaving);
    14
    15	        // If the caller has asked not to resume at this point, we make note
    16	        // of this in the record so that we can skip it when trying to find
    17	        // the top running activity.
    18	        if (!doResume) {
    19	            r.delayedResume = true;
    20	        }
    21
    22	        HistoryRecord notTop = (launchFlags&Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP)
    23	                != 0 ? r : null;
    24
    25	        // If the onlyIfNeeded flag is set, then we can do this if the activity
    26	        // being launched is the same as the one making the call...  or, as
    27	        // a special case, if we do not know the caller then we count the
    28	        // current top activity as the caller.
    29	        if (onlyIfNeeded) {
    30	            HistoryRecord checkedCaller = sourceRecord;
    31	            if (checkedCaller == null) {
    32	                checkedCaller = topRunningNonDelayedActivityLocked(notTop);
    33	            }
    34	            if (!checkedCaller.realActivity.equals(r.realActivity)) {
    35	                // Caller is not the same as launcher, so always needed.
    36	                onlyIfNeeded = false;
    37	            }
    38	        }
    39
    40	        if (grantedUriPermissions != null && callingUid > 0) {
    41	            for (int i=0; i<grantedUriPermissions.length; i++) {
    42	                grantUriPermissionLocked(callingUid, r.packageName,
    43	                        grantedUriPermissions[i], grantedMode, r);
    44	            }
    45	        }
    46
    47	        grantUriPermissionFromIntentLocked(callingUid, r.packageName,
    48	                intent, r);
    49
    50	        if (sourceRecord == null) {
    51	            // This activity is not being started from another...  in this
    52	            // case we -always- start a new task.
    53	            if ((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
    54	                Slog.w(TAG, "startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: "
    55	                      + intent);
    56	                launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    57	            }
    58	        } else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    59	            // The original activity who is starting us is running as a single
    60	            // instance...  this new activity it is starting must go on its
    61	            // own task.
    62	            launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    63	        } else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
    64	                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
    65	            // The activity being started is a single instance...  it always
    66	            // gets launched into its own task.
    67	            launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
    68	        }
    69
    70	        if (r.resultTo != null && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
    71	            // For whatever reason this activity is being launched into a new
    72	            // task...  yet the caller has requested a result back.  Well, that
    73	            // is pretty messed up, so instead immediately send back a cancel
    74	            // and let the new task continue launched as normal without a
    75	            // dependency on its originator.
    76	            Slog.w(TAG, "Activity is launching as a new task, so cancelling activity result.");
    77	            sendActivityResultLocked(-1,
    78	                    r.resultTo, r.resultWho, r.requestCode,
    79	                Activity.RESULT_CANCELED, null);
    80	            r.resultTo = null;
    81	        }
    82
    83	        boolean addingToTask = false;
    84	        if (((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &&
    85	                (launchFlags&Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
    86	                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
    87	                || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
    88	            // If bring to front is requested, and no result is requested, and
    89	            // we can find a task that was started with this same
    90	            // component, then instead of launching bring that one to the front.
    91	            if (r.resultTo == null) {
    92	                // See if there is a task to bring to the front.  If this is
    93	                // a SINGLE_INSTANCE activity, there can be one and only one
    94	                // instance of it in the history, and it is always in its own
    95	                // unique task, so we do a special search.
    96
    97			// sunway:
    98			// 对于launchMode不为SINGLE_INSTANCE的情况, taskTop是根
    99			// 据affinity(或activity component)查找到的已存在的task的top activity; 对于
   100			// SINGLE_INSTANCE的情况, taskTop为该single activity
   101			// Q: 系统如何在NEW_TASK时查找是否已经存在一个`密切`的task?
   102
   103	                HistoryRecord taskTop = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE
   104	                        ? findTaskLocked(intent, r.info)
   105	                        : findActivityLocked(intent, r.info);
   106
   107			// sunway:
   108			// 对于NEW_TASK, 已经找到一个已经存在的TASK或single instance
   109			// activity
   110
   111	                if (taskTop != null) {
   112	                    if (taskTop.task.intent == null) {
   113	                        // This task was started because of movement of
   114	                        // the activity based on affinity...  now that we
   115	                        // are actually launching it, we can assign the
   116	                        // base intent.
   117	                        taskTop.task.setIntent(intent, r.info);
   118	                    }
   119	                    // If the target task is not in the front, then we need
   120	                    // to bring it to the front...  except...  well, with
   121	                    // SINGLE_TASK_LAUNCH it's not entirely clear.  We'd like
   122	                    // to have the same behavior as if a new instance was
   123	                    // being started, which means not bringing it to the front
   124	                    // if the caller is not itself in the front.
   125
   126
   127	                    HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);
   128
   129			    // sunway:
   130			    // our task or single_instance activity is in background,
   131			    // move it to front
   132
   133	                    if (curTop.task != taskTop.task) {
   134	                        r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
   135	                        boolean callerAtFront = sourceRecord == null
   136	                                || curTop.task == sourceRecord.task;
   137
   138				// sunway:
   139				// 如果: 1. new task 2. task在后台 3. caller在前台 (或
   140				// sourceRecord==null),则将task移到前台, 所以, 一个后台的
   141				// task里的一个thread无法通过 new_task &
   142				// activity.startActivity将task移动到前台
   143
   144	                        if (callerAtFront) {
   145	                            // We really do want to push this one into the
   146	                            // user's face, right now.
   147	                            moveTaskToFrontLocked(taskTop.task, r);
   148	                        }
   149	                    }
   150	                    // If the caller has requested that the target task be
   151	                    // reset, then do so.
   152	                    if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
   153				// sunway:
   154				// reset task ... take a deep breath;
   155	                        taskTop = resetTaskIfNeededLocked(taskTop, r);
   156	                    }
   157	                    if (onlyIfNeeded) {
   158	                        // We don't need to start a new activity, and
   159	                        // the client said not to do anything if that
   160	                        // is the case, so this is it!  And for paranoia, make
   161	                        // sure we have correctly resumed the top activity.
   162	                        if (doResume) {
   163	                            resumeTopActivityLocked(null);
   164	                        }
   165	                        return START_RETURN_INTENT_TO_CALLER;
   166	                    }
   167
   168	                    if ((launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
   169	                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
   170	                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
   171	                        // In this situation we want to remove all activities
   172	                        // from the task up to the one being started.  In most
   173	                        // cases this means we are resetting the task to its
   174	                        // initial state.
   175
   176				// sunway:
   177				// 在大多数情况下, task或single instance activity
   178				// 在此之前已经被移动到前台,performClearTaskLocked只会
   179				// finish该task中位于r之上的activity, 除非...移动到前台
   180				// 时失败(例如callerAtFront为假,这时会有意想不到的效
   181				// 果)
   182
   183				// sunway:
   184				// performClearTaskLocked会finish位于r,top之间的所有
   185				// activity,一般情况下不会finish `基准`activity (对于
   186				// CLEAR_TOP,即是r,对于SINGLE_TASK,SINGLE_INSTANCE,即是
   187				// task的root activity, 除非...基准activity是MULTIPLE
   188				// launch mode且其SINGLE_TOP为假
   189
   190				// 总结: 对于一般的startActivity(不包含
   191				// RESET_TASK_IF_NEEDED intent flag), CLEAR_TOP是可以
   192				// finish某些activity的机会,如果想让一个activity在每次
   193				// startActivity时finish掉之前的并create新的且只有一个实
   194				// 例 (例如某些通知功能的activity),可以:
   195				// 1. 使用NEW_TASK和CLEAR_TOP
   196				// 2. launchMode为MULTIPLE,且SINGLE_TOP为假
   197				// 3. 为防止CLEAR_TOP误杀同task的其他activity, 可以设其
   198				// affinity为其他唯一值或者直接使用空串, 确保task中只有
   199				// 它一个activity (类似于singleInstance)
   200
   201				// Q: 看起来start SINGLE_TASK 的 root activity 也会导致
   202				// performClearTask .... 并perforClearTask并不
   203				// 能保证developer中声称的SINGLE_TASK的属性:SINGLE_TASK必
   204				// 须是task的root activity; 实际上这段代码的效果是: 设
   205				// A,B的affinity相同, A启动B,其中B是
   206				// SINGLE_TASK,则结果是A,B; B再启动A,结果A,B,A; A再启动
   207				// B, 结果是A,B, 和CLEAR_TOP有啥区别?
   208				// 若想达到文档中声称的SINGLE_TASK效果,必须保证B一开始就
   209				// 是task的root activity.....那只能给它设一个唯一的
   210				// affinity(或affinity为null)才行
   211				// Q: 为什么会有这个问题?
   212				// A: 相比之下,SINGLE_INSTANCE的行为是正常的,根本原因是
   213				// 因为前面对taskTop的查找: 对于SINGLE_INSTANCE, 是从整
   214				// 个mHistory去找唯一的一个activity实例. 而对于
   215				// SINGLE_TASK, 则是从上到下根据affinity找\emph{第一个}
   216				// 匹配的task, 考虑这种情况:
   217				// 有A,B,C,D四个activity, 使用相同的affinity, 其中的A是
   218				// SINGLE_TASK, 设当前有两个task, 'A,C,D'和'B'. 然后另外
   219				// 某处startActivity(B), 假设系统找到第一个匹配的
   220				// task是'A,C,D'... 是否要为B生成一个new task?
   221				// 所以根本原因是task的管理还是过于简单, \emph{task的查找方法
   222				// 无法满足SINGLE_TASK语义}.
   223				// 做为workaround,可以通过确保SINGLE_TASK的activity为唯
   224				// 一的affinity来弥补task查找方法的不足.
   225
   226
   227	                        HistoryRecord top = performClearTaskLocked(
   228	                                taskTop.task.taskId, r, launchFlags, true);
   229
   230				// sunway:
   231				// 若top不为null, 说明CLEAR_TOP真的只是 `clear top`, 则需
   232				// 要调用top的onNewIntent
   233
   234
   235	                        if (top != null) {
   236	                            if (top.frontOfTask) {
   237	                                // Activity aliases may mean we use different
   238	                                // intents for the top activity, so make sure
   239	                                // the task now has the identity of the new
   240	                                // intent.
   241	                                top.task.setIntent(r.intent, r.info);
   242	                            }
   243	                            logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
   244	                            deliverNewIntentLocked(top, r.intent);
   245	                        } else {
   246				    // sunway:
   247				    // 若top为null,说明CLEAR_TOP把`基准`activity也clear掉
   248				    // 了...这种情况的发生只有一种可能:`基准`activity是
   249				    // MULTIPLE & SINGLE_TOP, `基准`activity被clear掉后,
   250				    // 需要通过addingToTask标记通知后续代码:该activity需
   251				    // 要重新添加一个新的实例到task中, addingToTask的意思
   252				    // 是:addNewInstanceToTask
   253
   254	                            // A special case: we need to
   255	                            // start the activity because it is not currently
   256	                            // running, and the caller has asked to clear the
   257	                            // current task to have this activity at the top.
   258	                            addingToTask = true;
   259	                            // Now pretend like this activity is being started
   260	                            // by the top of its task, so it is put in the
   261	                            // right place.
   262	                            sourceRecord = taskTop;
   263	                        }
   264	                    } else if (r.realActivity.equals(taskTop.task.realActivity)) {
   265				// sunway:
   266	                        // 我们想要start的是task的root activity, 若使用的intent
   267	                        // 也是相同的, 系统认为我们只是想moveTaskToFront, 所以不
   268	                        // 生新create一个activity,则只是resume这个task的top
   269	                        // activity.
   270				// 实际上,这段代码反映的是launcher的行为: laucher每次点
   271	                        // 击桌面图标时,对同一个图标,使用的intent是一样的,且要启
   272	                        // 动的activity也必然是task的root activity
   273				// 通过模拟launcher的这种行为,我们也可以只是将某个task移
   274	                        // 动到前台,而不做其他任何事
   275
   276
   277
   278	                        // In this case the top activity on the task is the
   279	                        // same as the one being launched, so we take that
   280	                        // as a request to bring the task to the foreground.
   281	                        // If the top activity in the task is the root
   282	                        // activity, deliver this new intent to it if it
   283	                        // desires.
   284	                        if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
   285	                                && taskTop.realActivity.equals(r.realActivity)) {
   286	                            logStartActivity(EventLogTags.AM_NEW_INTENT, r, taskTop.task);
   287	                            if (taskTop.frontOfTask) {
   288	                                taskTop.task.setIntent(r.intent, r.info);
   289	                            }
   290	                            deliverNewIntentLocked(taskTop, r.intent);
   291	                        } else if (!r.intent.filterEquals(taskTop.task.intent)) {
   292	                            // In this case we are launching the root activity
   293	                            // of the task, but with a different intent.  We
   294	                            // should start a new instance on top.
   295	                            addingToTask = true;
   296	                            sourceRecord = taskTop;
   297	                        }
   298	                    } else if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
   299				// sunway:
   300	                        // 这里基本上是NEW_TASK所判断的最后一个条件了: 若
   301	                        // RESET_TASK_IF_NEED设置, 则addingToTask为false,阻止了
   302	                        // 后续的处理. 效果和前面提到的launcher行为类似,但要启动
   303	                        // 的activity不必是root activity.
   304				// 一般情况下,只有launcher会使用这个标志
   305
   306
   307	                        // In this case an activity is being launched in to an
   308	                        // existing task, without resetting that task.  This
   309	                        // is typically the situation of launching an activity
   310	                        // from a notification or shortcut.  We want to place
   311	                        // the new activity on top of the current task.
   312	                        addingToTask = true;
   313	                        sourceRecord = taskTop;
   314	                    } else if (!taskTop.task.rootWasReset) {
   315	                        // In this case we are launching in to an existing task
   316	                        // that has not yet been started from its front door.
   317	                        // The current task has been brought to the front.
   318	                        // Ideally, we'd probably like to place this new task
   319	                        // at the bottom of its stack, but that's a little hard
   320	                        // to do with the current organization of the code so
   321	                        // for now we'll just drop it.
   322	                        taskTop.task.setIntent(r.intent, r.info);
   323	                    }
   324	                    if (!addingToTask) {
   325	                        // We didn't do anything...  but it was needed (a.k.a., client
   326	                        // don't use that intent!)  And for paranoia, make
   327	                        // sure we have correctly resumed the top activity.
   328	                        if (doResume) {
   329	                            resumeTopActivityLocked(null);
   330	                        }
   331	                        return START_TASK_TO_FRONT;
   332	                    }
   333	                }
   334	            }
   335	        }
   336
   337		// sunway:
   338	        // finally we are here....
   339	        // 在三种情况下代码会走到这里:
   340	        // case 1. NEW_TASK为真, 但taskTop为null...说明现在系统里找不到一个已经存在的
   341	        // `密切`的task, 真的需要`new`一个task了
   342	        // case 2. NEW_TASK==true, taskTop!=null, 但addingToTask为真, 即需要在taskTop
   343	        // 上 new activity instance
   344	        // case 3. 根本没有指定NEW_TASK标志,新的activity使用当前的task (使用当前的
   345	        // task并不意味着要直接new activity instance, 因为SINGLE_TOP,
   346	        // CLEAR_TOP...还要考虑)
   347		//
   348	        //
   349	        //
   350	        //String uri = r.intent.toURI();
   351	        //Intent intent2 = new Intent(uri);
   352	        //Slog.i(TAG, "Given intent: " + r.intent);
   353	        //Slog.i(TAG, "URI is: " + uri);
   354	        //Slog.i(TAG, "To intent: " + intent2);
   355	        if (r.packageName != null) {
   356	            // If the activity being launched is the same as the one currently
   357	            // at the top, then we need to check if it should only be launched
   358	            // once.
   359	            HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
   360	            if (top != null && r.resultTo == null) {
   361	                if (top.realActivity.equals(r.realActivity)) {
   362	                    if (top.app != null && top.app.thread != null) {
   363				// sunway:
   364				// case 2,3;
   365				// SINGLE_TOP并非NEW_TASK的专利
   366				// A,B,C (c single top)
   367	                        if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
   368	                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
   369	                            || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
   370	                            logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);
   371	                            // For paranoia, make sure we have correctly
   372	                            // resumed the top activity.
   373	                            if (doResume) {
   374	                                resumeTopActivityLocked(null);
   375	                            }
   376	                            if (onlyIfNeeded) {
   377	                                // We don't need to start a new activity, and
   378	                                // the client said not to do anything if that
   379	                                // is the case, so this is it!
   380	                                return START_RETURN_INTENT_TO_CALLER;
   381	                            }
   382	                            deliverNewIntentLocked(top, r.intent);
   383	                            return START_DELIVERED_TO_TOP;
   384	                        }
   385	                    }
   386	                }
   387	            }
   388
   389	        } else {
   390	            if (r.resultTo != null) {
   391	                sendActivityResultLocked(-1,
   392	                        r.resultTo, r.resultWho, r.requestCode,
   393	                    Activity.RESULT_CANCELED, null);
   394	            }
   395	            return START_CLASS_NOT_FOUND;
   396	        }
   397
   398	        boolean newTask = false;
   399
   400	        // Should this be considered a new task?
   401	        if (r.resultTo == null && !addingToTask
   402	                && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
   403		    // sunway:
   404		    // case 1, 新建一个task, NEW_TASK
   405
   406	            // todo: should do better management of integers.
   407	            mCurTask++;
   408	            if (mCurTask <= 0) {
   409	                mCurTask = 1;
   410	            }
   411	            r.task = new TaskRecord(mCurTask, r.info, intent,
   412	                    (r.info.flags&ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
   413	            if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
   414	                    + " in new task " + r.task);
   415	            newTask = true;
   416	            addRecentTaskLocked(r.task);
   417
   418	        } else if (sourceRecord != null) {
   419	            if (!addingToTask &&
   420	                    (launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
   421			// sunway
   422			// case 3;
   423			// CLEAR_TOP并非NEW_TASK的专利
   424			// 由于这里没有经过NEW_TASK的 moveToFront, 导致CLEAR_TOP更容易伤
   425			// 到其他task的activity
   426
   427	                // In this case, we are adding the activity to an existing
   428	                // task, but the caller has asked to clear that task if the
   429	                // activity is already running.
   430
   431	                HistoryRecord top = performClearTaskLocked(
   432	                        sourceRecord.task.taskId, r, launchFlags, true);
   433	                if (top != null) {
   434	                    logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
   435	                    deliverNewIntentLocked(top, r.intent);
   436	                    // For paranoia, make sure we have correctly
   437	                    // resumed the top activity.
   438	                    if (doResume) {
   439	                        resumeTopActivityLocked(null);
   440	                    }
   441	                    return START_DELIVERED_TO_TOP;
   442	                }
   443	            } else if (!addingToTask &&
   444	                    (launchFlags&Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
   445			// sunway:
   446
   447			// case 3;
   448			// REORDER_TO_FRONT是非NEW_TASK的专利
   449			// 若当前task的stack为A,B,C; C调用startActivity(B),则执行后的结
   450			// 果为A,C,B;
   451			// 即B会被reorder to front
   452			//
   453			// 到目前为止可以导致onNewIntent的标志:
   454			// 1. SINGLE_INSTANCE, SINGLE_TASK
   455			// 2. MULTIPLE & SINGLE_TOP
   456			// 3. REORDER_TO_FRONT
   457
   458
   459	                // In this case, we are launching an activity in our own task
   460	                // that may already be running somewhere in the history, and
   461	                // we want to shuffle it to the front of the stack if so.
   462	                int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
   463	                if (where >= 0) {
   464	                    HistoryRecord top = moveActivityToFrontLocked(where);
   465	                    logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
   466	                    deliverNewIntentLocked(top, r.intent);
   467	                    if (doResume) {
   468	                        resumeTopActivityLocked(null);
   469	                    }
   470	                    return START_DELIVERED_TO_TOP;
   471	                }
   472	            }
   473	            // An existing activity is starting this new activity, so we want
   474	            // to keep the new one in the same task as the one that is starting
   475	            // it.
   476	            r.task = sourceRecord.task;
   477	            if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
   478	                    + " in existing task " + r.task);
   479
   480	        } else {
   481	            // This not being started from an existing activity, and not part
   482	            // of a new task...  just put it in the top task, though these days
   483	            // this case should never happen.
   484	            final int N = mHistory.size();
   485	            HistoryRecord prev =
   486	                N > 0 ? (HistoryRecord)mHistory.get(N-1) : null;
   487	            r.task = prev != null
   488	                ? prev.task
   489	                : new TaskRecord(mCurTask, r.info, intent,
   490	                        (r.info.flags&ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
   491	            if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
   492	                    + " in new guessed " + r.task);
   493	        }
   494	        if (newTask) {
   495	            EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.task.taskId);
   496	        }
   497	        logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);
   498
   499		// sunway:
   500		//
   501		// 经过九九八十一难,到这里才真正调用onCreate;回想前面的种种, 有些
   502		// activity被kill掉了, 有些被移动到前台并被resume了, 能收到onNewIntent调
   503		// 用都算不错了; 能真正因为startActivity导致onCreate被调用的有多少?
   504
   505	        startActivityLocked(r, newTask, doResume);
   506	        return START_SUCCESS;
   507	    }
   508
   509
   510
   511
   512	private HistoryRecord findTaskLocked(Intent intent, ActivityInfo info) {
   513	        ComponentName cls = intent.getComponent();
   514	        if (info.targetActivity != null) {
   515	            cls = new ComponentName(info.packageName, info.targetActivity);
   516	        }
   517
   518	        TaskRecord cp = null;
   519
   520	        final int N = mHistory.size();
   521	        for (int i=(N-1); i>=0; i--) {
   522	            HistoryRecord r = (HistoryRecord)mHistory.get(i);
   523	            if (!r.finishing && r.task != cp
   524	                    && r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
   525
   526			// sunway:
   527			// launchMode!=SINGLE_INSTANCE这个条件可用避免这种情况:
   528			// 当前mHistory对于同一个affinity有多个task (只有一种可能:一个为正常的task,
   529			// 其他的均为SINGLE_INSTANCE); 通过这个条件判断,可以避免findTask
   530			// 时找到SINGLE_INSTANCE的task (这种task即使找到也不可能往上添加
   531			// 其他activity, 结果还是要新建一个task, 但实际上该
   532			// SINGLE_INSTANCE下面明明有一个可用的`正常`task...最后会导致task越
   533			// 来越多)
   534
   535	                cp = r.task;
   536	                //Slog.i(TAG, "Comparing existing cls=" + r.task.intent.getComponent().flattenToShortString()
   537	                //        + "/aff=" + r.task.affinity + " to new cls="
   538	                //        + intent.getComponent().flattenToShortString() + "/aff=" + taskAffinity);
   539	                if (r.task.affinity != null) {
   540	                    if (r.task.affinity.equals(info.taskAffinity)) {
   541	                        //Slog.i(TAG, "Found matching affinity!");
   542	                        return r;
   543	                    }
   544	                } else if (r.task.intent != null
   545	                        && r.task.intent.getComponent().equals(cls)) {
   546	                    //Slog.i(TAG, "Found matching class!");
   547	                    //dump();
   548	                    //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
   549	                    return r;
   550	                } else if (r.task.affinityIntent != null
   551	                        && r.task.affinityIntent.getComponent().equals(cls)) {
   552	                    //Slog.i(TAG, "Found matching class!");
   553	                    //dump();
   554	                    //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
   555	                    return r;
   556	                }
   557	            }
   558	        }
   559
   560	        return null;
   561	    }
   562
   563
   564	    private final HistoryRecord resetTaskIfNeededLocked(HistoryRecord taskTop,
   565	            HistoryRecord newActivity) {
   566		// sunway:
   567		// resetTaskIfNeeded, 是RESET_TASK_IF_NEED intent flag导致的调用
   568		// launcher在启动activity时会使用NEW_TASK & RESET_TASK_IF_NEED 标志
   569		// 所以该标志和launch有关, 实际上, activity的四个属性:
   570		// 1. CLEAR_TASK_ON_LAUNCH
   571		// 2. FINISH_ON_TASK_LAUNCH
   572		// 3. ALLOW_TASK_REPARENTING
   573		// 4. ALWAYS_RETAIN_TASK_STATE
   574		// 都只是和这个标志有关
   575		// 另外, CLEAR_WHEN_TASK_RESET intent flag 也只和这个标志有关.
   576		// Q: RESET_TASK是干什么?
   577		// Q: IF_NEEDED是什么意思?
   578
   579	        boolean forceReset = (newActivity.info.flags
   580	                &ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
   581
   582		// sunway:
   583		// ACTIVITY_INACTIVE_RESET_TIME 为 30 分钟
   584		// 当task.getInactiveDuration > 30 min时, 表示该task需要被forceReset了, 这也
   585		// 许就是IF_NEEDED的要表达的意思(之一)?
   586
   587
   588	        if (taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME) {
   589	            if ((newActivity.info.flags
   590	                    &ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0) {
   591			// sunway:
   592			// 若root activity设置了这个属性,可以避免空闲30分钟后整个task被
   593			// reset (reset case 1)
   594			// 但对case 2,3 无效
   595	                forceReset = true;
   596	            }
   597	        }
   598
   599		// sunway:
   600		// 所谓 reset task, 是指要从当前task中找出哪些activity需要被reset
   601		// (finish), 主要分为三种情况:
   602		// case 1. 整个task的所有activity被需要被reset
   603		// case 2. 某个或某些activity需要被reset
   604		// case 3. 还要考虑更复杂的ALLOW_TASK_REPARENTING属性
   605
   606	        final TaskRecord task = taskTop.task;
   607
   608	        // We are going to move through the history list so that we can look
   609	        // at each activity 'target' with 'below' either the interesting
   610	        // activity immediately below it in the stack or null.
   611	        HistoryRecord target = null;
   612	        int targetI = 0;
   613	        int taskTopI = -1;
   614	        int replyChainEnd = -1;
   615	        int lastReparentPos = -1;
   616
   617		// sunway:
   618		// 遍历mHistory的所有activity, top --> bottom
   619
   620	        for (int i=mHistory.size()-1; i>=-1; i--) {
   621	            HistoryRecord below = i >= 0 ? (HistoryRecord)mHistory.get(i) : null;
   622
   623	            if (below != null && below.finishing) {
   624	                continue;
   625	            }
   626	            if (target == null) {
   627	                target = below;
   628	                targetI = i;
   629	                // If we were in the middle of a reply chain before this
   630	                // task, it doesn't appear like the root of the chain wants
   631	                // anything interesting, so drop it.
   632	                replyChainEnd = -1;
   633	                continue;
   634	            }
   635
   636	            final int flags = target.info.flags;
   637
   638		    // sunway:
   639		    // 当前activity需要被finish on task launch?
   640		    // IF_NEEDED (之二)?
   641
   642	            final boolean finishOnTaskLaunch =
   643	                (flags&ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
   644	            final boolean allowTaskReparenting =
   645	                (flags&ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
   646
   647	            if (target.task == task) {
   648			// sunway:
   649			// 我们只能reset要reset的task, 其他的task不能碰
   650
   651	                // We are inside of the task being reset...  we'll either
   652	                // finish this activity, push it out for another task,
   653	                // or leave it as-is.  We only do this
   654	                // for activities that are not the root of the task (since
   655	                // if we finish the root, we may no longer have the task!).
   656	                if (taskTopI < 0) {
   657	                    taskTopI = targetI;
   658	                }
   659	                if (below != null && below.task == task) {
   660	                    final boolean clearWhenTaskReset =
   661	                            (target.intent.getFlags()
   662	                                    &Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
   663	                    if (!finishOnTaskLaunch && !clearWhenTaskReset && target.resultTo != null) {
   664	                        // If this activity is sending a reply to a previous
   665	                        // activity, we can't do anything with it now until
   666	                        // we reach the start of the reply chain.
   667	                        // XXX note that we are assuming the result is always
   668	                        // to the previous activity, which is almost always
   669	                        // the case but we really shouldn't count on.
   670	                        if (replyChainEnd < 0) {
   671	                            replyChainEnd = targetI;
   672	                        }
   673	                    } else if (!finishOnTaskLaunch && !clearWhenTaskReset && allowTaskReparenting
   674	                            && target.taskAffinity != null
   675	                            && !target.taskAffinity.equals(task.affinity)) {
   676
   677				// sunway:
   678	                        // 若当前处理的activity是从别的地方`收养`的
   679	                        // (allowTaskReparenting为真,且它的affinity和要reset的
   680	                        // task的affinity不同), 而且它不想死,那么放了它(从哪来的
   681	                        // 回哪去,或者自立门户)
   682	                        //
   683	                        //
   684	                        // If this activity has an affinity for another
   685	                        // task, then we need to move it out of here.  We will
   686	                        // move it as far out of the way as possible, to the
   687	                        // bottom of the activity stack.  This also keeps it
   688	                        // correctly ordered with any activities we previously
   689	                        // moved.
   690	                        HistoryRecord p = (HistoryRecord)mHistory.get(0);
   691	                        if (target.taskAffinity != null
   692	                                && target.taskAffinity.equals(p.task.affinity)) {
   693	                            // If the activity currently at the bottom has the
   694	                            // same task affinity as the one we are moving,
   695	                            // then merge it into the same task.
   696	                            target.task = p.task;
   697	                            if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
   698	                                    + " out to bottom task " + p.task);
   699	                        } else {
   700	                            mCurTask++;
   701	                            if (mCurTask <= 0) {
   702	                                mCurTask = 1;
   703	                            }
   704	                            target.task = new TaskRecord(mCurTask, target.info, null,
   705	                                    (target.info.flags&ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
   706	                            target.task.affinityIntent = target.intent;
   707	                            if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
   708	                                    + " out to new task " + target.task);
   709	                        }
   710	                        mWindowManager.setAppGroupId(target, task.taskId);
   711	                        if (replyChainEnd < 0) {
   712	                            replyChainEnd = targetI;
   713	                        }
   714	                        int dstPos = 0;
   715	                        for (int srcPos=targetI; srcPos<=replyChainEnd; srcPos++) {
   716	                            p = (HistoryRecord)mHistory.get(srcPos);
   717	                            if (p.finishing) {
   718	                                continue;
   719	                            }
   720	                            if (DEBUG_TASKS) Slog.v(TAG, "Pushing next activity " + p
   721	                                    + " out to target's task " + target.task);
   722	                            task.numActivities--;
   723	                            p.task = target.task;
   724	                            target.task.numActivities++;
   725	                            mHistory.remove(srcPos);
   726	                            mHistory.add(dstPos, p);
   727	                            mWindowManager.moveAppToken(dstPos, p);
   728	                            mWindowManager.setAppGroupId(p, p.task.taskId);
   729	                            dstPos++;
   730	                            if (VALIDATE_TOKENS) {
   731	                                mWindowManager.validateAppTokens(mHistory);
   732	                            }
   733	                            i++;
   734	                        }
   735	                        if (taskTop == p) {
   736	                            taskTop = below;
   737	                        }
   738	                        if (taskTopI == replyChainEnd) {
   739	                            taskTopI = -1;
   740	                        }
   741	                        replyChainEnd = -1;
   742	                        addRecentTaskLocked(target.task);
   743	                    } else if (forceReset || finishOnTaskLaunch
   744	                            || clearWhenTaskReset) {
   745
   746				// sunway:
   747	                        // 经过若干次循环后,确定了要reset的activity的范围,开始reset
   748	                        // 其中, CLEAR_WHEN_TASK_RESET和CLEAR_TOP行为相似,都使
   749	                        // 该activity以上被finish,但前者会限制上限为当前task
   750
   751	                        // If the activity should just be removed -- either
   752	                        // because it asks for it, or the task should be
   753	                        // cleared -- then finish it and anything that is
   754	                        // part of its reply chain.
   755	                        if (clearWhenTaskReset) {
   756	                            // In this case, we want to finish this activity
   757	                            // and everything above it, so be sneaky and pretend
   758	                            // like these are all in the reply chain.
   759	                            replyChainEnd = targetI+1;
   760	                            while (replyChainEnd < mHistory.size() &&
   761	                                    ((HistoryRecord)mHistory.get(
   762	                                                replyChainEnd)).task == task) {
   763	                                replyChainEnd++;
   764	                            }
   765	                            replyChainEnd--;
   766	                        } else if (replyChainEnd < 0) {
   767	                            replyChainEnd = targetI;
   768	                        }
   769	                        HistoryRecord p = null;
   770	                        for (int srcPos=targetI; srcPos<=replyChainEnd; srcPos++) {
   771	                            p = (HistoryRecord)mHistory.get(srcPos);
   772	                            if (p.finishing) {
   773	                                continue;
   774	                            }
   775	                            if (finishActivityLocked(p, srcPos,
   776	                                    Activity.RESULT_CANCELED, null, "reset")) {
   777	                                replyChainEnd--;
   778	                                srcPos--;
   779	                            }
   780	                        }
   781	                        if (taskTop == p) {
   782	                            taskTop = below;
   783	                        }
   784	                        if (taskTopI == replyChainEnd) {
   785	                            taskTopI = -1;
   786	                        }
   787	                        replyChainEnd = -1;
   788	                    } else {
   789	                        // If we were in the middle of a chain, well the
   790	                        // activity that started it all doesn't want anything
   791	                        // special, so leave it all as-is.
   792	                        replyChainEnd = -1;
   793	                    }
   794	                } else {
   795	                    // Reached the bottom of the task -- any reply chain
   796	                    // should be left as-is.
   797	                    replyChainEnd = -1;
   798	                }
   799
   800	            } else if (target.resultTo != null) {
   801	                // If this activity is sending a reply to a previous
   802	                // activity, we can't do anything with it now until
   803	                // we reach the start of the reply chain.
   804	                // XXX note that we are assuming the result is always
   805	                // to the previous activity, which is almost always
   806	                // the case but we really shouldn't count on.
   807	                if (replyChainEnd < 0) {
   808	                    replyChainEnd = targetI;
   809	                }
   810
   811	            } else if (taskTopI >= 0 && allowTaskReparenting
   812	                    && task.affinity != null
   813	                    && task.affinity.equals(target.taskAffinity)) {
   814			// sunway:
   815			// 如果其它task中有从当前task`过继`过去的activity, 那么也会reset
   816			// 它,或者会把它move回当前task (根据IF_NEEDED)
   817
   818	                // We are inside of another task...  if this activity has
   819	                // an affinity for our task, then either remove it if we are
   820	                // clearing or move it over to our task.  Note that
   821	                // we currently punt on the case where we are resetting a
   822	                // task that is not at the top but who has activities above
   823	                // with an affinity to it...  this is really not a normal
   824	                // case, and we will need to later pull that task to the front
   825	                // and usually at that point we will do the reset and pick
   826	                // up those remaining activities.  (This only happens if
   827	                // someone starts an activity in a new task from an activity
   828	                // in a task that is not currently on top.)
   829			Slog.e("sunway", "AMS:206");
   830	                if (forceReset || finishOnTaskLaunch) {
   831			    Slog.e("sunway", "AMS:208");
   832	                    if (replyChainEnd < 0) {
   833	                        replyChainEnd = targetI;
   834	                    }
   835	                    HistoryRecord p = null;
   836	                    for (int srcPos=targetI; srcPos<=replyChainEnd; srcPos++) {
   837	                        p = (HistoryRecord)mHistory.get(srcPos);
   838	                        if (p.finishing) {
   839	                            continue;
   840	                        }
   841				Slog.e("sunway", "AMS:218");
   842	                        if (finishActivityLocked(p, srcPos,
   843	                                Activity.RESULT_CANCELED, null, "reset")) {
   844	                            taskTopI--;
   845	                            lastReparentPos--;
   846	                            replyChainEnd--;
   847	                            srcPos--;
   848	                        }
   849	                    }
   850	                    replyChainEnd = -1;
   851	                } else {
   852			    Slog.e("sunway", "AMS:229");
   853	                    if (replyChainEnd < 0) {
   854	                        replyChainEnd = targetI;
   855	                    }
   856	                    for (int srcPos=replyChainEnd; srcPos>=targetI; srcPos--) {
   857	                        HistoryRecord p = (HistoryRecord)mHistory.get(srcPos);
   858	                        if (p.finishing) {
   859	                            continue;
   860	                        }
   861	                        if (lastReparentPos < 0) {
   862	                            lastReparentPos = taskTopI;
   863	                            taskTop = p;
   864	                        } else {
   865	                            lastReparentPos--;
   866	                        }
   867	                        mHistory.remove(srcPos);
   868	                        p.task.numActivities--;
   869	                        p.task = task;
   870	                        mHistory.add(lastReparentPos, p);
   871	                        if (DEBUG_TASKS) Slog.v(TAG, "Pulling activity " + p
   872	                                + " in to resetting task " + task);
   873	                        task.numActivities++;
   874	                        mWindowManager.moveAppToken(lastReparentPos, p);
   875	                        mWindowManager.setAppGroupId(p, p.task.taskId);
   876	                        if (VALIDATE_TOKENS) {
   877	                            mWindowManager.validateAppTokens(mHistory);
   878	                        }
   879	                    }
   880	                    replyChainEnd = -1;
   881
   882	                    // Now we've moved it in to place...  but what if this is
   883	                    // a singleTop activity and we have put it on top of another
   884	                    // instance of the same activity?  Then we drop the instance
   885	                    // below so it remains singleTop.
   886	                    if (target.info.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
   887	                        for (int j=lastReparentPos-1; j>=0; j--) {
   888	                            HistoryRecord p = (HistoryRecord)mHistory.get(j);
   889	                            if (p.finishing) {
   890	                                continue;
   891	                            }
   892	                            if (p.intent.getComponent().equals(target.intent.getComponent())) {
   893	                                if (finishActivityLocked(p, j,
   894	                                        Activity.RESULT_CANCELED, null, "replace")) {
   895	                                    taskTopI--;
   896	                                    lastReparentPos--;
   897	                                }
   898	                            }
   899	                        }
   900	                    }
   901	                }
   902	            }
   903
   904	            target = below;
   905	            targetI = i;
   906	        }
   907
   908	        return taskTop;
   909		// sunway:
   910		// 总结:
   911		// RESET_TASK是指有些activity会被finish,有些会被move (ALLOW_TASK_REPARENTING)
   912		// IF_NEEDED因为有三层含义:
   913		//   1. task inactive超过30 min后会被CLEAR_TASK_ON_LAUNCH
   914		//   2. 有些activity若设置了FINISH_ON_TASK_LAUNCH属性或有
   915		//      CLEAR_WHEN_TASK_RESET intent flag, 会被finish
   916		//   3. 有些activity若设置了ALLOW_TASK_REPARENTING, 会被moved, 或者被finish
   917		// 一般只有launcher会 reset task
   918	    }
#+END_EXAMPLE
****** analysis
#+BEGIN_EXAMPLE
      startActivityUnchecked(HistoryRecord r, HistoryRecord sourceRecord, ...)
      // r is the activity to be start; sourceRecord is the activity that issues the startActivity, for notification, service..., sourceRecord is null
        if (sourceRecord==null):
	// This activity is not being started from another...  in this case, always start new task
	  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
        else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
	// original Activity is SINGLE_INSTANCE launchMode
	  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
	else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
	         or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
	  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;

	if (r.resultTo != null && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
	  // NEW_TASK is set, but requires Activity result, so just cancel the result
          sendActivityResultLocked(-1,...)

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0 ...):
	  HistoryRecord taskTop=findTaskLocked(intent, r.info);
	     // find the target task complies with r, according to affinity, compnent, .... from mHistory, top --> bottom
	     // findTaskLocked will return the top activity in any existing task matching the given intent
	     // typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered
	     // How taskAffinity is null? if activity's taskAffinity property is set to "" (see `Notification`), then it's taskAffinity will be set to null
	  if (taskTop!=null):
	  // found an target task, may try to foreground the task
	  // else jump to endif of ..launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK..
	    HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);
	    // find the current top activity's task
	    if (curTop.task != taskTop.task):
	    // target task is in background, will try to foreground target task, unless ...
	      boolean callerAtFront = sourceRecord == null  || curTop.task == sourceRecord.task;
	      // whether the startActivity action is issued from an obscured activity
	      // we prefer that an obscured activity can't moveTaskToFront
	      if (callerAtFront):
	        moveTaskToFrontLocked(taskTop.task, r);
		// move all the activities belonging to target task to the top of mHistory
	      if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0):
	        // reset task if need, another dragon~
	        taskTop = resetTaskIfNeededLocked(taskTop, r);
            if ((launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
                 or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
                 or r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
	      HistoryRecord top = performClearTaskLocked(taskTop.task.taskId, r, launchFlags, true);
	      // clear the *mHistory* from top to the target *artivity*
	      // note that: if target is successfully moved to front beforehand,
	      // clearTask will actually only clear the target task, instead of the whole mHistory
	        // for each activity from mHistory.top downto target activity, finish it!
		// for the target activity, if it has the SINGLE_TOP flag, do nothing and return it, else finish it!
	      if (top!=null):
	        // target activity has the SINGLE_TOP flag, thus not finished
		deliverNewIntentLocked(top, r.intent);
	      else:
	        // target activity has been finished, place a new one on the task
		addingToTask = true;  // future actions will be taken if addingToTask is true, which means we need add the target activity to target task
		                      // addingToTask means `startNewActivity`
	    else if (r.realActivity.equals(taskTop.task.realActivity)): // else of clear_top
	      // In this case the top activity on the task is the
              // same as the one being launched, so we take that
              // as a request to bring the task to the foreground.
	      if (!r.intent.filterEquals(taskTop.task.intent)):
	      // we are trying to restart target task's root activity, but with a different intent, we should start a new instance on top
	      // else, do nothing (since the target task is already brought to front)
	        addingToTask = true;
            // if CLEAR_TOP ends here
	    if (!addingToTask):
	    // new instance should not be started, e.g. CLEAR_TOP will SINGLE_TOP; starting target task's root activity with the same intent
	      resumeTopActivity()
	      return;
	// if NEW_TASK end here

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// when we reach here:
	// 1. activity w/o NEW_TASK
	// 2. activity w/ NEW_TASK but doesn't found the target task

        HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
	if (top.realActivity.equals(r.realActivity)):
	  if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
	    or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
            or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
	      resumeTopActivityLocked(null);
	      deliverNewIntentLocked(top, r.intent);
	      return;
	if (!addingToTask  && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
	  // case 2.
          r.task = new TaskRecord(mCurTask, r.info, intent,...)
	else if (!addingToTask && (launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0):
	  // case 1.
	  HistoryRecord top = performClearTaskLocked(sourceRecord.task.taskId, r, launchFlags, true);
	  if (top != null):
	    deliverNewIntentLocked(top, r.intent);
	    return;
	else if (!addingToTask && (launchFlags&Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0):
	  // case 1.
	  // In this case, we are launching an activity in our own task
          // that may already be running somewhere in the history, and
          // we want to shuffle it to the front of the stack if so.
	  int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
	    // if sourceRecord.task is not the top task in mHistory, return -1, else return the index of r in mHistory
	  HistoryRecord top = moveActivityToFrontLocked(where);
          deliverNewIntentLocked(top, r.intent);
          resumeTopActivityLocked(null);
	  return;
        // if NEW_TASK ends here

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// all launchMode and flag is considered, if control flow still reach here ... startActivity!
	startActivityLocked(r, newTask, doResume);
	return;
#+END_EXAMPLE
      simplified procedure:

#+BEGIN_EXAMPLE
      if NEW_TASK:
        if found target task:
          moveTaskToFront()
	  clearTop
	  starting with the same intent with target task?
      single_top
      new task
      clear_top
      reorder_to_front
      startActivity
#+END_EXAMPLE

      To summarize:
      1. FLAG\_ACTIVITY\_NEW\_TASK may be set implicitly, e.g.
	 - starting activity from service, notification ..., where sourceRecord==null
	 - target activity is SINGLE\_INSTANCE, SINGLE\_TASK
	 - sourceRecord is in SINGLE\_INSTANCE
      2. FLAG\_ACTIVITY\_NEW\_TASK has two means:
	 1. if target task exists: `moveTaskToFront`
	 2. if not: start new task
      3. moveTaskToFront must meet 3 conditions:
	 1. NEW\_TASK
	 2. target task exists and is in background
	 3. sourceRecord is null or sourceRecord is the top activity,
	    that is, only notification, service and curTop activity can move a background task to front through NEW\_TASK
      4. CLEAR\_TOP
	 CLEAR\_TOP will clear all the activities in *mHistory* on top of target activity, so  CLEAR\_TOP should be used in two ways:
	 1. in most cases, CLEAR\_TOP should be used in conjunction with NEW\_TASK, so that, before clear top, the target task is moveTaskToFront,
	    thus the succeeding CLEAR\_TOP will be restrict to the target task
	 2. CLEAR\_TOP can be used w/o NEW\_TASK, but make sure the sourceRecord is the foreground task, or else all the activities on top of it will
	    be finished.
      5. REORDER\_TO\_FRONT
	 1. should *ONLY* be called by foreground task, or else the flag will not take effect
	 because CLEAR\_TOP condition is judged before REORDER\_TO\_FRONT, so if CLEAR\_TOP is set, REORDER\_TO\_FRONT is ignored
	 What's more: REORDER\_TO\_FRONT will only take effect if NEW\_TASK
      6. deliverNewIntent
	 deliverNewIntent will occurs in two cases:
	 1. SINGLE\_TOP, w/ or w/o NEW\_TASK
	 2. REORDER\_TO\_FRONT
***** TODO Launcher & Task
***** resetTaskIfNeededLocked
      FLAG\_ACTIVITY\_NEW\_TAKS && FLAG\_ACTIVITY\_RESET\_TASK\_IF\_NEEDED will trigger resetTaskIfNeededLocked

      Typically, only launcher will set those two flags to resetTaskIfNeededLocked, but we still can set those flags manually to
      trigger resetTaskIfNeededLocked

#+BEGIN_EXAMPLE
      resetTaskIfNeededLocked
        // whether the launching activity has the property `CLEAR_TASK_ON_LAUNCH`
        boolean forceReset = (newActivity.info.flags &ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
	// if the target task has been inactive for ACTIVITY_INACTIVE_RESET_TIME (30 min)
	// and the target's *root* activity doesn't have the ALWAYS_RETAIN_TASK_STATE property, also set forceReset to true
	// that is what the phrase `IfNeed` means
	if (taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME):
          if ((newActivity.info.flags &ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0):
            forceReset = true;
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	foreach HistoryRecord of the target task in mHistory (from top --> bottom):
	  // should the activity be finished on task launch?
	  boolean finishOnTaskLaunch = (flags&ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
	  // should the activity has ALLOW_TASK_REPARENTING property?
          boolean allowTaskReparenting = (flags&ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
	  // should the activity clear it's top when task reset?
          boolean clearWhenTaskReset = (target.intent.getFlags()&Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
	  if (!finishOnTaskLaunch && !clearWhenTaskReset && allowTaskReparenting
	      && !target.taskAffinity.equals(task.affinity)):
	    // if the activity is ALLOW_TASK_REPARENTING and it's affinity is different with target task ...
	    // that is , the activity is reparent from somewhere else ... , so detach it, instead of kill it.
	    // however, ALLOW_TASK_REPARENTING can only overide forceReset: finishOnTaskLaunch and clearWhenTaskReset can still kill it.
	    // ALLOW_TASK_REPARENTING is flexible: it can be attached/detached from a TO-BE-RESET task.
	  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	  if (forceReset || finishOnTaskLaunch || clearWhenTaskReset ):
	    if (clearWhenTaskReset):
	      // finish all the actvities of the target task above the launching activity.
	    finish current activity
	  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
          else if (taskTopI >= 0 && allowTaskReparenting && task.affinity.equals(target.taskAffinity)):
	    // We are inside of another task...  if this activity has an affinity for our task, then either remove it if we are
            // clearing or attach it to our task
#+END_EXAMPLE

      To summarize:
      - CLEAR\_TASK\_ON\_LAUNCH property will clear the task when re-launch the task from launcher, (only meaningful for root activity)
      - if task has been inactive for 30 min, it will also be CLEAR\_TASK\_ON\_LAUNCH, unless RETAIN\_TASK\_STATE property is set
	RETAIN\_TASK\_STATE is closely related to the 30 min thresh-hold, (only meaningful for root activity)
      - FINISH\_ON\_TASK\_LAUNCH property vs. CLEAR\_WHEN\_TASK\_RESET intent flag (not only meaningful for root activity)
      - ALLOW\_TASK\_REPARENTING is flexible: it can be detached/attached from a TO-BE-RESET task

***** affinity
      2010-11-15
      1. One task's affinity is the root activity's task affinity.
      2. activity's task affinity, if not specified in manifest, is set to the activity's package name, by default.
      3. activity's task affinity can be *null*:
	 if activity's taskAffinity property is set to "" (see [[Notification]]), then it's taskAffinity will be set to null
      4. Affinity will affect activity in two ways:
	 1. When activity A calls startActivity(B) to start B activity, B will be
	    put into the same task as A, but if the calling intent set the flag
	    FLAG_NEW_TASK
	    2. if there is already ONE task whose affinity is identical with B's
               affinity (including the origina task), B will be put into that
               task. so, if orig task's affinity is the same as B's affinity,B will still be placed into the orig task
	    3. if there is no task whose affinity is identical with B's
               affinity, B will be put into a new task. So the FLAG_NEW_TASK is
               a little ambiguous, maybe it should be named
               FLAG_NEW_OR_EXIST_TASK.
	 2. If A call startActivity(B) to start B activity, and the calling
	   task's affinity is same as B's affinity, and B has set the activity
	   property: AllowTaskReparenting, then B will be `reparented` to the
	   calling task.
***** launch mode
****** standard
****** singleTop
****** singleInstance
****** singleTask
***** Intent flag
****** FLAG_ACTIVITY_NEW_TASK
****** FLAG_ACTIVITY_CLEAR_TOP
****** FLAG_ACTIVITY_SINGLE_TOP
****** FLAG_ACTIVITY_REORDER_TO_FRONT
****** FLAG_ACTIVITY_RESET_TASK_IF_NEEDED [launch related]
****** FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET [launch related]
       stronger CLEAR_TOP?
****** FLAG_ACTIVITY_MULTIPLE_TASK
****** FLAG_ACTIVITY_FORWARD_RESULT
****** FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
***** Properties
****** FINISH_ON_TASK_LAUNCH  [launch related]
****** CLEAR_TASK_ON_LAUNCH  [launch related]
       activity must be taks's root activity
****** ALLOW_TASK_REPARENTING
****** ALWAYS_RETAIN_TASK_STATE
*** Service							    :service:
**** startService
#+BEGIN_EXAMPLE
	startServiceLocked()
	   retrieveServiceLocked()
	     checkComponentPermission()
	   bringUpServiceLocked()
	      if serviceRecord.app and app.thread is not null,
	           sendServiceArgs()
	              thread.scheduleServiceArgs()
	                  service.onStartCommand()
	       else
	           getProcessRecord(appName)
	           if app or thread is not null (process is ready)
	               realStartService()
	                  thread.scheduleCreate..
	           else
	               startProcess()
	                  start ActivityThread
	               add service to mPendingSer..
#+END_EXAMPLE

#+BEGIN_EXAMPLE
	New process:
	  ActivityThread::attach()
	     AMS::attachApplication()
	        foreach mPendingServices:
	           realStartService()
	                thread.scheduleCreate..
#+END_EXAMPLE
**** bindService &  unbindService
***** ServiceConnection
      ServiceConnection itself is binder proxy, which only implement one method:
#+BEGIN_EXAMPLE
      void connected(ComponentName name, IBinder service) throws RemoteException;
#+END_EXAMPLE
      through ServiceConnection.connected(), service can notify the *client* about service bound/unbound.

      so the client must implement the ServiceConnection stub, actually, ActivityThread maintains one
#+BEGIN_EXAMPLE
      HashMap<Context, HashMap<ServiceConnection, ServiceDispatcher>> mServices
#+END_EXAMPLE
      while ServiceDispatcher maintains the ServiceConnection stub. AMS will notify the client directly through ServiceConnection stub in ActivityThread
      To summarize:
	 1. ServiceConnection is a stub implement in ActivityThread, AMS use it to notify client
	 2. ServiceConnection are maintained by ActivityThread, Activity.destroy will not affect the connection.
***** bindService
#+BEGIN_EXAMPLE
      int bindService(IServiceConnection connection,...);; connection is the binder proxy supplied by client
        mServiceConnections.put(binder, c); ;; AMS save the proxy for later use
         if ((flags&Context.BIND_AUTO_CREATE) != 0):  ;; if BIND_AUTO_CREATE flag is set, will bring up the service
           bringUpServiceLocked(s, service.getFlags(), false);
	     ;; may start process --> create service --> start service ...
           return 0;
         if (s.app != null && b.intent.received):
	   connection.connected(s.name, b.intent.binder); ;; notify client by onServiceConnected
#+END_EXAMPLE
***** unbindService
#+BEGIN_EXAMPLE
        mServiceConnections.remove(connection);
        s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());
	if ((c.flags&Context.BIND_AUTO_CREATE) != 0):
          bringDownServiceLocked(s, false);
	    if (!force && r.startRequested):  // startService will set r.startRequested to true, that why unbindService won't bring down service if it is
	                                      // started by startService
              return;
	    if (r.connections.size() > 0):
	      for each connection:
                if ((cr.flags&Context.BIND_AUTO_CREATE) != 0):  // if there is still any other connection that is BIND_AUTO_CREATE,
		                                                  // skip bring down the service
                  return;
	      for each connection:
                c.conn.connected(r.name, null);   // service is about to be brought down, notify all connections through onServiceDisconnected
	  r.app.thread.scheduleStopService(r);
#+END_EXAMPLE
	To summarize:
	  unbindService will normally stop service, unless:
	     1. the connection is not a BIND_AUTO_CREATE connection
	     2. service is started by startService
	     3. that are still other BIND_AUTO_CREATE connections bound to the service
**** ServiceRecor
d12/28/10 8:12 pm
similar with AMS::HistoryRecord. mainly save the r.ap and r.app.thread so as to interact with the service's process. .  But there is no correspondant like ActivityRecord in ActivityThread, since service needn't interqact with WMS, and it's life cycle is quite simple. (create, start, stop)
**** DONE STICKY service
     SCHEDULED: <2011-06-01 Wed> CLOSED: [2011-07-18 Mon 17:21]
     - State "DONE"       from "DOING"      [2011-07-18 Mon 17:21]
     STICKY mainly make sense when process has crashed due to uncaught exception.
     see also [[Android Process Crash and Restart]]
*** Broadcast							  :broadcast:
**** OrderedBroadcast
***** AbortBroadcast()
***** GetResult..()
***** priority
      broadcast receiver's intent filter's `priority` will be used to by the AMS to determine the order in which the broadcast is send to
***** SetResult..()
**** DONE [#C] <<<protected-broadcast>>>
     CLOSED: [2011-08-01 Mon 09:19]
     - State "DONE"       from "TODO"       [2011-08-01 Mon 09:19]
     PACKAGE_REMOVED/PACKAGE_ADDED/BOOT_COMPLETED are all protected-broadcasts, only the process with "system" uid can send the broadcast
#+BEGIN_EXAMPLE
     broadcastIntentLocked()
       if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) :
         // Always okay.
       else:
         if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) :
	   throw new SecurityException(msg);
#+END_EXAMPLE
     To summarize:
     `protected-broadcasts` means `those broadcasts can only be sent by SYSTEM,PHONE,SHELL or root`

**** DONE [#B] <<<SendBroadcast>>>
     CLOSED: [2011-02-15 Tue 19:37]
     - State "DONE"       [2011-02-15 Tue 19:37]
     12/28/10 8:11 pm
     every call to sendBroadcast will init a new receiver instance.
#+BEGIN_EXAMPLE lang:c
     AMS:broadcastIntentLocked()
       // find out who will recv this broadcast
       if intent.getComponent():
         receivers.add(r);
       else:
         if !Intent.FLAG_RECEIVER_REGISTERED_ONLY:
	   receivers=PM.queryIntentReceivers();
	 registeredReceivers = ReceiverResolver.queryIntent(); ;;ReceiverResolver is a in-memory storage that stores runtime-registered receivers
       // now, `receivers` stores receivers from PM, `registeredReceivers` stores receivers from ReceiverResolver
       if !ordered:
         BroadcastRecord r=new BroadcastRecord(registeredReceivers);
	 mParallelBroadcasts.add(r);
	 scheduleBroadcastsLocked()
	   sendMessage(BROADCAST_INTENT_MSG);
	     processNextBroadcast();
	       foreach BroadcastRecord in mParallelBroadcasts:
	         foreach receiver in BroadcastRecord:
		   deliverToRegisteredReceiver();
		     ;; make sure receiver has the requiredPermission imposed by the sender,  e.g. PERMISSION_BOOT_COMPLETED, sender can imposed a
		     ;; requiredPermission through sendBroadcast(intent,requiredPermission)
		     if r.requiredPermission!=null:
		       checkComponentPermission(r.requiredPermission,filter.receiverList.pid, filter.receiverList.uid, -1);
		     ;; make sure the sender has the requiredPermission imposed by the receiver's filter
		     if filter.requiredPermission != null:
		       checkComponentPermission(filter.requiredPermission,r.callingPid, r.callingUid, -1);
		     performReceive();
		       if app.thread !=null:
		         app.thread.scheduleRegisteredReceiver();
			   ReceiverDispatcher.performReceive() ;; for registeredReceivers, receiver class are identified by ReceiverDispatcher (which is send to
			                                       ;; AMS during registerReceiver()
			     new Args() {
			       run():
			         receiver.onReceive();
			         if ordered:
			           AMS:finishReceiver(); ;; not called here
			     }
			     H.post(Args);
         registeredReceivers=null; ;; since registeredReceivers is broadcasted already as mParallelBroadcasts, it should not be merged with receivers
       ;; if  !ordered, registeredReceivers are broadcasted all at once, without TIMEOUT consideration! SO, registeredReceivers in non-ordered broadcast
       ;; will never cause ANR!
       ;; if ordered, both registeredReceivers and receivers are merged in a single list, so that both registeredReceivers and receivers are broadcasted in
       ;; order
       merge_into_one_receiver_list();
       scheduleBroadcastsLocked();
         sendMessage();
	   processNextBroadcast();
	     r=OrderedBroadcast.get(0);
	     if r.nextReceiver>r.receivers.size():
	       removeMessages(BROADCAST_TIMEOUT_MSG);
	     r.receiverTime=now();
	     if current receiver is the first one of r:
	       sendMessageAtTime(BROADCAST_TIMEOUT_MSG,r.receiverTime+BROADCAST_TIMEOUT);
	     if current receiver is a registeredReceivers:
	       scheduleBroadcastsLocked(get Current Receiver); ;; direct call
	     else:
	       if app!=null:
	         app.thread.scheduleReceiver();
		   handlerReceiver()
		     receiver = (BroadcastReceiver)cl.loadClass(component).newInstance(); ;; for static receivers, receivers are identified by component name
		     receiver.onReceive(context.getReceiverRestrictedContext(),...)
		     AMS:finishReceiver(); ;; notify AMS that it can process next broadcast.
	       else:
	         startProcess();
		 mPendingBroadcast=r; ;; mPendingBroadcast will broadcasted when process is ready and attached to AMS

        BROADCAST_TIMEOUT_MSG's handle Message() will check whether r.receiverTime is updated, if so, that means one of Ra's receiver has returned, so
	handler will not cause an ANR
#+END_EXAMPLE
   To summarize:
   1. dynamic registered receiver
      *the same BroadcastReceiver instance is used for Multi-broadcast*
      - in non-ordered broadcast
	1. doesn't cause ANR
	2. all dynamic receivers are invoked in parallel manner (by ActivityThread's handler), i.e. one receiver's onReceive() will not block another
	   receiver's correspondent.
      - in ordered broadcast
	ANR and parallel/serial manner is the same as static registered receivers

   2. static registered receiver
      *every time broadcast is received, a new static registered receiver instance is initiated*
      - always invoked in a serial manner, i.e. one static receiver's onReceive() will block other static receiver's correspondents, no matter
	whether it is ordered. (maybe because static receiver's process is not assumed to be running, AMS need a simplified way to start all the processes)
   3. for a certain broadcast, the ANR timing begins when the first receiver is about to be handled, and ends when the last receiver has been handled,
      and, what's most important: take one broadcast contains 10 static receivers for example, _the total ANR timing can be 10*10s at most_, instead of 10s.
      because although the BROADCAST_TIMEOUT is set to be 10s, every receiver will update r.receiverTime in AMS.finishReceiver(), and the timeout handler
      will issues an ANR only when *now-r.receiverTime > BROADCAST_TIMEOUT (10s)*

   4. sendBroadcast will make sure both the sender and the receiver has been granted the requiredPermission imposed by the counterpart.
      see also protected-broadcast for another sendBroadcast limitation.

   5. Intent.FLAG_RECEIVER_REGISTERED_ONLY
**** BroadcastRecord
**** Sticky
*** ProcessRecord
**** processName
*** DONE AppDeathRecipient
    CLOSED: [2011-08-02 Tue 13:39]
    - State "DONE"       from ""           [2011-08-02 Tue 13:39]
    see also [[binder's death]]
    see also [[Android Process Crash and Restart]]
*** ActivityThread
    :PROPERTIES:
    :CUSTOM_ID: @ActivityThread
    :END:
    ActivityThread stands for the client (contract to AMS) side *process*.
    Actually, the class itself is not a Thread at all. It is a normal java class, and has ONE main(), which act as the entry point of a java process.
    ActivityThread.main()
#+BEGIN_EXAMPLE
    Looper.prepare()
    ActivityThread thread = new ActivityThread();
    thread.attach(false);
    Looper.loop();
#+END_EXAMPLE
    that is ,
    - ActivityThread.main() will start loop in the main thread, the looper is the so-call `mainLooper`
    - thread.attach() will establish reverse connection (AMS --> ActivityThread) with AMS, (set IApplicationThread IBinder to AMS.app.thread),
      so that AMS can use the IApplicationThread to interact with ActivityThread, e.g. scheduleResumeaCtivity, scheduleLaunchActivity.
      AMS use [[@AppDeathRecipient]] to reset app.thread to null, which means the process has gone.
*** DONE Android Process Crash and Restart
    SCHEDULED: <2011-07-18 Mon> CLOSED: [2011-07-18 Mon 14:39]
    - State "DONE"       from "DOING"      [2011-07-18 Mon 14:39]
      see also [[persistent application]]
      see also [[STICKY service]]
      see also [[Java Process Creation]]
      see also [[binder's death]]
      Note: we can also restart process manually by: AM.restartPackage()
  1. setDefaultUncaughtExceptionHandler during process creation
#+BEGIN_EXAMPLE
     1	    Thread.setDefaultUncaughtExceptionHandler @ RuntimeInit.java
     2	      UncaughtHandler implements Thread.UncaughtExceptionHandler
     3	        public void uncaughtException(Thread t, Throwable e):
     4		  ActivityManagerNative.getDefault().handleApplicationCrash(mApplicationObject, new ApplicationErrorReport.CrashInfo(e));
     5		  Process.killProcess(Process.myPid());
     6	          System.exit(10);
#+END_EXAMPLE
  2.  when there are ANY uncaught exception in ANY thread, AMS.handleApplicationCrash will be invoked, and then process will be killed
#+BEGIN_EXAMPLE
     1	      AMS.handleApplicationCrash()
     2	        crashApplication(r, crashInfo);
     3	          makeAppCrashingLocked()
     4	            handleAppCrashLocked(app);
     5	              // NOTE: when handling app crashing, the process is still alive, so there is still a chance for AMS to stop activity/service(s)..
     6	              // if crashing too much, stopActivity, and in SOME cases, bringDownService
     7	              if (crashTime != null && now < crashTime+MIN_CRASH_INTERVAL):
     8	                killServicesLocked(app, false);
     9	                // `killServiceLocked`, the name is quite misleading, maybe it should be named to `killOrRestartService`xs
    10	                foreach (activity of app):
    11	                  finishActivityLock();
    12	              // although crashTime interval is long enough, but if the crashed app owns the top running activity...also finish the activities
    13	              ...
    14	              foreach (service of app):
    15	                service.crashCount++;
    16	      // NOTE: any way, after handleApplicationCrash, the process will definitely be killed. But before it is killed, AMS can destroy the activity/service
    17	      // explicitly, and what's more important, restart service in some cases;
#+END_EXAMPLE
  3. Process.killProcess
     After handleApplicationCrash(), the process will be killed

     When process exit, all fd(s) will be closed; when the fd of /dev/binder is closed, binder_release() in binder.c will be called;
     binder_release will trigger the binder_death notification of the IApplicationThread binder node;
     For each Java process, AMS hold their IApplicationThread, in app.thread. Thus, when the process exit, AMS.AppDeathRecipient (which implements
     IBinder.DeathRecipient) will be notified.

     AppDeathRecipient mainly does some cleaning up of activity/service, but if the app is persistent, it will always be restarted
#+BEGIN_EXAMPLE
     AppDeathRecipient.binderDie()
       ...
       cleanUpApplicationRecordLocked()
         if (app.persistent):
           startProcessLocked(app, "restart", app.processName);
#+END_EXAMPLE

  4. AMS.killServiceLocked
#+BEGIN_EXAMPLE
     if (service.crashCount >= 2):
       bringDownServiceLocked(sr, true);
     else:
       scheduleServiceRestartLocked(sr, true);
       // after 5s, service will be restarted
       // sr.stopIfKill is true if the service is started as STICKY
       if (sr.stopIfKilled):
         if (!hasClients):
           // Whoops, no reason to restart! since no one bind the service
           bringDownServiceLocked(sr, true);
#+END_EXAMPLE
 To summaries:
   After an uncaught exception occurs in any thread, the process will crash through the registered Thread.UncaughtExceptionHandler.
   The handler will firstly finish activities, and if the service has crashed >=2 times, the service will be bringDown (service.onDestroy will be called)
   If the service is crashing for the 1st time, doesn't bring it down (service.onDestroy will not be called, although the service will be killed due to the
   process will be killed later), and schedule the restart of the service after the process is killed later.
** Alarm
** DONE [#A] Android Testing
   SCHEDULED: <2011-03-14 Mon>
   - State "DONE"       [2011-03-13 Sun 18:01]
   see [[@Instrumentation]]
   there are 3 different testing in android
     - Testing using JUnit's Test{Runner,Suite,Case}
     - Testing using AndroidTest{Runner,Suite,Case}
     - Testing using InstrumentationTest{Runner,Suite,Case}
*** JUnit TestRunner
    there are classes such as `TestSuite` and `TestCase`, but there is no `TestRunner` in android.
    if u want to kick off a JUnit testing, there are 2 alternative ways:
       1. write some `TestCase` and run the application as `JUnit TestCase` in eclipse or using cmd like `java -cp jnit.jar com.sunway.test`,
	  Note that: the testing will run in the PC side instead of android emulator or device.
       2. in the android application code, create a TestSuite instance manually, and add some TestCase to it, then invoke TestSuite.runTest() manually.
	  (similar with AndroidTestRunner)
*** AndroidTestRunner
    AndroidTestRunner, in contract with JUnit TestRunner, it maintain a Context instance (need to call AndroidTestRunner.setContext(context) to set it
    manually, then any underlying AndroidTestCase can call `getContext()` to get the Context instance.

    Q:how to kick off the testing?
    A:manually...

    if u use AndroidTestRunner, u must setup the testing manually, e.g. new AndroidTestRunner, new TestSuite, add AndroidTestCase to suite, and invoke
    runner.runTest() at last.

*** InstrumentationTestRunner
    InstrumentationTestRunner, in contract with AndroidTestRunner, it itself is a Instrumentation, and thus the Context is set automatically by
    Instrumentation.init() when AMS calls bindApplication().
    InstrumentationTestCase can call `getInstrumentation()` to get the Instrumentation instance.

    InstrumentationTestRunner extends *Instrumentation*, thus the testing can be kick-off by Instrumentation.onCreate(), in fact:
#+BEGIN_EXAMPLE
    InstrumentationTestRunner.onCreate()
      mTestRunner = getAndroidTestRunner();
      mTestRunner.setContext(getTargetContext());
      mTestRunner.setInstrumentation(this);
      mTestRunner.setTest(testSuiteBuilder.build());       ;;testSuiteBuilder will scan all the testCase automatically
      mTestRunner.addTestListener();
      start(); ;; Instrumentation.start() will start another thread and call onStart()
        onStart();
	  mTestRunner.runTest();
#+END_EXAMPLE
    that is , InstrumentationTestRunner actually is not a TestRunner, what it does is two things:
      1. reply on Instrumentation.onCreate() to kick of the testing
      2. reply on inner AndroidTestRunner to run all the test.

#+BEGIN_EXAMPLE
    AndroidTestRunner.runTest()						o
      for (TestCase testCase : mTestCases):
        setContextIfAndroidTestCase(testCase, mContext, testContext);
        setInstrumentationIfInstrumentationTestCase(testCase, mInstrumentation); ;; set mInstrumentation to InstrumentationTestCase so that they can make use
	                                                                         ;; of it.
        testCase.run(mTestResult);
#+END_EXAMPLE
*** class hierachy graph
#+BEGIN_EXAMPLE
       	       	       	       	       	       	       	      -+----------+
	     						       | TestCase |
                            				      -+-----+----+
	     						      	     |
       	       	     for unit test	     -+----------------------+---------------------+
       	       	    -+------------------------+--------------------+ 		       	   |
	     	     |		      -+------+--------+	   |   	      -+-----------+-----------+
	     	     |		       |AndroidTestCase|	   |	       |InstrumentationTestCase|
	     	     |		      -+------+--------+       	   |   	      -+-----------+-----------+
	     	     |		      	      |		       	   |	      		   |
	     	     |		   -+---------+---------+      	   |	      -+-----------+-----------+
	     	     |		    |	   		|      	   |	       |       	  	       |
	     	     |	 -+---------+------+  -+--------+------+   | -+--------+-------+       	     .....
	     	     |	  |ProviderTestCase|   |ServiceTestCase|   |  |ActivityTestCase|
	     	     |	 -+----------------+  -+---------------+   | -+--------+-------+
	     	     |			       	                   |           |
       	       	     | 	       	       	       	      -+-----------+-----------+----------------------+    for functional test
	     	     |			       	       |  	   |	       -+---------------------+---------------+
       	       	     | 	       	       	  -+-----------+---------+ |	       	| -+------------------+-------------+ |
	     	     |		           |ActivityUnitTestCase | |	       	|  | ActivityInstrumentationTestCase| |
	     	     |		       	  -+---------------------+ |	       	| -+--------------------------------+ |
		    -+---------------------------------------------+   	       -+-------------------------------------+
#+END_EXAMPLE

   - AndroidTestCase
     - AndroidTesCase.setContext()/getContext()
     - AndroidTestCase doesn't interact with AMS, e.g. ServiceTestCase has methods like startService(), but as against to
       Instrumentation.startActivitySync(), ServiceTestCase.startService() only call through to mService.start(), mContext is mainly used to access
       resource?
   - InstrumentationTestCase
     - InstrumentationTestCase can call getInstrumentation() and getContext() (mContext is set by AMS automatically)
     - ActivityInstrumentationTestCase is for functional testing: the activity under test will be create using the system infrastructure
       (by calling mInstrumentation.launchActivity) will call Instrumentation.startActivitySync to launch the activity, and perform functional testing
     - ActivityUnitTestCase  is for unit testing: the activity under test will be create with minimal connection to the system infrastructure, and you can
       invoke setActivityConetxt() to inject a mock context.
** Animation
*** TranslateAnimation
** DONE ANR
   CLOSED: [2011-06-13 Mon 10:52]
   - State "DONE"       [2011-06-13 Mon 10:52]
   see [[Strict Mode]]
*** DONE [#A] Broadcast ANR					  :broadcast:
    SCHEDULED: <2011-02-15 Tue> CLOSED: [2011-02-15 Tue 19:41]
    - State "DONE"       [2011-02-15 Tue 19:41]
    see SendBroadcast
*** TODO [#B] KeyEvent ANR					   :keyevent:
    key event is dispatched by AMS one by one, that is ,until prev key event is
    dispatched, AMS will wait to dispatching next key event, until ANR occurs.

    when key event is dispatched to ViewRoot, ViewRoot will
    diliverToViewHierachy, then notify WMS that key is dispatched.

    KeyWaiter says:
#+BEGIN_HTML
<pre lang="java" line="1">
    long keyDispatchingTimeout = 10 * 1000;
</pre>
#+END_HTML
*** DONE Service ANR						    :service:
    CLOSED: [2011-06-13 Mon 10:52]
    - State "DONE"       [2011-06-13 Mon 10:52]
AMS calls:
#+BEGIN_EXAMPLE
1. sendServiceArgs()
     bumpServiceExcuting
       sendMessageAtTime(SERVICE_TIMEOUT) (20s)
       after SERVICE_TIMEOUT (20s), appNotResponding() will be call, and ANR occurs
     app.thread.scheduleServiceArgs()
     activityThread will call service.onStart()
     activityThread calls mWindowSession.serviceDone() to tell AMS that onStart returns. then the SERVICE_TIMEOUT msg is removed

2. realStartService()
     bumpServiceExecuting()
	sendMessageAtTime(SERVICE_TIMEOUT) (20s)
     app.thread.scheduleCreateService()
     activityThread will call service.onCreate()
     activityThread calls mWindowSession.serviceDone()
#+END_EXAMPLE
** Ant & android
** ANT and android project
** Application
   see also [[Context.getApplicationContext()]]
*** DONE persistent application
    SCHEDULED: <2011-07-19 Tue> CLOSED: [2011-07-19 Tue 10:08]
    - State "DONE"       from "DOING"      [2011-07-19 Tue 10:08]
    see also [[Android Process Crash and Restart]]
    1. An application is persistent only when it is [[system application]]; 3rd application will never be taken as persistent.
    2. when the persistent application is killed (crash, killPid ...), AMS will always restart it.
    3. persistent application will be launched during system boot, before the BOOT_COMPLETED is broadcasted
** AppWidget
** TODO ASEC
   :PROPERTIES:
   :CUSTOM_ID: @ASEC
   :END:
   Android Security Executable Cache
*** dm_crypt
** Ashmem
** Audio
*** AudioFlingerService
**** Track
**** PlaybackThread
**** MixerThread
*** AudioPolicyService
*** AudioTrack
*** MediaServer
*** Higher level
**** MediaPlayer
**** MediaRecorder
**** SoundPool
**** AudioService
**** AudioRecord
*** MediaPlayerService
** Bionic libc
*** Prelink
** CANCELED [#B] Preference
   - State "CANCELED"   from "DOING"      [2011-07-26 Tue 16:25]
*** PreferenceActivity
    - PreferenceActivity extends ListActivity
    - Basic usage:
      1. setContentView(resId)
	 optional, if called, resId must contain a ListView with id="@+android/List"
      2. PreferenceActivity.addPreferencesFromResource()
    - Basically, PreferenceActivity is an Activity contains a ListView, and it delegate anything about the ListView to a inner member: PreferenceManager
*** PreferenceManager
    PreferenceManager is a utility functional object
    - PreferenceManager extends NULL
    - PreferenceManager mainly does two things:
      1. maintain the underlying SharedPreference
      2. maintain the PreferenceScreen (inflate PreferenceScreen from xml)
*** PreferenceScreen
    PreferenceScreen is one of the two core concepts of Preference  (another is Preference)
    *NOTE*: PreferenceScreen vs. ListAdapter

    - PreferenceScreen extends PreferenceGroup
    - it maintains a PreferenceGroupAdapter (extends ListAdapter), which is shown in the ListView
      The adapter will map the Preference to ListView item.
*** Preference
    *NOTE*: Preference vs. ListView item
    - when Preference is changed (through Preference.notifyChanged()), it will eventually
      invoke PreferenceScreen.PreferenceGroupAdapter.notifyDatasetChanged(), thus update the ListView.
    - when PreferenceGroupAdapter decides to getView(), it will eventually call through to Preference.getView()->Preference.onBindView()
    - Preference's builtin setTitle()/setSummary() will call notifyChanged() automatically, thus cause onBindView()
*** KeyEvent dispatch
#+BEGIN_EXAMPLE
    ListView.onItemClicked
      Preference.performClick
        Preference.mOnClickListener
	if not intercepted:
	  PreferenceActivity.OnPreferenceTreeClickListener
	if not intercepted && mIntent != null:
	  startActivity(mIntent)
#+END_EXAMPLE
*** To summurize:
    PreferenceScreen vs. ListAdapter
    Preference vs. ListItem
** PowerManagment
*** WakeLock
** ClassLoader
*** DexClassLoader
*** PathClassLoader
*** Context.getClassLoader
    see also [[Context.getClassLoader]]
** TODO [#B] ContentObserver

** ContentProvider , ContentResover & SQLite
*** ContentProvider.openFile() & ContentProvider.openInputStream()
** DONE [#A] Context
   SCHEDULED: <2011-06-02 Thu> CLOSED: [2011-06-13 Mon 16:57]
   - State "DONE"       [2011-06-13 Mon 16:57]
   Context can be used to:
   - Access application's resource and manipulate files in /data/data/xxx (through Context.mPackageInfo)
   - Context.mainThread (ActivityThread) is a interface exposed by ActivityThread to Android component, so that Context can interact with various
     system services on behalf of ActivityThread (permission checking, IApplicationThread, ...)
   - call through to many system services, e.g. AMS, PMS

   Context ( or ContextImpl ) is the facade of the running Context, it mainly represents:
     1. mPackageInfo -- the PackageInfo, represents the data, e.g. ApplicationInfo, ActivityInfo, data file (resource, asset, db ...), ClassLoader, ...
     2. mMainThread -- the ActivityThread, represents the process, e.g. looper, ApplicationThread

#+END_EXAMPLE
*** Context class hierachy
#+BEGIN_EXAMPLE
	     				           Context
 					       	      |
				   -+-----------------+---------------+
				    |	     			      |
				    |		       	       	      |
	    		     ContextWrapper    	                 ContextImpl
       	       	       	       	    |		    		      ^
	    -+------------------+---+---------+-		      |
	     |			| 	      |		 	      |
	     |			| 	      |		 	      | composition
   ContextThemeWrapper       Service   Application      	      |
  	    |	  |    	       	|      	      |		 	      |
	    |	 -+-------------+-------------+----------+------------+
        Activity

#+END_EXAMPLE
    Actually, Activity,Receiver,Service all use ContextImpl as the common implementation of the Context, but instead of inherit from ContextImpl,
    they implement from the ContextWrapper, whose `attachBaseContext()` will compose the ContextImpl as mBase, to which ContextWrapper will delegates
    all of the context functions.
*** How ContextImpl is initialized
    Take `startActivity` for example
#+BEGIN_EXAMPLE
     1	    AMS::startActivityMayWait()
     2	      ActivityInfo aInfo = ActivityThread.getPackageManager().resolveIntent().activityInfo;
     3	      startActivityLocked(...,aInfo,...)
     4	        HistoryRecord r=new HistoryRecord(...,aInfo,...)
     5		startActivityUncheckedLocked(r,...)
     6		  ...
     7		  app.thread.scheduleLaunchActivity(...,r.info,...)
     8		    // ActivityThread
     9		    ActivityRecord ar=new ActivityRecord();
    10		    ar.activityInfo=info;
    11		    performLaunchActivity(r,...)
    12		      ar.packageInfo=getPackageInfo(r.activityInfo)
    13		      // classLoader is obtained from packageInfo , or aInfo
    14		      Activity activity=mInstrumentation.newActivity(ar.packageInfo.getClassLoader(),intent.getComponent,...)
    15		      ContextImpl context=new ContextImpl(); // GOTCHA!
    16		      context.init(ar.packageInfo,r.token,this)
    17		        // mainThread=this
    18	  	        mPackageInfo = packageInfo;
    19			mResources = mPackageInfo.getResources(mainThread);
    20			mMainThread = mainThread;
    21		      activity.attach(context,...)
    22		        // call ContextWrapper.attachBaseContext() to compose the ContextImpl to mBase
    23		        attachBaseContext(context);
    24		      ....
    25		      call onCreate, onStart ...
#+END_EXAMPLE
*** Context.createPackageContext()
     Return a new Context object for the given application name.  This
     Context is the same as what the named application gets when it is
     launched, containing the same resources and class loader.  Each call to
     this method returns a new instance of a Context object; Context objects
     are not shared, however they share common state (Resources, ClassLoader,
     etc) so the Context instance itself is fairly lightweight.

     As mentioned before, Context represents both data and process. Can createPackageContext() create a Context object that we can use to run in
     other package's process? No!

#+BEGIN_EXAMPLE
     1	     createPackageContext():
     2	        ActivityThread.PackageInfo pi =  mMainThread.getPackageInfo(packageName, flags);
     3	        ContextImpl c = new ContextImpl();
     4		// notice `init` take mMainThread as the mMainThread of the created context, thus, the context still runs in the caller's process.
     5	        c.init(pi, null, mMainThread, mResources);
     6		return c;
#+END_EXAMPLE
*** Restricted Context
*** Context.getClassLoader()
*** Context.getApplicationContext()
    return an process global `Application` instance.
    - We can inherit the `Application` class and set it to the `Application` field in AndroidManifest.xml, so that getApplicationContext() can return our own `Application` instance.
    - since `Application` extends ContextWrapper and has been init with a ContextImpl, it is a context of the full functionality.
      You can use it as a `persistent` Context.
**** onCreate()
     Called when the application is stopping.  There are no more application
     objects running and the process will exit.  <em>Note: never depend on
     this method being called; in many cases an unneeded application process
     will simply be killed by the kernel without executing any application
     code.
     If you override this method, be sure to call super.onTerminate().
**** onTerminate()
**** onConfigurationChanged()
**** onLowMemory()
*** ContextImpl.getOuterContext()
    OuterContext means ContextImple's `outer` context, e.g. activity or service
** Dalvik
*** dalvik-cache
    :PROPERTIES:
    :CUSTOM_ID: @dalvik-cache
    :END:
    /data/dalvik-cache
*** TODO [#A] dex & apk file format
**** DexInv & DexOpt
** dbus
** DONE [#C] FileObserver
   SCHEDULED: <2011-02-10 Thu> CLOSED: [2011-02-10 Thu 14:55]
   - State "DONE"       [2011-02-10 Thu 14:55]
     FileObserver relies on `inotify`
     it mainly use jni to call inotify_init() to init the inotify_fd,
     then call inotify_add_watch(path) to add watch a file path,
     and at last init one ObserverThread, and run

#+BEGIN_EXAMPLE
     while (true):
       read(inotify_fd);
       env->CallVoidMethod() ;; call ObserverThread.onEvent() to notify FileObserver
#+END_EXAMPLE

** HAL								    :ARCHIVE:
** important files
*** device
    1. data/system/packages.xml
    2. /mnt/secure/asec
    3. /mnt/asec
    4. /system/etc/permissions/platform.xml
    5. /system/etc/security/cacerts.bks
    6. /data/dalvik-cache
    7. /data/property
    8. /system/build.prop
    9. /data/system/registered_services/android.accounts.AccountAuthenticator.xml
    10. /data/system/registered_services/android.content.SyncAdapter.xml
*** src
    1. framework/base/core/res
    2. framework/base/core/jni
    3. system/core/init
    4. system/core/include/private/android_filesystem_config.h
** init
*** TODO init.rc
*** DONE System init
    CLOSED: [2011-03-01 Tue 11:20]
    - State "DONE"       [2011-03-01 Tue 11:20]
    init will start some daemon, service_manager, media_service. Then call app_process to call zygoteInit.java to start zygote.
    ZygoteInit.java, first will fork and start system_server, then listen on one local socket through runSelectLoopMode().
    SystemServer.java's main() will firstly load 'android_server'.so and call
    it's init1() to start binderThreadPool and call SystemServer's init2(),
    which will init an ServerThread and start some java service like AMS, WMS.

    system_server is setuid to `system` uid.

    Note:
    zygote will keep running with `root` uid, so that zygote can setuid/gid/groups on newly forked progress, so that new java progress will run with
    proper uid/gid/groups
*** Zygote init
    app_process --> app_main.cpp: framework/base/cads/app_process
    ZygoteInit.java: framework/base/core/java/com/android/internal/os
#+BEGIN_EXAMPLE
    app_process::main()
      runtime.start("com.android.internal.os.ZygoteInit", startSystemServer);
       ZygoteInit.main()
         registerZygoteSocket();
	 startSystemServer();
	   pid = Zygote.forkSystemServer();
	   if (pid == 0):
             handleSystemServerProcess(parsedArgs);
	       closeServerSocket(); // for newly forked system_server process, close zygote socket inherited from parent
	       RuntimeInit.zygoteInit(parsedArgs.remainingArgs);
	         zygoteInitNative();
		   proc->startThreadPool();
		   invokeStaticMain(startClass, startArgs); // startClass is "com.android.server.SystemServer"
		     SystemServer.java:main()
		       System.loadLibrary("android_servers");
		       init1(args); // init1 is native method in android_servers.so
		         android_server_SystemServer_init1(JNIEnv* env, jobject clazz)
			   system_init();
			     runtime->callStatic("com/android/server/SystemServer", "init2");
			       SystemServer.java:init2()
			         Thread thr = new ServerThread();
				   // start any system service, e.g. ams, wms..
				   // prepare the looper and loop in it.
				   // the looper is TAKEN as the `main` looper  of the `system` process
				 thr.start();
			     ProcessState::self()->startThreadPool();
			     IPCThreadState::self()->joinThreadPool();
	 runSelectLoopMode();
#+END_EXAMPLE
    Q: Why SystemServer.java will call android_server.so:init1(), which will call SystemServer.java:init2()? instead of call init2() directly?
    A: android_server.so:init1() is needed because it will call `joinThreadPool` to put the process into ThreadPool. There is no java correspondent of
       joinThreadPool()

** Input Method Framework
** IntentSender
   :PROPERTIES:
   :CUSTOM_ID:       @IntentSender
   :ATTACH_DIR_INHERIT: t
   :END:
   see [[@PendingIntent]]
** Launcher							    :ARCHIVE:
** Looper & Message & Message Queue
   see [[@ActivityThread]]
**** Message Queue
****** DONE [#A] Idle Handler
       SCHEDULED: <2011-02-09 Wed> CLOSED: [2011-02-09 Wed 17:57]
       - State "DONE"       [2011-02-09 Wed 17:57]
#+BEGIN_EXAMPLE
       MessageQueue.next()
         while true:
	   msg=pullNextLocked(now)
	     foreach msg:
	       if now>msg.when:
	         return msg
	   if msg==null:
	     return msg
	   else:
	     idlers = mIdleHandlers.toArray();
	   foreach idler in idlers:
	     keep=idler.queueIdle();
	     if !keep:
               mIdleHandlers.remove(idler);
           if (mMessages != null):
             this.wait(mMessages.when-now); // if there is a message, but it's not up to date, wait until it is up to date
           else:
             this.wait();  // no message, wait until new message arrives
           // MessageQueue.enqueueMessage() will call this.notify()
#+END_EXAMPLE
******* <<<Idler>>>
	Idler class is used by ActivityThread when resumeActivity. when resumeActivity returns, ActivityThread will put one Idler in the MessageQueue,
	when the queue is idle (activity is ready), Idler.queueIdle() will be called, which will notify AMS to finish activities registered before.

**** DONE Message.obtain() & Message.recycle()
     SCHEDULED: <2011-05-28 Sat> CLOSED: [2011-05-27 Fri 14:55]
     - State "DONE"       [2011-05-27 Fri 14:55]
     - Message.obtain():
#+BEGIN_EXAMPLE
     synchronized (mPoolSync) {
         if (mPool != null) {
             Message m = mPool;
             mPool = m.next;
             m.next = null;
             return m;
         }
     }
     return new Message();
#+END_EXAMPLE
     - Message.recycle():
#+BEGIN_EXAMPLE
     synchronized (mPoolSync) {
         if (mPoolSize < MAX_POOL_SIZE) {
             clearForRecycle();
	       what = 0;
               obj = null;
               when = 0;
               target = null;
               callback = null;
	       ...
             next = mPool;
             mPool = this;
         }
     }
#+END_EXAMPLE
     - sendMessage():
#+BEGIN_EXAMPLE
       sendMessageDelayed(msg,delayMillis)
         sendMessageAtTime(msg, uptimeMillis)
	   queue.enqueueMessage(msg, uptimeMillis);
	     if (msg.when != 0):
               throw new AndroidRuntimeException(msg + " This message is already in use.");
	       msg.when = uptimeMillis;  // important
	       if (p == null || when == 0 || when < p.when): // reorder messages in queue according to msg.when
                 msg.next = p;
                 mMessages = msg;
                 this.notify(); // notify waiting
	       else:
                 Message prev = null;
                 while (p != null && p.when <= when) {
                   prev = p;
                   p = p.next;
                 }
                 msg.next = prev.next;
                 prev.next = msg;
                 this.notify();
#+END_EXAMPLE
     - Looper.loop():
#+BEGIN_EXAMPLE
       while true:
         Message msg=queue.next(); // might block
	 msg.target.dispatchMessage(msg);
	 msg.recycle()
#+END_EXAMPLE
       Note:
       Looper.loop() will recycle message automatically, thus *NEVER* invoke Message.recycle() manually!  Or else `message is already in use` exception
       will be thrown. Because: when u call recycle() manually, the message will finally be recycled twice, after the 2nd recycle(), the message list will
       have circular reference, and the succeeding obtainMessage() will definitly obtain the *same* message *again and again*

     To summarize:
     - Generally, message can't be re-used, except for the situation that `Message is firstly recycled by Message.recycle() and then reused by
       Message.obtain()`, or else any other form of Message re-use will cause exception.
     - Loop will invoke Message.recycle() automatically, thus never call it manually.
**** misc
***** Looper.setMessageLogging()
***** DONE <<<HandlerThread>>>
      CLOSED: [2011-02-24 Thu 15:00]
      - State "DONE"       [2011-02-24 Thu 15:00]
      Handy class that starting a thread with a looper, u can call HandlerThread.getLooper() to get the looper.
      note that getLooper() will block until the looper is ready.

***** Messenger
      see [[@Messenger]]
** LowMemoryKiller
*** oom adj
** misc
*** DONE [#A] bitmap recycle
    SCHEDULED: <2011-02-10 Thu> CLOSED: [2011-02-10 Thu 11:46]
    - State "DONE"       [2011-02-10 Thu 11:46]
    Bitmap.recycle() will call nativeRecycle() to release native memory used by Skia. But, we don't need call it directly, since Bitmap.finalize()
    will call it.
*** TODO [#B] android 尺寸单位 (px,pt,dp,sp..)
** TODO [#B] MountService
   :PROPERTIES:
   :CUSTOM_ID: @MountService
   :END:
   see [[@NativeDaemonConnector]]
   see [[@vold]]
#+BEGIN_EXAMPLE
		       -+------socket-------+
	   	        |	     	    |
	       	       	|    	     	    V
   MountService-----connector  	       	   vold <-----netlink-----> kernel
	   	       	^	     	    |
	   	       	|	     	    |
	       	       -+------binder-------+
#+END_EXAMPLE

** TODO NativeDaemonConnector
   :PROPERTIES:
   :CUSTOM_ID: @NativeDaemonConnector
   :END:
   see [[@MountService]]
   android use NativeDaemonConnector to interactive native daemons, including
   - vold
   - netd
   - installd
** NDK								    :ARCHIVE:
** Notification
   :PROPERTIES:
   :CUSTOM_ID: Notification
   :END:
   Notification intent will use FLAG_NEW_TASK implicitly, and the target activity *should* use blank string ("") as affinity, to reduce the risk that
   startActivity from notification falls into an existing task;

*** "" as taskAffinity
    see `startActivityUnchecked`

    activity with "" as taskAffinity will have it taskAffinity set to null; So that `findTaskLocked` in `startActivityUnchecked` will not try to find
    any existing task according to taskAffinity, instead, it will try to find the target task by the condition

                        *the target task's starting intent must be identical with the calling intent*

    which impose a stronger restriction on the target task searing, and thus reduce conflict.

    Different activities with the same "" taskAffinity will not be placed in the same task when start activty with NEW_TASK, since their starting intent is
    different.

** DONE [#A] PackageManager
   SCHEDULED: <2011-03-02 Wed> CLOSED: [2011-05-12 Thu 17:50]
   - State "DONE"       [2011-05-12 Thu 17:50]
*** Security
**** DONE [#A] Android Permission
     SCHEDULED: <2011-03-02 Wed> CLOSED: [2011-03-01 Tue 18:33]
     - State "DONE"       [2011-03-01 Tue 18:33]
     :PROPERTIES:
       :CUSTOM_ID: @Android Permission
     :END:
***** check permission during Binder transactions
      see [[Binder.getCallingPid() & Binder.getCallingUid()][getCallingPid]]
****** check `component permission` when access certain component: startService, sendBroadcast, startActivity
       see [[startService][startService]], [[sendBroadcast][sendBroadcast]], [[startActivity][startActivity]]
       note: sendBroadcast will make sure both the sender and the receiver has gained the requiredPermission imposed by the counterpart.
****** check `application permission` when access application's any component
#+BEGIN_EXAMPLE
       <application ... android:permission="xxx">  </application>
#+END_EXAMPLE
***** check permission by private API calls
      e.g. When accessing network, u need `INTERNET` permission, the network API will check permission.
***** check permission by operating system (e.g. file permission..)
      /system/etc/permissions/platform.xml reads:
#+BEGIN_EXAMPLE
      <permission name="android.permission.INTERNET" >
          <group gid="inet" />
      </permission>
      ...
#+END_EXAMPLE
      The above tags are associating low-level group IDs with permission
      names.  By specifying such a mapping, you are saying that any application
      process granted the given permission will also be running with the given
      group ID attached to its process, so it can perform any filesystem (read,
      write, execute) operations allowed for that group.

***** DONE [#B] PendingIntent / IntentSender
      SCHEDULED: <2011-03-03 Thu> CLOSED: [2011-03-07 Mon 15:15]
      - State "DONE"       [2011-03-07 Mon 15:15]
      when A's PendingIntent is delivered to B, B calls PendingIntent.send() to send the underlying intent *on behalf of* A, A's permission is also
      delegated to B

***** PermissionController Service
      PermissionController Service is a service added by ActivityManagerService though addService("permission"), it's only a encapsulation of
      AMS.checkPermission() and further PMS.checkUidPermission()

      android::checkCallingPermission() in native code use PermissionController service to check permission in native code:
#+BEGIN_EXAMPLE
      binder = defaultServiceManager()->checkService("permission");
      pc = interface_cast<IPermissionController>(binder);
      pc.checkPermission
#+END_EXAMPLE

**** DONE where is the /etc/password , /etc/shadow & /etc/group files of android?
     CLOSED: [2011-03-01 Tue 11:21]
     - State "DONE"       [2011-03-01 Tue 11:21]
       system/core/include/private/android_filesystem_config.h
       /bionic/libc/bionic/stubs.c

       progresses granted "EXTERNAL_STORAGE" permission can read/write sdcard, because these progresses will be put into `sdcard_rw` group (see [[@Android Permission]])
       but this doesn't mean that the file's owner is added into the `sdcard_rw` group beforehand, in fact, PM will maintain the group info, when
       forking the process from zygote, zygote will invoke setgroups to add the process to `sdcard_rw` group.

       typically, when user A launch a linux program, the program uid/gid/groups will be set according to user A's uid/gid/groups, but progress can also call
       setuid/gid/groups manually (with enough privilege) to reset the uid/gid/groups (zygote adopts the later approach to restrict user progress's privilege)
**** DONE secure container
     CLOSED: [2011-03-07 Mon 14:06]
     - State "DONE"       [2011-03-07 Mon 14:06]
     :PROPERTIES:
	:CUSTOM_ID: @secure_container
     :END:

       see dm_crypt [[@ASEC]] vold MountService
       when apk are installed to sdcard, for security reason, it must not be placed in the sdcard directly , instead, a security container is used to save
       the encrypted apk (xxx.asec), we need to mount (use MountService) the security container to a cached directory (/mnt/asec) to get the
       decrypted apk (pkg.apk)

      related files:
      - /data/misc/systemkeys/AppsOnSD.sks
	the *AES* key to encrypt pkg.apk and decrypt xxx.asec, all the secure container share the same key.
      - /mnt/asec/com.xx xx.xxxx/pkg.apk
	;; from init.rc

#+BEGIN_EXAMPLE
	# Secure container public mount points.
	mkdir /mnt/asec  0700 root system
	mount tmpfs tmpfs /mnt/asec mode=0755,gid=1000
#+END_EXAMPLE
	that is, /mnt/asec/ is actually mounted from a tmpfs, it's content (com.xxx.xx/pkg.apk) actually is the run-time decryption of
	/mnt/secure/asec/com.xxx.asec

      - /mnt/secure/asec/com.xxx.xxx.asec
	the secure container (encrypted apk), /mnt/asec/xxx/pkg.apk is extracted from this file in run-time

	secure container is created, mounted, umounted by MountService, which relies on `asec` executable binary to perform
	`mount,umount,create,delete..` of the secure containers:
      - how to create a secure container of 1.apk
	asec create cid
	asec mount cid /mnt/asec/xxxix
	cp 1.apk /mnt/asec/xxxx/pkg.apk
	asec umount cid

      To summarize:
      secure container is analogous to the `encrypt file system`.

      MORE DETAILS:
#+BEGIN_EXAMPLE
      $>mount
1      tmpfs /mnt/asec tmpfs rw,relatime,mode=755,gid=1000 0 0
2      /dev/block/vold/179:1 /mnt/sdcard vfat rw,dirsync,nosuid,nodev,noexec,relatime,uid=1000,gid=1015,fmask=0702,dmask=0702,allow_utime=0020,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0
3      /dev/block/vold/179:1 /mnt/secure/asec vfat rw,dirsync,nosuid,nodev,noexec,relatime,uid=1000,gid=1015,fmask=0702,dmask=0702,allow_utime=0020,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0
4      tmpfs /mnt/sdcard/.android_secure tmpfs ro,relatime,size=0k,mode=000 0 0
5      /dev/block/dm-0 /mnt/asec/com.sunway.testwebview-1 vfat ro,dirsync,nosuid,nodev,noexec,relatime,uid=1000,fmask=0222,dmask=0222,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0
#+END_EXAMPLE
      that is,
      1. sdcard is mounted as two part:
	 1. the entire sdcard is mounted to /mnt/sdcard (line 2)
	 2. sdcard/.android_secure is *bind-mount* to /mnt/secure/asec (line 3)
	    *note*: android mount the sdcard/.android_secure to tmpfs (line 4) to obscure the actual asec data on sdcard, so that normal operations
	    on sdcard won't touch asec data at run-time.
      2. /mnt/secure/asec/xxx.asec is mounted as loop device, e.g.:
	mount /mnt/secure/asec/xxx.asec -o loop=/dev/loop0
      3. cryptsetup key /dev/block/dm-0 /dev/loop0
      4. mount /dev/block/dm-0 /mnt/asec/xxxx (line 5)

      Step 3 is essential: android use `device-mapper crypto` as the `encrypt file system` behind secure container, which can mount a encrypted image file
      to a mapped device (dm-0)
**** SharedUserId
**** TODO [#A] Signature & Certificate
     :PROPERTIES:
     :ID:       c5ca7d63-57fd-407a-8275-3266f925d386
     :END:
     see also [[keytool & jarsigner]]
     google: Android APK 签名比对

     [[file:~/codebase/cb_study/build/tools/signapk/SignApk.java::for%20(String%20name%20:%20names)%20{][signApk.java]]

*** installd
    installd is a system binary running as `root` and listening on `installd` socket.
    see [[@dalvik-cache]]
    - when installing and uninstalling package, PMS need to mkdir/rmdir /data/data/xxx, but those data dirs is not accessable by PMS (PMS running with
      `system` uid, while data dirs is owned by package uids like `app_1`), so PMS need to use `installd` to access those data dir.
    - after package is installed / deleted, PMS need invoke dex_opt / rm_dex to do the dirty work like optimize dex to dalvik-cache or remove dalvik-cache,
      those works are also delegated to installd.

*** forward_lock
    adb install -l xxx.apk ( -l means `forward_lock` install )

    when xxx.apk is `forward_lock` installed
    - it's orig .apk is deleted
    - it's res/, manifest.xml is put to /data/app/xxx.zip
      (note that .dex is cached in dalvik-cache)
*** Install Package
    - there are 2 ways to install package:
       1. push xxx.apk to any folder of /data/app, /system/app, /system/framework
       2. use PackageInstaller or adb install (which will invoke PM.installPackage())

    - `system` application & 3rd application
      `system` is a property of ApplicationInfo after installation.
      `system` application are applications not listed in `downloaded` category in Settings, while 3rd applications are applications listed in `downloaded`
      category.

      PackageManager will decide whether a newly installed application is a `system` application:
      - if apk is pushed to /system/app & /system/framework, then it is `system` application
      - if apk is replacing an existing old system application, then it is.
      - ...
**** adb push
#+BEGIN_EXAMPLE
     FileObserver.onEvent()
       isApk=isPackageFilename():
         name.endsWith(".apk");
       if !isApk:return;
       if ignoreCodePath(fullPathStr):   ;; if apk name is like "xxx-1.apk", it will be ignored!
                                         ;; this is because PM.installPackage will also put installed package to /data/app, PM.installPackage use the
					 ;; special naming rule to prevent FileObserver from installing the apk again.
         return
       if ADD_EVENTS:
         scanPackageLI(mIsRom?PARSE_IS_SYSTEM:0) ;; if apk is in /system/app or /system/framework, mIsRom is true
	                                         ;; package with PARSE_IS_SYSTEM flag will be marked as `system` application
	 updatePermissionsLP()
       if REMOVE_EVENTS:
         removePackageLI()
       if addedPackage!=null:
         sendPackageBroadcast(ACTION_PACKAGE_ADDED)
       if removedPackage!=null:
         sendPackageBroadcast(ACTION_PACKAGE_REMOVED)
#+END_EXAMPLE
**** PM.installPackage
***** PackageInstaller
***** install location (src & dest)
****** src apk location
	  - from DownloadManager through ContentProvider
	  - from file though MediaContainerService
****** app install location
       the apk's install location can be internal flash / sdcard.
       1. The apk's manifest may declares it's `install location`, including:
	  - auto
	  - internalOnly
	  - preferExternal
       2. PackageHelper.recommendAppInstallLocation() make the ultimate decision:
	  - if `install location` is not set in manifest, internal will always be selected
	  - auto
	    if apk's code size>1MB, location will be set to external, unless external storage is slow (<10% free space..
	  - internalOnly
	    internal will be selected
	  - preferExternal
	    always selected external unless storage is unavailable or inefficient.
	  - system setting for default installation location is also considered

       To summurize:
       - manifest's `install location`
       - system setting for `default install location`
       - internal/external storage status

***** DONE MediaContainerService / DefaultContainerService
      SCHEDULED: <2011-03-02 Wed> CLOSED: [2011-03-02 Wed 16:42]
      - State "DONE"       [2011-03-02 Wed 16:42]
       	see [[@MountService]]
       	see [[@secure_container]]
***** calling stack
*** Replace Package
*** Uninstall package
**** Intent.ACTION_PACKAGE_REMOVED
*** resolveActivity
    as shown in [[IntentFilter matching][IntentFilter matching]], startActivity will call PM.resolveIntent to resolve the intent, and get one best ResolveInfo;
    PM.resolveActivity() will also call PM.resolveIntent() to resolve the intent, but there is ONE difference, PM.resolveActivity will not force the DEFAULT_ONLY
    flag set when calling resolveIntent(). but startActivity will.

*** android package vs. java package vs. android application
** DONE PendingIntent
   CLOSED: [2011-03-07 Mon 15:58]
   - State "DONE"       [2011-03-07 Mon 15:58]
   :PROPERTIES:
     :CUSTOM_ID: @PendingIntent
   :END:
   see [[PendingIntent @ Permission][Permission]]
   see [[@IntentSender]]
   A description of an Intent and target action to perform with
   it. Instances of this class are created with getActivity(Context, int,
   Intent, int), getBroadcast(Context, int, Intent, int), getService(Context,
   int, Intent, int); the returned object can be handed to other applications so
   that they can perform the action you described on your behalf at a later
   time.

   By giving a PendingIntent to another application, you are granting it the
   right to perform the operation you have specified as if the other application
   was yourself (with the same permissions and identity (*uid*) ). As such, you
   should be careful about how you build the PendingIntent: often, for example,
   the base Intent you supply will have the component name explicitly set to one
   of your own components, to ensure it is ultimately sent there and nowhere
   else.

   A PendingIntent itself is simply a reference to a token maintained by the
   system describing the original data used to retrieve it. This means that,
   even if its owning application's process is killed, the PendingIntent itself
   will remain usable from other processes that have been given it. If the
   creating application later re-retrieves *the same kind of PendingIntent* (same
   operation, same Intent action, data, categories, and components, and same
   flags), it will receive a PendingIntent representing the same token if that
   is still valid, and can thus call cancel() to remove it.

   *Note*:
   if u want to generate different PendingIntent for different intents, make
   sure the PendingIntent's request_code is different, or intents are different.

   Intent equality:
   That is, if intents' action, data, type, class, and categories are the same.
   This does *not* compare any extra data included in the intents.

** TODO [#A] Scroll
*** Scroller
*** GestureDetector
*** VelocityTracker
** TODO Service Manager
   see also [[binder]]
** SharedPreference
** DONE Strict Mode
   SCHEDULED: <2011-06-13 Mon> CLOSED: [2011-06-13 Mon 15:24]
   - State "DONE"       [2011-06-13 Mon 15:24]
   see [[ANR]]
   - use BlockGuard (StrictMode) to detect possible ANR caused by file/network IO in mainThread
** Surfacing							    :ARCHIVE:
** System Property
   1. android property is by no means related to java property.
   2. android SDK doesn't provide public java API to access android property; However, internal java API is available
   3. android SDK provide java API to manipulate java property.
*** android property
    - adb shell getprop / adb shell setprop
    - there is NO java api to set/get android property
    - only root can set android property
**** internal
     main() @ init.c  // in system/core/init
      property_init()
      property_set("ro.hardware", hardware);
      property_set(...)
      ...
*** java property
    System.getProperty() / System.setProperty()
** system_server
*** ServerThread
** Toast
** Tools
*** aapt
*** adb
**** dumpsys
**** am
     am start
     am startservice
     am broadcast
     am instrument
     am monitor
**** pm
     pm list instrumentation
     pm setInstallLocation
     pm getInstallLocation
**** sendevent
*** aidl
**** in,out
     - void foo(in Foo foo,out Bar bar)
     - void foo(String s) // s is `in` implicitly, since String is immutable
     - void foo(Integer i) // i in `in` implicitly, since Integer is also immutable
     - void foo(Foo foo) // compile error, must specify in/out/inout for foo
**** oneway
     - oneway int foo();
*** android
*** ddms
*** decompile
**** dex2jar
**** jd-gui
**** apktool
*** hierachyviewer
*** layouopt
*** sign
**** jarsigner
**** signapk.jar
**** keytool
*** traceview
**** set traceview buffer size in ddms
     .android/ddms.cfg:
       profilerBufferSizeMb=100
** Uri
** vold
   :PROPERTIES:
   :CUSTOM_ID: @vold
   :END:
   *android's alternative to linux udev*
   src location: /system/vold
** Widget
*** ActivityGroup
*** AdapterView
*** Layout
**** LinearLayout
**** TODO FrameLayout
**** GridLayout
**** CANCELED RelativeLayout
     - State "CANCELED"   from "DOING"      [2011-07-18 Mon 17:43]
*** ListView
**** convertView
**** Adapter
***** getView
***** ViewBinder
***** ViewHolder
***** DONE [#A] NotifyDatasetChanged()
      CLOSED: [2011-02-24 Thu 13:33]
#+BEGIN_EXAMPLE
     1	      BaseAdapter.NotifyDatasetChanged()
     2	        AdapterView.AdapterDataSetObserver.onChanged()
     3		  mDataChanged=true;
     4		  AbsList.requestLayout()
     5		    if !mBlockLayoutRequests && !mInLayout: // mInLayout makes sure that NotifyDatasetChanged() in getView() will not cause infinite loop
     6		      super.requestLayout();
     7		      ...
     8		      ViewRoot.requestLayout()
     9		        ViewRoot.performTraversals()
    10			  deco.measure()
    11			  deco.layout()
    12	                    ListView.onLayout()
    13			      mInLayout=true;
    14			      ListView.layoutChildren()
    15			        remove_all_children
    16			        makeAndAddView()
    17			          if !mDataChanged:
    18				    reuse_previous_views
    19				  else:
    20				    obtainView()
    21				      Adapter.getView()
    22			        mDataChanged=false;
    23			  deco.draw();
#+END_EXAMPLE
**** cacheColorHint
**** FastScroller
**** DONE Android BUG: NotifyDatasetChanged() when scrolling
      CLOSED: [2011-06-13 Mon 17:16]
      - State "DONE"       [2011-06-13 Mon 17:16]
      - BUG表现: 在 getView() 中调用 NotifyDatasetChanged(), 当滑动 ListView 时, onItemClick 无法响应
      - 原因:
	1. NotifyDatasetChanged: see also  [[NotifyDatasetChanged]]
	   其中最重要的三点:
	   1. NotifyDatasetChanged 会在开始时将 mDataChanged 置位, 然后调用 AbsListView.requestLayout
	   2. AbsListView.requestLayout 在 *mBlockLayoutRequests* 时什么也不做! ( 重要 )
	   3. ListView layoutChildren 完成后会将 mDataChanged 复位
	2. AbsListView TouchEvent dispatch
	   当 mDataChanged 置位时, touch up 事件不会被处理, 因为 mDataChanged 置位, 表示 数据已改变, 而该 ListView 还没有被重新 layout, 这
	   时应该阻止 itemClick 事件, 因为用户点击时看到的数据很可能并不是真正的数据
	3. ListView scroll
	   上面提到的一重要的数据是 mBlockLayoutRequests, 这个值表示 ListView 当前禁止 requestLayout.
	   当发生 scroll 事件时, ListView 调用 trackMotionScroll(incrementalDeltaY, incrementalDeltaY); 处理滚动,
	   该函数大致是:
#+BEGIN_EXAMPLE
     1		   trackMotionScroll()
     2		     mRecycler.addScrapView(start,count); // cache 滑动出去的 view
     3		       mRecyclerListener.onMovedToScrapHeap(scrap);
     4	             detachViewsFromParent(start, count); // detach 滑动出去的 view from ViewGroup
     5		     mBlockLayoutRequests = true;
     6		       fillGap() --> makeAndAddView() --> obtainView() --> getView() 获得新的 view 以填充滑动时产生的 gap
     7		     mBlockLayoutRequests = false;
     8	             invokeOnItemScrollListener();
     9	             awakenScrollBars();
#+END_EXAMPLE
           最重要的一点是: 在 scroll 时, mBlockLayoutRequests 会被置位,以禁止 scroll 时 requestLayout

****** 在 Preference 中出现该 BUG
       Preference 作为 经过包装的 ListView ,相对来说比较容易出现该 BUG:
       see also [[Preference]]
       - Preference.onBindView() 实际是经过包装的 getView()
       - Preference 自带的 setTitle(), setSummary() 的写法:

#+BEGIN_EXAMPLE
     1		 Preference.setTitle(title):
     2		   if (title == null && mTitle != null || title != null && !title.equals(mTitle)):
     3		     mTitle = title;
     4		     notifyChanged();
#+END_EXAMPLE

     如果调用者在 onBinderView 中调用了 setXXX() 方法, 则会出现该 BUG.

*** TODO view overlay
*** GestureOverlayView
*** TODO SurfaceView
*** TabActivity
*** TabHost
*** TODO [#A] TextView
*** ViewAnimator
*** WebView
**** TODO [#C] Cookie
     see [[@HTTP_Cookie]]
***** CookieManager
***** CookieSyncManager
** WindowManager
*** addView
    2010-11-16
    window.addView() will firstly gen (viewRoot,view,layout_param) tuple, then call ViewRoot.setView() to ask WMS to add the view.
    since ViewRoot has an IWindowSession, and it will send IWindow to WMS (as mClient), it can communicate with WMS back and forth.

    2010-11-15
    window.addView() will add [new viewroot,decorView] tuple to
    WindowManagerImpl, when WMS want to dispatch event to window, e.g. key event, it will
    call mClient.dispatchKey() to viewRoot, viewRoot, as a handler, will then dispatch key event to it's looper

    Activity and Dialog will generate decorView automatically, then call
    WM.addView(decorView) to window.  but PopupWindow will not generate
    decorView since PopupWindow need not to be `decorated`.

*** Event dispatch
**** KeyEvent dispatch
     11/17/10 11:12 am WMS first found the focused WindowState, then dispatch
     event to WindowState.mClient (this is a IWindow), IWindow , as an AIDL
     register by viewRoot, will call viewRoot's dispatch() directory

     2010-11-14
#+BEGIN_EXAMPLE
     WMS get mClient, and call mClient.dispatch() through binder
       ViewRoot.dispatchKey()
         ViewRoot.sendEmptyMessage(DISPATCH_KEY)
	   message handler: ViewRoot.deliverKeyEvent()
	     ViewRoot.deliverKeyEventToViewHierarchy()
	       Decorview.dispatchKeyEvent() ;; mView is the decorView
	         if (is volume key)
		   adjust volume
		 if (has Window.Callback) ;; Activity, Dialog implents Window.Callback
		   callback.dispatchKeyEvent()
		     DecorView.superDispatchKeyEvent()
		       ViewGroup.dispatchKeyEvent() ;; dispatch key event to view hierachy
		         Travers the focus path, call every ViewGroup's dispatchKeyEvent, then finally,calls:
			 focusView.dispatchKeyEvent()
			   mOnKeyListener.onKey()
			   if (not handled)
			     event.dispatch(view) ;; view also implents Event.Callback
		     if (not handled)
		         event.dispatch(activity) ;; Activity implents Event.Callback, which implents onKeyUp, onKeyDown ...
		 else
		   super.dispatchKeyEvent() ;; view.dispatchKeyEvent, PopupWindow falls into this condition, since PopupWindow
		                            ;; does not implents Window.Callback
                 if (still not handled):
                   Window.onKeyDown() or onKeyUp()
                     // cope with MENU,CAMERA,VOLUME,MEDIA,CALL,SEARCH...
               if (not handled)
	         changeFocus()
		 if not (focus changed)
		   playSoundEffect
	       sWindowSession.finishKey(mWindow) to tell AMS that key
#+END_EXAMPLE

    note that:
    Activity and Dialog implements Window.Callback and KeyEvent.Callback, so you can override Activity or Dialog's dispatchKeyEvent (implemented in
    Window.Callback), and you can override onKeyUp, onKeyDown ...( implemented in KeyEvent.Callback)
    But PopupWindow implements neither Window.Callback nor KeyEvent.Callback.

**** DONE [#A] TouchEvent dispatch
     SCHEDULED: <2011-01-27 Thu> CLOSED: [2011-01-27 Thu 11:35]
     - State "DONE"       [2011-01-27 Thu 11:35]

#+BEGIN_EXAMPLE
     ViewRoot.dispatchPointer()
       decorView.dispatchTouchEvent() ;; mView is typically a DecorView
         if DecorView has callbacks like Activity or Dialog
	   activity.dispatchTouchEvent()
	     mDecor.superDispatchTouchEvent()
	     .... ;; same as the `else` branch
	     activity.onTouchEvent() if not handled before
	 else
	   mDecor.superDispatchTouchEvent()
	     ViewGroup.dispatchTouchEvent() ; DecorView is a FrameLayout
               if (action == MotionEvent.ACTION_DOWN):
                 if (disallowIntercept || !onInterceptTouchEvent(Ev)):
                   foreach mView of ViewGroup: ;; for each child of the ViewGroup whose rect contains pointer(x,y), note that view's rect is set during view.layout()
                     if (mView.dispatchTouchEvent()):
                       mMotionTarget=mView;
                       return true;
               if mMotionTarget==null: // DOWN is not handled by any child; or event is up/move, but there is no mMotionTarget,
                                       // which means last DOWN is handled by ourselves.
                 return super.dispatchTouchEvent()
	           mView.onTouchListener().on Touch()
	           mView.onTouchEvent() ;; if not handled before
	             mView.onClickListener()
               // ACTION is up/move, and mMotionTarget is not null, which means we should delegate the up/move to the mMotionTarget,
               // There is no need to go through child hierarchy to handle it.
               if (!disallowIntercept && onInterceptTouchEvent(ev)): // touchEvent is intercepted
                 ev.setAction(MotionEvent.ACTION_CANCEL);
                 mMotionTarget.dispatchTouchEvent(ev)
                 return true;
               // touchEvent is not intercepted
               return mMotionTarget.dispatchTouchEvent(ev);
#+END_EXAMPLE
     To summarize:
     1. TouchEvent dispatching 的过程和 KeyEvent *相反*:
	- KeyEvent: 先调用 ViewGroup.superDispatchKeyEvent(), 若没处理,再调用 mFocused.dispatchKeyEvent()
	- TouchEvent: 先调用 child.dispatchTouchEvent(),若没处理, 再调用 super.dispatchTouchEvent()
     2. dispatchTouchEvent -> onTouchListener -> onTouchEvent -> onClickListener
     3. onInterceptTouchEvent and mMotionTarget
***** DONE ListView TouchEvent dispatch
      SCHEDULED: <2011-02-16 Wed> CLOSED: [2011-02-16 Wed 15:04]
      - State "DONE"       [2011-02-16 Wed 15:04]
      ListView 首先是一个 ViewGroup, 它使用了
#+BEGIN_EXAMPLE
	 ViewGroup.dispatchTouchEvent()
	   ask_child_to_handle_it()
	   if not handled:
	     super(view).dispatchTouchEvent()
	       AbsListView.onTouchEvent()
	         if child(list item).hasFocusable(): ;; if the liste_item have any view that is focusable
		   do_nothing;
		 else:
		   onItemClickedListener();
#+END_EXAMPLE

      To summarize:
      ListView is just like a common ViewGroup, but:
      1. ListView's onTouchEvent will not invoke `onClickListener`, but `onItemClickedListener`
      2. before invoke onItemClickedListener, onTouchEvent will make sure that child.hasFocusable() is false

***** DONE ViewGroup.onInterceptTouchEvent & mMotionTarget
      SCHEDULED: <2011-07-19 Tue> CLOSED: [2011-07-19 Tue 16:55]
      - State "DONE"       from "DOING"      [2011-07-19 Tue 16:55]
*** View
**** TODO [#A] View life cycle
***** DONE requestLayout
      SCHEDULED: <2011-01-27 Thu> CLOSED: [2011-01-26 Wed 17:22]
      - State "DONE"       [2011-01-26 Wed 17:22]
      :PROPERTIES:
	:CUSTOM_ID: @requestLayout
      :END:
      see [[@onMeasure]] [[@onLayout]]
      requestLayout() is actually implemented in ViewRoot
      View defined it's own requestLayout by:
#+BEGIN_EXAMPLE
      View.requestLayout()
        mParent.requestLayout() ;; for a view, mParent is the upper ViewGroup
	  mParent.requestLayout() ;; ViewGroup implements View, thus recursive again to the parent
	    ...
	      top_view.requestLayout()
	        ViewRoot.requestLayout() ;; top view's mParent is the ViewRoot
#+END_EXAMPLE

    Call stack:
#+BEGIN_EXAMPLE
    ViewRoot.requestLayout()
      ViewRoot.scheduleTraversals()
        ViewRoot.performTraversals() handles the msg
	  mView.dispatchAttachedToWindow() ;; mView is the ViewRoot's top view
	    ViewGroup.dispatchAttachedToWindow()
	      view.dispatchAttachedToWindow() for every child view of the ViewGroup
	        view.onAttachedToWindow() ;;  see [[onAttachedToWindow][onAttachedToWindow]]
	  mView.measure()
	    mView.onMeasure()
	      layout.onMeasure() ;; e.g. LinearLayout, FrameLayout
	        view.measure() ;; for every child view of the layout, including margin
		  view.onMeasure() ;; see [[onMeasure][onMeasure]]
	  mView.layout()
	    layout.layout() ;; e.g. LinearLayout
	      view.layout() ;; it seems that view.layout && view.onLayout doesn't do something meaningful?  it mainly stores the child's x,y,width,height
	                    ;; so that we can, when touch the screen, tell which view is touched
	        view.onLayout() ;; see [[onLayout][onLayout]],
#+END_EXAMPLE

***** addView
***** removeView
***** onAttachedToWindow
      see [[@requestLayout]]
***** onDetachedFromWindow
***** DONE onLayout
      CLOSED: [2011-03-15 Tue 16:50]
      - State "DONE"       [2011-03-15 Tue 16:50]
      :PROPERTIES:
      :CUSTOM_ID: @onLayout
      :END:
      see [[@requestLayout]]
****** android:layout_gravity & android:gravity
       during onMeasure, view's size is fixed, after-wards, ViewGroup.onLayout will re-position children views and invoke child.onLayout to notify children
       for their position.

       - similar with android:height, only a few views or ViewGroup has the android:gravity property.
	 e.g. TextView has the android:gravity property, so that the inner text can be positioned to top/bottom/left/right
	 LinearLayout also has the android:gravity, which control Linear Layout's children's gravity as a whole.
******* How does LinearLayout make use of gravity.
	- for *Vertical* LinearLayout with layout_height= *fill_parent* :
	  vertical LinearLayout can only set it's android:gravity to `top,bottom,center_vertical`, which can move the children as a whole in
	  vertical direction.
	  vertical LinearLayout's child can set their android:layout_gravity to `left,right,center_horizontal`,which can move a single child view
	  in the horizontal direction.

	  that is, if u want to position a view in vertical LinearLayout to right-bottom, u can:
	    - set LinearLayout.android:gravity to bottom
	    - set view.android:layout_gravity to right

#+BEGIN_EXAMPLE
	    vertical LinearLayout      	       	      set android:gravity to bottom   		& set view1.layout_gravity to right
	   -+-----------------------+                -+-----------------------+                -+--------------------------+
	    |-+-------------+	    |		      |			      |		       	|		 	   |
	    | |	 view1	    |	    |		      |			      |		       	|		 	   |
	    | |	      	    |	    |		      |			      |		       	|		 	   |
	    |-+-------------+	    |		      |			      |		       	|		 	   |
	    | |	 view2	    |	    |		      | 		      |		       	|		 	   |
	    | |		    |	    |		      | 		      |		       	|		 	   |
	    |-+-------------+	    |		      |-+--------------+      |		       	|  	    -+-----------+ |
	    |			    |		      |	|  view1       |      |		       	|  	     |	view1	 | |
	    |			    |		      |	|  	       |      |		       	|      	     | 	     	 | |
	    |			    |		      |-+--------------+      |		       	| -+---------+--+--------+ |
	    |			    |		      |	|  view2       |      |		       	|  |  view2    	|    	   |
	    |			    |		      |	|      	       |      |		       	|  |		|    	   |
	    |			    |		      |-+--------------+      |		       	| -+------------+  	   |
	   -+-----------------------+		     -+-----------------------+		       -+--------------------------+
#+END_EXAMPLE

	- for horizontal LinearLayout:
	  vice-versa

***** TODO [#B] invalidate
**** view padding and margin
     padding = 内边距
     margin =  外边距
     内,外是相对于容器(盒子)的边界而言, 以Button为例,Button可以看作一个盒子,设置button.padding会影响Button里的文字或图片与Button边界的距离,例如:

     Button
#+BEGIN_EXAMPLE
       -+---------------+
       	|[padding] click|
       -+---------------+
#+END_EXAMPLE

     而button.margin会影响button与其更外层盒子(如layout)的边界

     LinearLayout
#+BEGIN_EXAMPLE
       -+-------------------+
       	| [top margin] 	    |
       	|+-------------+    |
       	|| button      |    |
       	|+-------------+    |
       -+-------------------+
#+END_EXAMPLE

   需要注意的一点是,android中view是没有margin属性的,只有 ViewGroup 才有margin属性, 所以,如果想达到上图的效果,不可能直接设置button的margin,而是需在将button
   放在一个 ViewGroup 中,然后设置该 ViewGroup 的margin.

**** DecorView
**** findViewById
**** Switch focus
     11/17/10 9:41 am
     Q:when press 'left' key, how the focus is changed?
     A:
     1. when viewRoot got the key event, it will firstly call 'dispatchKeyEventToViewHierachy' to dispatch the key event to it's correspondingg top level viw (i.e. DecorView)
     2. If the key event is not handled by the view hierachy, viewRoot will call 'findFocus' to find next focus in 'handleFinishedEvent'

     3. If the current focused view has set 'focus:right...' properties, viewRoot will call view.findViewById to find the next focus, or find the nearest focusable view in a specified rectangle area.

**** getDrawingCache
**** ViewGroup
*** ViewRoot
    2010-11-16
    ViewRoot is the bridge between WMS and View

    It is basically a handler of activityThread's mainLooper.  So WMS can use this handler to dispatch event to top view of the activity or dialog.  What more, viewRoot is also equiped with an IWindowSession, through which can communicate with WMS, e.g, tell WMS to add view in ViewRoot.setView()

**** appToken
**** IWindowSession
     when viewRoot is constructred, it will open session to WMS (IWindowSession) to communicate with WMS (e.g. For add, remove view)
**** IWindow
     when viewRoot is constructed, it will create IWindow, and register the AIDL interface to WMS,  WMS will save the IWindow as 'mClient' in WindowState arrays, through which WMS can communite with ViewRoot for event dispatching.
     IWindow.dispatch() will call viewRoot.dispatch() directly.
*** ViewRoot, View (DecorView) and Window
    - 与WMS直接打交道的是ViewRoot,WMS能直接看到的只有ViewRoot (通过ViewRoot注册到WMS的IWindow mClient)

    - ViewRoot直接管理其顶层View (对于Actity,Dialog, 即DecorView. 对于

      PopupWindow及手动通过WindowManagerImpl.addView添加的view, 其顶层view只是普
      通的view), 所以一个进程可以有多个ViewRoot

    - Window是和DecorView一一对应的. 

      因为Activity, Dialog项层view是DecorView, 所以有window的概念, 可以通
      过Window来控制ContextMenu, 调用Window.Callback等;

    - Window与Activity,Dialog对应
    
      通过Window.Callback, 可以和Activity和Dialog联系起来,因为它们都实际了
      Window.Callback接口.而PopupWindow顶层只是普通view,所以没有Window的概念

      综上:
      - WMS<-->ViewRoot
      - ViewRoot<-->DecorView
      - DecorView<-->Window<-->Activity,Dialog
*** Window
    对于ViewRoot来说,顶层的`Window`就是一个普通的View, 但有些和`Window`有关的操
    作,如:
    - 如何处理一些通用的按键事件, 如Volume, ContextMenu,Camera,Call,Search...,
    - 如何在顶层View之上再显示一个ContextMenu
    - 从WMS来的一些事件如何通知给Activity,Dialog, 例如onBackPressed()
    因为, 提供了一个Window类, 用来处理这些和`Window`有关的操作, 但从WMS及
    ViewRoot的角度看,并没有`Window`的概念. 

    只有DecorView能和Window关联,来处理`Window`相关操作 (因为DecorView是Window的
    inner class), 所以只有Activity,Dialog有window的概念
**** PhoneWindow
*** WindowManagerImpl
*** WindowManagerService
**** WindowState
***** mClient
** Zygote
*** DONE Java Process Creation
    CLOSED: [2011-03-01 Tue 11:20]
    - State "DONE"       [2011-03-01 Tue 11:20]
#+BEGIN_EXAMPLE lang:c
    AMS::startSpecificActivity()
      Process::start(className,uid..)
         Process::startViaZygote()
            Pro::zygoteSendArgAndGetPid()
               for zygote socket read pid
#+END_EXAMPLE
    zygote socket:
#+BEGIN_EXAMPLE lang:c
        runSelectLoopMode()
          got request form socket
             runOnce()
	       forkAndSpecialize(int uid, int gid, int[] gids..)
	         - uid: the UNIX uid that the new process should setuid() to after fork()ing and and before spawning any threads.
                 - gid: the UNIX gid that the new process should setgid() to after fork()ing and and before spawning any threads.
                 - gids: null-ok; a list of UNIX gids that the new process should setgroups() to after fork and before spawning any threads.
		   because zygote runs with root uid, it can setuid/gid/groups freely
                 // in child process
                 handleChildProc()
                   closeSocket();
                   RuntimeInit.zygoteInit(parsedArgs.remainingArgs);
                     commonInit()
                       Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); // NOTE: the UncaughtHandler does nothing but crash the app
                     zygoteInitNative()
                       gCurRuntime->onZygoteInit()
                         proc->startThreadPool();
                     invokeStaticMain();
                in parent process
                    return child pid
#+END_EXAMPLE
*** DONE Zygote init
    CLOSED: [2011-06-30 Thu 16:42]
    - State "DONE"       from ""           [2011-06-30 Thu 16:42]
    see also [[System init]]
** Debug related
*** hprof & MAT
    - 在代码中生成
      Debug.dumpHprofData()
    - 使用信号on-demand生成
#+BEGIN_EXAMPLE
    $ chmod 777 /data/misc -R
    $ ps # 找到进程号
    $ kill -10 进程号 # 发送SIGQUIT信事信号给该进程，此时生成hprof信息
    $ ls /data/misc/*.hprof 
#+END_EXAMPLE
    - 为了能让MAT识别android的hprof格式,需要用hprof-conv转换一下
*** traceview
**** dmtracedump
     dmtracedump -g out.png -t 30% test.trace
*** hierachyviewer
*** Thread.dumpStack()
*** logcat
*** adb am start
*** monkey
* Mobile Dev							    :ARCHIVE:
#+CATEGORY:Mobile Dev
** APN
** 电容屏/电阴屏
** 多点触摸
* Java
#+CATEGORY:Java
** Top topic
   - Security
   - Collection Framework
   - Memory Model & Concurrent
   - NIO
   - JVM
     - bytecode
     - constant pool
     - linking & loading & ClassLoader
   - JNI
   - GP
   - GC
   - Reflect
   - Module System
** misc
*** DONE [#A] java initialization
    CLOSED: [2011-08-02 Tue 15:28]
    - State "DONE"       from "TODO"       [2011-08-02 Tue 15:28]
    java code:
#+BEGIN_EXAMPLE
	class S {
	    static {
		System.out.println ("super static block");
	    }
	}

	class Test extends S {
	    static {
		System.out.println ("Test static block");
	    }
	    int x=1;
	    public Test () {
		System.out.println ("Test ctor");
		foo ();
	    }
	    public static void main(String args[]) {
		Test t=new Test ();
	    }
	    void foo () {

	    }
	}
#+END_EXAMPLE
    byte code of Test.class
#+BEGIN_EXAMPLE
	public Test();
	  Code:
	   Stack=2, Locals=1, Args_size=1
	   0:   aload_0                                                // put the first argument (this) to operand stack
	   1:   invokespecial   #1; //Method S."<init>":()V;           // call super.<init>
	   4:   aload_0
	   5:   iconst_1
	   6:   putfield        #2; //Field x:I                        // initialize x=1
	   9:   getstatic       #3; //Field java/lang/System.out:Ljava/io/PrintStream;  // The actual ctor: Test()
	   12:  ldc     #4; //String Test ctor
	   14:  invokevirtual   #5; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
	   17:  aload_0
	   18:  invokevirtual   #6; //Method foo:()V
	   21:  return
	static {};
	  Code:
	   Stack=2, Locals=0, Args_size=0
	   0:   getstatic       #3; //Field java/lang/System.out:Ljava/io/PrintStream;
	   3:   ldc     #9; //String Test static block
	   5:   invokevirtual   #5; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
	   8:   return
#+END_EXAMPLE
    To summarize:
    - <init> differs with ctor!
      <init> will:
      1. invoke super.<init>
      2. init member field
      3. call ctor

*** CharSequence vs. String
*** java de-initialization
*** final keyword
*** ConcurrentModificationException
*** DONE fail-fast iterator
    CLOSED: [2011-07-26 Tue 16:16]
    - State "DONE"       from ""           [2011-07-26 Tue 16:16]
    see also [[ConcurrentModificationException]]
    see also [[Immutable Collection]]

    An iterator is considered /fail-fast/ if it throws a /ConcurrentModificationException/ under either the following two conditions:
    1. In multithreaded processing: if one thread is trying to modify a /Collection/ while anther one is iterating over it.
    2. In single-threaded: if after the creating of the /iterator/, the container is modified at any time by any method other than the iterator's own
       remove or add methods

    - code snippet that will throw ConcurrentModificationException:
#+BEGIN_EXAMPLE
      for (Foo o:container) {
        if (o.v==0) {
          container.remove(o);
        }
      }
#+END_EXAMPLE
    - using fail-fast iterator to avoid ConcurrentModificationException:
#+BEGIN_EXAMPLE
      ListIterator ite=container.listIterator();
      while (ite.hasNext()) {
        Foo o=ite.next();
        if (o.v==0) {
          ite.remove();
        }
      }
#+END_EXAMPLE
    - using a copy of container to avoid ConcurrentModificationException: see also [[Immutable Collection]]
#+BEGIN_EXAMPLE
      List tmp=new ArrayList(container);
      for (Foo o:tmp) {
        if (o.v==0) {
          container.remove(o); // this works because of `shallow copy`
        }
      }
#+END_EXAMPLE
*** initialization on-demand holder
    :PROPERTIES:
    :CUSTOM_ID: @initialization on-demand holder
    :END:
#+BEGIN_EXAMPLE
// Correct lazy initialization in Java
    @ThreadSafe
    class Foo {
      private static class HelperHolder {
        public static Helper helper = new Helper();
      }
      public static Helper getHelper() {
        return HelperHolder.helper;
      }
    }
#+END_EXAMPLE
*** DONE java主线程与子线程的关系
    SCHEDULED: <2011-02-09 Wed> CLOSED: [2011-02-09 Wed 17:42]
    - State "DONE"       [2011-02-09 Wed 17:42]
    java 主线程退出后,子线程仍成执行
    linux 主线程退出后,子线程也在执行
*** TODO [#A] HttpClient 连接的关闭 (close & shutdown) 与 InputStream, OutputStream 的关闭
*** Java Service Wrapper
** Java Criticism
   see also [[Immutable Collection]]
   see also [[GP]]
   see also [[GC]]

   - enumeration
   - final
** Tools
   - jps
   - jmap
   - jhat
   - jstack
   - jinfo
   - MAT
   - keytool
   - jarsigner
     http://download.oracle.com/javase/1.3/docs/tooldocs/win32/jarsigner.html
   - javac
   - javah
   - javap -verbose
   - java
     - java -Xcomp -XX:+PrintAssembly -XX:CompileCommand='compileonly A.foo' -XX:CompileCommand='compileonly Test.main' -XX:CompileCommand='compileonly B.foo
     - java -Xint
     - java -Xss4096k Test  // set stack size
     - java -Xms 4096k -Xmx 128m Test // set heap size
     - java -verbose:sizes
     - java -verbose:gc
     - java -XX:+DisableExplicitGC
     - java -client
     - java -server
** CANCELED [#B] Java Language Specification (jls)
   - State "CANCELED"   from "DOING"      [2011-08-29 Mon 17:20]
   CLOCK: [2011-02-16 Wed 17:38]--[2011-02-16 Wed 18:01] =>  0:23
*** String
**** compile-time constant pool
     all reference to the same compile-time String literal constant refers to the same String object in the *compile-time constant pool*
     e.g.
     -
       String s1="abc";
       String s2="abc";
       s1==s2 is true
     -
       String s1=foo();
       String s2="abc";
       String foo() {return "abc";}
       s1==s2 is true;
**** A.intern()
     `constant pool` is stored in the .class file (like string literals in c/c++, which are statically stored at TEXT section)
     compile-time String are always `interned` to shared the same String instance in the constant pool.
     if the constant pool already contains a String whose value equals to A, return it, else, create a new String object in the pool, then return it.
     i.e. intern() may add a new entry to the constant pool!
     - intern() usage?
       suppose u are manage thousands of Strings whose value is
       among only 3 alternatives , u can make use of s.intern() instead of s, so
       as to store only 3 objects in the constant pool.
**** concatenation operator `+`
     The String concatenation operator `+` will only create new String object when operand are not *compile-time* constant.
     e.g.:
     - String s1="abc"
     - String s2="abc"+"abc";
       will not create new String object at run-time, since "abc" are compile-time constant.
     - final String s1="abc"; String s2=s1+"abc";
       also will not create new String object for s2, since s1 is a compile-time constant.
     - final String s1=getString() or final String s1=new String("abc"); String s2=s1+"abc";
       will create new String object for s2, since s1 is not a compile-time constant (it's a run-time constant)

*** conversion
**** Boolean
     conversion between boolean and numeric is impossible.
**** Numeric
     - conversion between numeric primitive type can always be applied, implicitly or explicitly.
       e.g.
       1. long l=2L;
	 int a=(int)l;
       2. void foo(int);
	 long x=2L;
	 foo((int)x)
       3. int i=2;
	  long l=i;
       Note:
       in example 1 & 2, if the conversion will cause loss of precision, e.g. from long to int, explicitly conversion is mandatory.
       in example 3, implicitly conversion is applied, since the conversion cause no loss of precision.
     - conversion between numeric primitive type's reference type is not allowed in anyway.
       e.g.
       Longer l=2L;
       Integer a=(Integer)l; is not allowed.
     - conversion between numeric primitive and reference type is allowed, with auto boxing and un-boxing conversion
       e.g.
       1. Integer a=1;
	  long xx=a; // a is firstly un-boxed to int
       2. int aa=1;
	  Long xx=(long)aa; // aa is firstly converted to long, then boxed to Long.

**** autoboxing & un-boxing conversion
     see also [[constant pool]]
     see also valueOf
     - un-boxing from one NULL object  will result in a NullPointerException, e.g. int a=getInt(); Integer getInt() {return null;}
     - primitive type's reference type's ++/-- will cause another reference class object be created
       e.g. Integer a=1; a++; then another Integer for value 2 is created automatically. (but may re-use an existing Integer(2) directly instead of
       create a new one)
     - autoboxing 实际是只是隐式的调用了 valueOf

**** valueOf
#+BEGIN_EXAMPLE
     Integer.valueOf():
       return  i >= 128 || i < -128 ? new Integer(i) : SMALL_VALUES[i + 128];
     static {
       for(int i = -128; i < 128; i++) {
         SMALL_VALUES[i + 128] = new Integer(i);
       }
     }
#+END_EXAMPLE

**** shift
     before shifting char,byte,short, the operand will be converted to int through Numeric Conversion.
     e.g.
#+BEGIN_EXAMPLE
     byte b=0xff;
     b=b<<8>>>8;
     first: b in converted to 0xff ff ff ff
     second:<<8 result in 0xff ff ff 00
     last :>>>8 result in 0x00 ff ff ff
     so lastly, b=0xff, instead of 0x00
#+END_EXAMPLE
*** equals, hashCode, HashMap, ==
    - HashMap.contains(key)的大致做法:
      if (this==key || (this.hashCode()==key.hashCode() && this.equals(key)):
        return true;
      else:
        return false;
    - equals的实现
      - Object.equals(o):
        return this==o;
      - Integer.equals(o):
	return this.value==o.value;
      - String.equals(o):
	if this==o:
	  return true;
	if this.hashCode()!=o.hashCode():
	  return false;
	foreach byte:
	  if byte1!=byte2:
	    return false;
    - hashCode 的实现
      - Object.hashCode():
	返回内存地址
      - Integer.hashCode():
	return this.value;
      - String.hashCode():
	built upon this.value[]

*** Object.clone, shadow copy & deep copy
    In java, though clone is intent to produce a copy of the same object
    it is not guaranteed. Clone comes with lots of its and buts. So my first advice
    is to not depend on clones. If you want to provide a handle / method to deliver
    a copy of the current instance write a kind of factory method and provide it
    with a good documentation. When you are in a situation to use a third party
    component and produce copies of it using the clone method, then investigate that
    implementation carefully and get to know what is underlying. Because when you
    ask for a rabbit, it may give monkeys!

    - Shallow Copy

      Generally clone method of an object, creates a new instance of the same
      class and copies all the fields to the new instance and returns it. This
      is nothing but shallow copy. Object class provides a clone method and
      provides support for the shallow copy. It returns ¡®Object¡¯ as type and
      you need to explicitly cast back to your original object.

      Since the Object class has the clone method (protected) you cannot use it
      in all your classes. The class which you want to be cloned should
      implement clone method and overwrite it. It should provide its own meaning
      for copy or to the least it should invoke the super.clone(). Also you have
      to implement Cloneable marker interface or else you will get
      CloneNotSupportedException. When you invoke the super.clone() then you are
      dependent on the Object class¡¯s implementation and what you get is a
      shallow copy.

    - Deep Copy

      When you need a deep copy then you need to implement it yourself. When the
      copied object contains some other object its references are copied
      recursively in deep copy. When you implement deep copy be careful as you
      might fall for cyclic dependencies. If you don¡¯t want to implement deep
      copy yourselves then you can go for serialization. It does implements deep
      copy implicitly and gracefully handling cyclic dependencies.

      One more disadvantage with this clone system is that, most of the
      interface / abstract class writers in java forget to put a public clone
      method. For example you can take List. So when you want to clone their
      implementations you have to ignore the abstract type and use actual
      implementations like ArrayList by name. This completely removes the
      advantage and goodness of abstractness.

      When implementing a singleton pattern, if its superclass implements a
      public clone() method, to prevent your subclass from using this class¡¯s
      clone() method to obtain a copy overwrite it and throw a
      CloneNotSupportedException.

      Note that clone is not for instantiation and initialization. It should not
      be synonymously used as creating a new object. Because the constructor of
      the cloned objects may never get invoked in the process. It is about
      copying the object in discussion and not creating new. It completely
      depends on the clone implementation. One more disadvantage (what to do
      there are so many), clone prevents the use of final fields. We have to
      find roundabout ways to copy the final fields into the copied object.

      Clone is an agreement between you, compiler and implementer. If you are
      confident that you all three have good knowledge of java, then go ahead
      and use clone. If you have a slightest of doubt better copy the object
      manually.

      Example source code for java clone and shallow copy

#+BEGIN_EXAMPLE
      class Employee implements Cloneable {
      private String name;
      private String designation;
      public Employee() {
        this.setDesignation("Programmer");
      }
      public Object clone() throws CloneNotSupportedException {
        /*
	Employee copyObj = new Employee();
	copyObj.setDesignation(this.designation);
	copyObj.setName(this.name);
	return copyObj;
	*/
        return super.clone(); // called Object.clone()
	}
      }
#+END_EXAMPLE
    - Object.clone()
      Object.clone() is quite efficient, since it relies on JNI and use a bit-wise copy to clone the Object

    To summarize:
    - clone is mainly used to produce a shadow copy of object
      - if u prefer deep copy, you can either use serialization, or use `
        ret=super.clone(); ret.obj1=this.obj1.clone();....`, things like
        that. but circular references should be well concerned
    - super(Object).clone() is quite efficient, u need not rewrite clone() for simple Object
    - *many Abstract containers is not clone-able...e.g. List, but ArrayList is clone-able*
*** constant variable
    we call a variable, of primitives type or of String type, that is final and initialized with a compile-time expression a constant variable
    e.g. final int a=10; final String s="abc";
*** Throwable, Exception,Error
    Note: all Exception and Error can be caught at run-time, even divided-by-zero error...
#+BEGIN_EXAMPLE lang:c
      Throwable
        Exception
          RuntimeException                    ;; unchecked exceptions
  	    NullPointerException
  	  ..                                  ;; checked exceptions, which can be declared in *Throws* clause
        Error
          OutOfMemoryError
  	  ..
#+END_EXAMPLE
**** Throwable.fillInStackTrace()
** Java Memory Area
   - Java Heap
     set by -Xms and -Xmx
   - Java Stack
     set by -Xss
   - Direct Buffer (ByteBuffer)
     - ByteBuffer.allocateDirect() actually will use mmap to map a separate VMA
     - while GC (minor/major) will caused automatically only when `Java Heap` is full...
     - Then: How about allocate 2G direct buffer while keep the Java Heap free?
       How is the direct buffer be `GC`ed?
       - Since the Java Heap is free, no GC is performed automatically
       - Actually, when allocateDirect(), Java will `try {} catch {}` the
         OutOfMemoryError and force a major GC using `System.gc()`, and gc may
         free some byte buffer.
       - But, if `-XX:+DisableExplicitGC` is specified..., good luck :(
#+BEGIN_EXAMPLE
    public static void main(String[] args) {
	ByteBuffer bf=ByteBuffer.allocateDirect(300*1024*1024);
	bf=ByteBuffer.allocateDirect(300*1024*1024);
	bf=ByteBuffer.allocateDirect(300*1024*1024);
    }
#+END_EXAMPLE
     when run the sample code above w/ or w/o `-XX:+DisableExplicitGC`:
#+BEGIN_EXAMPLE
     ~@mbjswglx56> java -XX:+DisableExplicitGC -verbose:gc TestByteBuffer
     Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory
        at java.nio.Bits.reserveMemory(Bits.java:633)
        at java.nio.DirectByteBuffer.<init>(DirectByteBuffer.java:98)
        at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)
        at TestByteBuffer.main(TestByteBuffer.java:7)
#+END_EXAMPLE
#+BEGIN_EXAMPLE
     ~@mbjswglx56> java -verbose:gc TestByteBuffer
     [GC 313K->320K(59840K), 0.0007220 secs]
     [Full GC 320K->121K(59840K), 0.0072890 secs]
#+END_EXAMPLE
   - Socket Buffer
   - JNI
   - Native Heap and Stack
** Java VM Specification (jvms)
*** DONE String.intern()
    CLOSED: [2011-08-01 Mon 15:22]
    - State "DONE"       from "DOING"      [2011-08-01 Mon 15:22]
    see also [[constant pool]]

    String.intern()与constant pool的关系?
    VM 运行后, VM 本身会维护一个 internedStrings<char *, String> 的 HashMap, String.intern() 的作用是:
    - 从 internedStrings 中查找是否已存在, 若不存在, 向 map 中插入一条记录, 最后返回 map的value,
    - 所以 assert(new String("abc").intern() == new String("abc").intern());

    String.intern() 使用的 internedStrings 本身和 constant pool 并没有直接关系, 但:
#+BEGIN_EXAMPLE
    String s1="abc";
    String s2=new String("abc");
    assert(s1==s2.intern());
#+END_EXAMPLE
    有两种可能:
      1. VM 在 resolve class (resolve constant pool) 时, 一次性的将所有 CONSTANT_String_info 全通过 intern() 放到 internedStrings 中, 然后 CONSTANT_String_info
	 的 data 为 生成的 String 对象
      2. LAZY initialization: 如 [[constant pool]] 所述, 访问 CONSTANT_String_info 使用 `ldc` 指令, 而 `ldc` 指令可以隐式的调用 String.intern(), 并返回 intern() 的结果

    To summarize:
    - 对于 string literal, 再显式调用 intern() 没有意义
    - 对于 运行时 string, 若 string 经常重复, 可以通过 intern() 做 cache
*** DONE constant pool
    SCHEDULED: <2011-08-02 Tue> CLOSED: [2011-08-01 Mon 15:11]
    - State "DONE"       from "DOING"      [2011-08-01 Mon 15:11]
    see also [[String.intern()]]
    see also [[autoboxing]]
    see also [[valueOf]]

#+BEGIN_EXAMPLE
    String s1="abc";
    String s2="abc";
    assert(s1==s2);
    String s3=new String("abc");
    String s4=new String("abc");
    assert(s3!=s4);

    Integer i1=100;
    Integer i2=100;
    assert(i1==i2);  // see autoboxing & valueOf
    Integer i3=200;
    Integer i4=200;
    assert(i3!=i4);  // see autoboxing & valueOf
#+END_EXAMPLE

    Constant pool plays an important role in the dynamic linking of Java program. In addition to constant values (String, integer, float literal),
    the constant pool contains the following kinds of symbolic references:
     - fully qualified names of classes and interfaces
     - field names and descriptors (type...)
     - method names and descriptors (params,type,...)
    Constant pool can contain the following variety entries:
     - CONSTANT_Utf8
     - CONSTANT_Integer
     - CONSTANT_Float
     - CONSTANT_Long
     - CONSTANT_Double
     - CONSTANT_Class
     - CONSTANT_String
     - CONSTANT_FieldRef
     - CONSTANT_MethodRef
     - CONSTANT_NameAndType

    To summarize:
    Constant pool works in 3 varieties:
      1. save constant literal (and class static field), much like DATA section in ELF
      2. help dynamic linking resolution
      3. name cache
**** class, method, field..
   java code:
#+BEGIN_EXAMPLE
   public class Test {
     int x;
     public static void main(String args[]) {
	Test t=new Test ();
	t.x=100;
	t.foo ();
     }
     void foo () {

     }
   }
#+END_EXAMPLE
   byte code:
#+BEGIN_EXAMPLE
   const #1 = Method	#6.#18;	//  java/lang/Object."<init>":()V
   const #2 = class	#19;	//  Test
   const #3 = Method	#2.#18;	//  Test."<init>":()V
   const #4 = Field	#2.#20;	//  Test.x:I
   const #5 = Method	#2.#21;	//  Test.foo:()V
   const #6 = class	#22;	//  java/lang/Object
   const #7 = Asciz	x;
   const #8 = Asciz	I;
   const #9 = Asciz	<init>;
   const #10 = Asciz	()V;
   const #11 = Asciz	Code;
   const #12 = Asciz	LineNumberTable;
   const #13 = Asciz	main;
   const #14 = Asciz	([Ljava/lang/String;)V;
   const #15 = Asciz	foo;
   const #16 = Asciz	SourceFile;
   const #17 = Asciz	Test.java;
   const #18 = NameAndType	#9:#10;//  "<init>":()V
   const #19 = Asciz	Test;
   const #20 = NameAndType	#7:#8;//  x:I
   const #21 = NameAndType	#15:#10;//  foo:()V
   const #22 = Asciz	java/lang/Object;

   {
   int x;

   public Test();
   Code:
   Stack=1, Locals=1, Args_size=1
   0:	aload_0
   1:	invokespecial	#1; //Method java/lang/Object."<init>":()V
   4:	return
   LineNumberTable:
   line 2: 0

   public static void main(java.lang.String[]);
   Code:
   Stack=2, Locals=2, Args_size=1
   0:	new	#2; //class Test
   3:	dup
   4:	invokespecial	#3; //Method "<init>":()V
   7:	astore_1
   8:	aload_1
   9:	bipush	100
   11:	putfield	#4; //Field x:I
   14:	aload_1
   15:	invokevirtual	#5; //Method foo:()V
   18:	return
   LineNumberTable:
   line 5: 0
   line 6: 8
   line 7: 14
   line 8: 18

   void foo();
   Code:
   Stack=0, Locals=1, Args_size=1
   0:	return
   LineNumberTable:
   line 11: 0

   }
#+END_EXAMPLE
**** put/set static field
     java code:
#+BEGIN_EXAMPLE
     class Test {
        static float x=1.1f;
	public static void main(String args[]) {
	    x=1.2f;
	  }
      }
#+END_EXAMPLE
     byte code:
#+BEGIN_EXAMPLE
     ...
     const #3 = Field        #5.#20; //  Test.x:F
     ...
     0:   ldc     #2; //float 1.2f
     2:   putstatic       #3; //Field x:F
     ...
#+END_EXAMPLE
**** literal
***** String literal
      java code:
      #+BEGIN_EXAMPLE
      public class Test {
      public static void main(String args[]) {
      String s1="abc";
      }
      }
      #+END_EXAMPLE
      byte code:
      #+BEGIN_EXAMPLE
      ~@mbjswglx56> javap -verbose Test
      Compiled from "Test.java"
      public class Test extends java.lang.Object
      SourceFile: "Test.java"
      minor version: 0
      major version: 49
      Constant pool:
      const #1 = Method       #4.#13; //  java/lang/Object."<init>":()V
      const #2 = String       #14;    //  abc
      const #3 = class        #15;    //  Test
      const #4 = class        #16;    //  java/lang/Object
      const #5 = Asciz        <init>;
      const #6 = Asciz        ()V;
      const #7 = Asciz        Code;
      const #8 = Asciz        LineNumberTable;
      const #9 = Asciz        main;
      const #10 = Asciz       ([Ljava/lang/String;)V;
      const #11 = Asciz       SourceFile;
      const #12 = Asciz       Test.java;
      const #13 = NameAndType #5:#6;//  "<init>":()V
      const #14 = Asciz       abc;
      const #15 = Asciz       Test;
      const #16 = Asciz       java/lang/Object;

      {
      public Test();
      Code:
      Stack=1, Locals=1, Args_size=1
      0:   aload_0
      1:   invokespecial   #1; //Method java/lang/Object."<init>":()V
      4:   return
      LineNumberTable:
      line 2: 0

      public static void main(java.lang.String[]);
      Code:
      Stack=1, Locals=2, Args_size=1
      0:   ldc     #2; //String abc
      2:   astore_1
      3:   return
      LineNumberTable:
      line 4: 0
      line 5: 3

      }
      #+END_EXAMPLE
      可见,"abc"这个string literal被保存在constant pool #14/#2 的位置, java代码使用 `ldc #2` 从 constant pool中获得这个string, 并放到栈顶.

      ldc pushes a one-word constant from the constant pool onto the operand stack. the following java types can be pushed using ldc:
       - int
       - float
       - String

      Pushing a String causes a reference to a java.lang.String object to be constructed and pushed onto the operand stack. Pushing an int or float causes
      a primitive value to be pushed;

      String literal总是放在constant pool中, 并通过 ldc 加载.

***** int, float literal
     java code:
#+BEGIN_EXAMPLE
     Integer i=100;
#+END_EXAMPLE
     byte code:
#+BEGIN_EXAMPLE
     0:   bipush  100
     2:   invokestatic    #2; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     5:   astore_1
#+END_EXAMPLE
     java code:
#+BEGIN_EXAMPLE
     Integer i=100000;
#+END_EXAMPLE
     byte code:
#+BEGIN_EXAMPLE
     0:   ldc     #2; //int 100000
     2:   invokestatic    #3; //Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     5:   astore_1
#+END_EXAMPLE
     - 对于int常量, >short时放在constant pool, <short时直接写到代码中
     - ldc 对于 int 只是放 primitive 值放在 stack中, Integer的 autoboxing 实际就是隐式的调用了 Integer.valueOf
     - float常量始终存放在constant pool中
*** Class Loader
**** DONE class unloading
     SCHEDULED: <2011-08-03 Wed> CLOSED: [2011-08-03 Wed 17:56]
     - State "DONE"       from "DOING"      [2011-08-03 Wed 17:56]
*** invokeXXX
**** invokevirtual vs. invokespecial
     similar with c++'s call-by-reference and call-by-value; that is, `invokespecial` will prohibit polymorphism.
**** invokestatic
     direct addressing
**** invokeinterface
     contant-pool would be iterated to find the interface method, since an object can inhereit multiply interface;
** Concurrent
   see also [[Immutable Collection]]
   see also [[CopyOnWriteArrayList]]
*** TODO AbstractQueuedSynchronizer
*** LockSupport
*** Callable vs. Runnable
*** CANCELED Future & FutureTask
    - State "CANCELED"   from "DOING"      [2011-07-18 Mon 17:43]
    see also [[Callable vs. Runnable]]
*** CountDownLatch
*** ReentrantLock
*** Semaphore
*** CyclicBarrier
*** Exchanger
*** Executor
** HttpClient
*** cookie
*** connection pool
** GC
   see also [[Java Criticism]]
*** Reference counting
*** Trace
**** Mark & sweep GC
**** Stop and copy
*** GC root
** CG (code generation / 代码生成 )
   see also [[CGLIB]]
   see also [[ASM]]
   see also [[Proxy]]
** GP
   see also [[Java Criticism]]
   google: “这可不是泛型”-Bruce Eckel眼中的Java泛型..
** DONE JDK Dynamic Proxy & CGLIB
   SCHEDULED: <2011-08-30 Tue> CLOSED: [2011-09-07 Wed 10:32]
   - State "DONE"       from "DOING"      [2011-09-07 Wed 10:32]
   see also [[Proxy]]
** JNI
*** tools
**** javah
**** javap
*** Reference
**** GlobalRef
***** NewGlobalRef/DeleteGlobalRef
**** LocalRef
***** DeleteLocalRef/NewLocalRef
***** PopFrame/PushFrame
*** JNIEnv
**** AttachThread
*** Monitor
**** MonitorEnter/MonitorExit
** Reflect
*** Class
**** newInstance
**** forName
**** getConstructor, getDeclaredConstructor
**** getField, getDeclaredField
**** getMethod, getDeclaredMethod
*** Field
**** get
**** set
**** setAccessible
*** Method
*** Constructor
**** newInstance
*** Proxy
    see also [[Dynamic Proxy]]
** NIO
*** Buffer
**** ByteBuffer
** Optimization
** Java Collection Framework
*** DONE Immutable Collection
    SCHEDULED: <2011-07-26 Tue> CLOSED: [2011-07-27 Wed 15:27]
    - State "DONE"       from "DOING"      [2011-07-27 Wed 15:27]
    see also [[Java Criticism]]
    see also [[Concurrent]]
    see also [[CopyOnWriteArrayList]]
    see also [[Collections.unmodifiableXXX]]

    google: why i hate java.util collection library

    SUN has inverted the Metabolite vs. Immutability in the class hierarchy.
    Immutability, in ANY language that wants to:
      1. guarantee semantics,
      2. ease concurrency
      3. resource contention
    should have immutability as a default.
    However, SUN have decided to have Mutablity  as a default.
    e.g.
    `Collection unmodifiableList(Collection)` will return an immutabile collection, BUT, the unmodifiableList wrapper does nothing but wrap the
    `setXXX`, `addXXX`, `removeXXX` function to throw exception...
*** Collections
**** Collections.EMPTY_LIST & Collections.emptyList()
     Sometimes we need to return an `empty` collections to indicate that no data available...what ever.
     Instead of return `new ArrayList(0)`, we can simply return Collections.EMPTY_LIST, which is itself an [[Immutable Collection]] and light-weighted
**** Collections.unmodifiableXXX
     see also [[Immutable Collections]]
**** Collection.synchronizedXXX
*** CopyOnWriteArrayList / CopyOnWriteArraySet
    see also [[Immutable Collection]]
** Serialization
** DONE UncaughtExceptionHandler
   CLOSED: [2011-07-25 Mon 13:37]
   - State "DONE"       from "TODO"       [2011-07-25 Mon 13:37]
   see also [[Java Process Creation]]
   see also [[Android Process Crash and Restart]]
** JDWP
** Memory Model
   Memory model mainly talks about two topics:
   1. re-ordering  (bytecode related)
      compiler writer should care about re-ordering in java language level
      Note: re-ordering in java language level has nothing to do with `out-of-order` execution of the CPU.

   2. visibility   (cpu related)
      compiler writer should insert some memory barrier to instruct CPU to update it's cache.
*** happen-before
    - happen-before is a partial relationship introduced to java memory model in JSR-133.
    - In single-threaded execution, all java instructions follows the `as-if-serial` semantic (introduced in LS),
      there is no need to enforce the happen-before relationship.
    - In multi-threaded execution, happen-before relationship is enforced to make sure that there is no race condition.
    - `volatile`, `synchronization`, `Thread` will heavily affect the happen-before relationship;
    - happen-before affect both the re-ordering and visibility.
*** DONE double-checked locking
    CLOSED: [2011-08-19 Fri 11:36]
    - State "DONE"       from ""           [2011-08-19 Fri 11:36]
    :PROPERTIES:
    :CUSTOM_ID: @double-checked locking
    :END:
    see also [[Memory Model]]
    google: double-checked locking is BROKEN

    Double-checked locking was broken, just before JSR-133
#+BEGIN_EXAMPLE
    class Foo {
      private volatile Helper helper = null;
      public Helper getHelper() {
        Helper result = helper;
        if (result == null) {
            synchronized(this) {
                result = helper;
                if (result == null)
                    helper = result = new Helper();
            }
        }
        return result;
      }
    }
#+END_EXAMPLE

   SCHEDULED: <2011-08-08 Mon>
*** JSR 133 FAQ
    google: JSR 133 (Java Memory Model) FAQ
    - volatile
    - final
    - synchronization
** Java Module System
   see also [[ClassLoader]]
*** JSR-277: Java Module System
*** OSGi & HotSwap
** ClassLoader
   see also [[Java Module System]]
*** Thread.setContextClassLoader() / Thread.getContextClassLoader()
    a backdoor in the ClassLoader architecture, which broken up the `Parents Delegation Scheme`, mainly used by JNDI,JDBC,JAXP and OSGi
*** Class.getClassLoader()
    This is the default ClassLoader for Class.forName()
*** ClassLoader.getSystemClassLoader()
** CG (Code Generation)
*** ASM
    see also [[Visitor Pattern]]
** Security
*** ClassLoader
*** SecurityManager
*** TODO Policy
*** How To Run Beanshell in Sandbox?
*** keystore
    keystore 中同时包含公钥,私钥及证书
*** TODO keytool & jarsigner
    see also [[数字签名]] [[数字证书]]
    http://download.oracle.com/javase/1.3/docs/tooldocs/win32/jarsigner.html

    jarsigner will add two additional files to the original jar to generate
    the signed jar:
     1. xxx.sf
	xxx.sf will contains the HASH of every source file, e.g.
	XX1.java
	ADFASDFASDFASDFASDFASF
	XX2.java
	SAFASDFASDFASDFASDFASDFSAF
	...
     2. xxx.dsa
	xxx.dsa is encoded in two parts:
	1. digital signature of the xxx.sf
	2. certificate used to verify the signature
* Design Pattern
#+CATEGORY: GOF
** abstract factory
** adapter
** bridge
** decorator
** facade
** factory
** observer
** reactor / proactor
** Visiton Pattern
   see also [[ASM]]
** singleton
   see [[@double-checked locking]]
   see [[@initialization on-demand holder]]
* Python							    :ARCHIVE:
#+CATEGORY:Python
** map,reduce,filter, [x*x for x in l if x>10]
** zip
* Algorithm
#+CATEGORY:Algorithm
** TODO [#C] 并查集(union find set)
** TODO [#C] 红黑树(rb tree)
** TODO [#C] 迪卡尔树 (Cartesian tree)
** 素数的判定
   费马说: 全部素数可分为4n+1和4n+3两种形式 (反之不成立)
** ip checksum
#+BEGIN_EXAMPLE
   static uint16_t ip_sum_calc(uint16_t count,char *addr) {
    /* Compute Internet Checksum for "count" bytes
     * beginning at location "addr".
     */
    u_int32_t sum = 0;
    while( count > 1 ) {
	/* This is the inner loop */
	sum += ntohs(* (u_int16_t*) addr);
	addr += 2;
	count -= 2;
    }
    /* Add left-over byte, if any */
    if( count > 0 )
	sum += * (u_int8_t *) addr;
    /* Fold 32-bit sum to 16 bits */
    while (sum>>16)
	sum = (sum & 0xffff) + (sum >> 16);
    return (u_int16_t)~sum;
   }
#+END_EXAMPLE

** 牛顿迭代法求平方根
   a(n+1)=(a(n)+N/a(n))/2
   其中a(0)是任意初始值,N是被开方的数,当n趋向无穷时,a(n)趋向于 sqrt(N)
** tricky
*** 一次遍历随机取出链表中元素

    - 给你一个长度为N的链表。N很大，但你不知道N有多大。你的任务是从这N个元素中随
     机取出k个元素。你只能遍历这个链表一次。你的算法必须保证取出的元素恰好有k个，
     且它们是完全随机的（出现概率均等）。

      - A：不失一般性，令K=1。算法：从头开始遍历链表。对于第i个节点，在k/i的概率
     下，让这个节点成为候选节点。最后留下个那个候选节点则是概率为K/N的幸运儿。

     用数学归纳法证明: 任何一个节点的入选概率都是1/N。N = 1时自然正确。假设
     N=i时，每个节点的入选概率都是1/i。也就是说，当前候选节点可能是1..i中的任何一
     个。则当N=i+1时，当前候选节点继续保留的概率为(1 - 1/(i+1))。它的总入选概率是
     1/i * (1 - (1/(i+1)) = 1/(i+1)。 而第i+1个节点的入选概率是1/(i+1)。因此，当
     N=i+1时，每个节点的入选概率是1/(i+1)。(证毕)

     当K>1时，令候选节点集合大小为k。当要替换候选节点时，每次从中这个集合中随机替
     换即可。
*** 给你一个数组A[1..n]，请你在O(n)的时间里构造一个新的数组B[1..n]，使得B[i]=A[1]*A[2]*...*A[n]/A[i]。你不能使用除法运算
    a[1]*a[2]*...*a[n]*exp(-ln(a[i])) ?
** floyd-warshall
   O(N^3)求解最短路径

#+BEGIN_EXAMPLE
   for (int i=0;i<N;++i) {
       for (int j=0;i<N;++i) {
           for (int k=0;i<N;++i) {
	       opt[j][k]=max(opt[j][k],opt[j][i]+opt[i][k])
	   }
       }
   }
#+END_EXAMPLE
** 串
*** 最长非重复子串
*** 最长公共子串
    http://en.wikipedia.org/wiki/Longest_common_substring_problem
*** 最长公共子序列
    http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
*** 最长回文串 (后缀数组)
    http://richardxx.yo2.cn/
    http://en.wikipedia.org/wiki/Suffix_array
    [[file:~/suffix_array.pdf]]
*** RK算法 (hash based pattern matching algo)
    http://en.wikipedia.org/wiki/Rabin-Karp_string_search_algorithm
*** 拼写检查
    http://www.matrix67.com/blog/archives/333
    http://en.wikipedia.org/wiki/Levenshtein_distance
* Linux Dev
#+CATEGORY:Linux dev
** TODO [#C] IBM ICU and HanziToPinyin in android
** DONE [#C] UTC,GMT,Wall Time and so on
   SCHEDULED: <2011-01-21 Fri> CLOSED: [2011-01-24 Mon 10:20]
   - State "DONE"       [2011-01-24 Mon 10:20]
     UTC = Universal Time Coordinate
     GMT = Greenwich Mean Time
     UTC and GMT are almost identical, but UTC use atomic clock.
     Wall Time, unix RTC time, measured from 1970/1/1 0:00:00
** DONE 程序运行时进行IO重定向
   CLOSED: [2011-03-01 Tue 10:59]
   - State "DONE"       [2011-03-01 Tue 10:59]
#+BEGIN_EXAMPLE
   $>gdb
   (gdb) attach pid
   (gdb) p close(1)
   (gdb) p open("/tmp/xxx",1,0755)
   (gdb) q
#+END_EXAMPLE
** TODO setuid() & SETUID flag
** DONE uuid
   SCHEDULED: <2011-05-31 Tue> CLOSED: [2011-07-01 Fri 13:44]
   - State "DONE"       from "DOING"      [2011-07-01 Fri 13:44]
** TODO 同步,互斥,信号量
** pthread_mutex_lock 开销
** 关于ctors,init...
   main.cpp:
     A a,b,c;
     B x;
     main() {...}
   最终生成的./a.out中, 有一个_global_I_a的函数,它会调用_static_init_global_...函数,这个函数会负责初始化a,b,c,x
   另外,在.init section中,会调用__do_global_ctors_aux,后者会从.ctors section中读出几个地址,顺序执行. 而.ctors section中
   会保存_global_I_a的地址. 由于所有全局变量的初始化都放在一个_static_init_global..函数中,所以.ctors section一般只需要保存一个4
   字节的数据.

   另外,__attribute__((contructor))和__attribute__((section (".ctors")))可以给.ctors section添加新数据,使程序执行或so载入时可
   以执行额外的函数


*** atexit,.init,.fini是什么关系
    void foo() __attribute__((destructor));
    T t;
    int main() {}

    执行的结果是: main之前,t的ctor先执行,正常退出时,t的dtor先执行,foo再执行
    原因:
    _start --- __libc_start_main (main,argc,argv,init,fini ..)
    而__libc_start_main大致为:
     if (fini)
        atexit (fini);
     if (init)
        (*init) ();
     exit ((*main) (argc, argv, __environ));
     即__libc_start_main会先将.fini段中的_fini函数用atexit注册,然后执行.init段中的_init函数,而_init函数一般是:调用.ctors段中的ctor,例如前面提到的
     _global_I_a..函数,这个函数最终会调用各个全局变量的构造函数,然后用atexit注册相应的析构函数

     因为atexit先注册的后执行,所以exit时析构函数先执行,然后_fini才执行(注:析构函数并不在.fini中)

** 静态库与.o还是有区别的
#+BEGIN_EXAMPLE
   foo.cpp:
   class A {
   public:
       A() {cout<<"a"<<endl;}
   };
   A a,b,c;
   main.cpp
   main(){}

   g++ main.cpp foo.cpp时,a会被初始化
   ar cr libfoo.a foo.o
   g++ main.cpp -L./ -lfoo时,a不会被初始化
   另外,
   g++ foo.cpp -shared -fPIC -o libfoo.so
   g++ main.cpp -L./ -lfoo时,a会被初始化
#+END_EXAMPLE

   究其原因:
   情况1. main.cpp foo.cpp中的全局变量被.init段的代码初始化,这是elf针对c++专门设计的
   情况2. 由于main.cpp没有引用foo.cpp中的任何东西,导致libfoo.a中的foo.o根本不会被链接到./a.out中
   情况3. 在main执行之前,libfoo.so被ld.so动态载入后,由ld.so负责调用.init段的初始化代码初始全局变量

   另外,静态库链接到程序时,是以.o为单位的,即若main.cpp需要libfoo.a的foo.o的一个函数时,foo.o中的所有东西
   都会链接进来.

   另外,由于一个编译单元中所有全局变量的初始化都是在一个函数中完成的([[*%20ctors%20init][ctor]]),所以foo.o被链接后,所有全局变量都会被初
   始化,而不是只有main.cpp中用到的变量被初始化
** ld链接器脚本
   http://hi.baidu.com/chosin/blog/item/be1a507b02eb54f70bd18712.html
   ld --verbose 显示默认链接器脚本
   链接器脚本可以:
   - 确定把各目标文件中的哪些section合并,如 .data : { *(mydata) } 即把所有文件中的mydata section合并成.data section
   - 确定合并后的section的起始地址,如
     . = 0x8049095;
     .data : { *(mydata) }
     即是使.data section的起始地址为0x8049095;
   - 设定生成的可执行文件的entry
     ENTRY (_start)
   - 对符号赋值
     .data : {*(.data)}
     _edata = .;
     即添加了一个_edata符号,$_edata即.data段的末尾的地址
     1.c:
     int a;
     lds:
     a = 3;
     则1.c中a变量的地址会变成3

** 修改了.so或executable，正在运行的程序会有啥影响？
   executable使用exec一类函数映射到进程地址空间
   .so使用mmap映射到进程地址,使用的参数类似于:
       mmap2(NULL, 44424, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0)

   MAP_PRIVATE表示私有映射,即本进程对文件的修改不会反映到对应的文件上
   但外部程序(如MAP_PUBLIC的mmap,或cp..)对.so文件的修改会反映到本进程,因而可能影响程序的正常运行.

   mmap的参数MAP_DENYWRITE本来用意就是阻止外部程序对mmap映射的文件的修改的,但这个
   mmap的选项在用户态已经被ignored了(但这个选项在内核还是有效的)....据说是因为会
   有dos风险

   所以.so被mmap后,外部的修改会影响已经mmap的.so,使程序崩溃
   有一个patch可以保护.so,其实就是不管有没有MAP_DENYWRITE选项,内核都对带PROT_EXEC的mmap加DENYWRITE:
   ETXTBUSY on shared libs (patch included)
   http://lkml.indiana.edu/hypermail/linux/kernel/9808.2/1046.html

   与.so不同的是,executable被mmap后,内核可以保证executable文件不能被其他程序修改,其
   他程序打开文件时,会返回ETXTBUSY

   executable被保护,是因为:
   executable都是通过sys_execve->do_execve->open_exec映射到内存的,open_exec中有一段:

#+BEGIN_EXAMPLE
   494 err = deny_write_access(file);
   495 if (err) {
   496   fput(file);
   497   file = ERR_PTR(err);
#+END_EXAMPLE
   所以executable可以被denywrite保护

   综上:
   .so在加载后可能被外部程序修改(比如cp),linux没有什么办法保护.so,唯一的办法就是注意不要无意修改.so,例如:
   安装新版本的.so时,不要直接cp,而要先rm .so,再cp .so,或使用install

** 外部对.so的修改是如何让正在使用.so的程序崩溃的
   - so都是用MAP_PRIVATE进行mmap的,在Linux的实现中,外部对.so的修改会反映到mmap的
   区域中,不管是MAP_PRIVATE还是MAP_SHARED,即使MAP_PRIVATE使用了COW使程序只是修改
   原so的附本,外部对.so的修改还是会反映到附本的区域....穷追不舍啊
   - loader将so载入时,不仅仅要用mmap把so映射进来,还要对映射的区域的一些内容进行修改,根据
     so类型的不同(是否使用了-fPIC选项),修改也会有所不同
   外部程序修改了so使正在使用so的程序崩溃的原因是:外部程序的修改直接反映到mmap区域,loader载入so时
   对mmap区域的一些修改因此丢失,而这些修改是关键的,因此程序崩溃

   - loader对mmap区域的修改:
     - so用-fPIC编译时:
       so中对全局变量的引用使用GOT表,对自己无法解析的其他函数的调用使用PLT表,这两个表都在.data段中,初始为空
       loader将so载入时,会填充GOT表,并将PLT表的所有entry置为loader自己的地址,将so初次调用PLT表的函数时,loader会
       负责查找这个函数的真正地址,用它替换掉entry中自己的地址,并调用之,这也是一种lazy evaluation.
     - so没用-fPIC编译时:
       so中对全局变量的引用和无法解析的函数的调用都是0,load在载入so时,会修改这些值,即会同时修改.data和.text
   因为外部程序修改so时,原来loader对mmap区域的修改都丢失了,导致so中全局变量和函数调用都变成空,出现段错误

** abi for register
   ==========i386 ABI / function calling sequence ==========

All registers on the Intel386 are global and
thus visible to both a calling and a
called function. Registers %ebp, %ebx, %edi,
%esi, and %esp 'belong' to the calling
function. In other words, a called function
must preserve these registers' values for
its caller. Remaining registers 'belong' to
the called function. If a calling
function wants to preserve such a register
value across a function call, it must
save the value in its local stack frame.


Some registers have assigned roles in the standard calling sequence:

%esp
The stack pointer holds the limit of the current stack frame, which
is the address of the stack’s bottom-most, valid word. At all
times, the stack pointer should point to a word-aligned area.

%ebp
The frame pointer optionally holds a base address for the current G
stack frame. Consequently, a function has registers pointing to
both ends of its frame. Incoming arguments reside in the previous
frame, referenced as positive offsets from %ebp, while local
variables reside in the current frame, referenced as negative
offsets from %ebp. A function must preserve this register’s value
for its caller.

%eax
Integral and pointer return values appear in %eax. A function that
returns a struct or union value places the address of the result
in %eax. Otherwise this is a scratch register.


%ebx
As described below, this register serves as the global offset table
base register for position-independent code. For absolute code,
%ebx serves as a local register and has no specified role in the
function calling sequence. In either case, a function
must preserve the register value for the caller.

%esi and %edi
These local registers have no specified role in the function calling sequence.
A function must preserve their values for the
caller.

%ecx and %edx
Scratch registers have no specified role in the standard calling sequence.
Functions do not have to preserve their values for
the caller.



%st(0)
Floating-point return values appear on the top of the floatingpoint
register stack; there is no difference in the representation
of single- or double-precision values in floating-point registers.
If the function does not return a floating-point value, then this
register must be empty. This register must be empty before G
entry to a function.

%st(1) through %st(7)
Floating-point scratch registers have no specified role in the standard
calling sequence. These registers must be empty before
entry and upon exit from a function.

EFLAGS
The flags register contains the system flags, such as the direction
flag and the carry flag. The direction flag must be set to the
‘‘forward’’ (that is, zero) direction before entry and upon exit
from a function. Other user flags have no specified role in the
standard calling sequence and are not preserved.

Floating-Point Control Word
The Intel387 control word contains the floating-point flags, such
as the rounding mode and exception masking.

** man 7 signal
   standard signal
   real-time signal
       信号队列
       siginfo_t包含额外的信息,如信号发送方的uid
   可重入系统调用
   可靠信号
   sigqueue/kill
   sigsuspend/pause

** libnotify
** pid,ppid,tgid,pgid,sid, and signal
   - pid 是进程/线程的唯一标识,但getpid并不是返回task_struct的pid字段,而是返回
     task_struct->tgid,因为posix规定一个进程创建的多个线程的getpid的结果是一样的,都是那个进程的id
     gettid返回真正的pid
   - ppid 父进程
     线程创建时使用了CLONE_PARENT,所以各个线程和主线程的的ppid都是主线程的ppid
     #>ps -meo cmd,pid,ppid,pgid,tid
     ./a.out                     23874 23237 23874     -
      -                               -     -     - 23874
      -                               -     -     - 23875
     而若a.out使用进程来创建子进程,相当于clone没指定CLONE_PARENT
     #>ps -meo cmd,pid,ppid,pgid,tid
     ./a.out                     23885 23237 23885     -
     -                               -     -     - 23885
     ./a.out                     23886 23885 23885     -
     -                               -     -     - 23886

   - tgid是线程组id,getpid返回tgid
   - pgid,组id. 子进程继承pgid,shell管道中各个进程有相同的pgid,kill -9 -pgid 可以给所有组id是pgid的进程发SIGKILL,
     而kill -9 pid只给pid是pid的进程发SIGKILL.
     If pid is less than -1, then sig is sent to every process in the process group whose ID is -pid.
     pgid可以使我们同时管理一组进程,比如发信号,另外,shell的作业控制也使用了pgid,比如tcsetpgrp(fd,pgid)使得所有组id为pgid的进程
     处于前台(即C-c给这个进程发SIGINT,这些进程的stdin,stdout为fd...) 另外, 要将一个进程daemonize通常需要关闭stdin/stdout,setpgid为自已的pid,
     setsid为自己的pid,其中setpgid的作用就是让进程脱离父进程的进程组,以免kill -SIG 时误杀daemon进程
   - sid,会话id,完全和shell有关的id,一个shell启动的所有进程的sid一样,当shell退出时,shell会向同一个会话id的进程发SIGHUP

** SIGSTOP与SIGCONT
   kill -SIGSTOP pid 可以将一个进程置于STOP状态,只有收到SIGCONT才能继续执行. 与各
   种sleep,mutex,阻塞而置于STOP状态不同的是,因SIGSTOP停止的进程不会因为SIGCONT以
   外的其他条件而苏醒
   SIGSTOP与SIGKILL一样不能修改handler

** objcopy 将数据文件保存在目标文件中
#+BEGIN_EXAMPLE
   #> objcopy -I binary  -O elf32-i386 -B i386 source.c sourcefile.o
   #> nm -a sourcefile.o|grep source.c
   00000179 D _binary_source_c_end
   00000179 A _binary_source_c_size
   00000000 D _binary_source_c_start

   #> cat source.c
   #include <stdio.h>
   extern char _binary_source_c_start,  _binary_source_c_end;
   int main(void) {
       char * start=(char *)&_binary_source_c_start;
       char * end=(char *)&_binary_source_c_end;
       while (start++!=end) {
           printf ("%c",*start);
       }
       return 0;
   }


   #>gcc source.c sourcefile.o -o ./a.out
   #> a.out 显示source.c的内容
#+END_EXAMPLE
   ps. c语言中的变量名和汇编语言中的符号的关系:
   变量名和汇编符号是对应的,不过直接引用变量名取到的是值,而直接引用汇编符号取到的是地址

** self-modification code						:ATTACH:
   :PROPERTIES:
   :Attachments: 1.S
   :ID:       ewhabz210oe0@sunway-lab.bupt.edu.cn
   :END:
   Note:mprotect is the key
   http://en.wikipedia.org/wiki/Self-modifying_code
   self-modifying code的作用:

   The method is frequently used for conditionally invoking test/debugging code
   without requiring additional overhead for every input/output cycle and also
   in just-in-time (JIT) compilers.

   能够避免使用 if (flag..) then ..这种语句,因为当flag发生时,代码已经被修改,后面
   的执行不需要再判断flag,用来优化和状态相关的循环

   例如:
   - c++的多态.实际就是通过修改vtbl将条件直接通过代码的修改体现
   - elf对共享库的函数的调用. 调用库函数时通过plt调用,例如foo@plt初始时实际是
     loader的代码,第一次执行foo时loader负责把foo@plt修改为真正的foo的位置
   - 对函数指针的修改也可以看作是更高层次上的self-modifying code

** How main() is executed on Linux
Starting

The question is simple: how does linux execute my main()?
Through this document, I'll use the following simple C program to illustrate how it works. It's called "simple.c"

main()
{
   return(0);
}


Build

gcc -o simple simple.c


What's in the executable?

To see what's in the executable, let's use a tool "objdump"

objdump -f simple

simple:     file format elf32-i386
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x080482d0

The output gives us some critical information about the executable.
 First of all, the file is "ELF32" format. Second of all, the start address is "0x080482d0"
What's ELF?

ELF is acronym for Executable and Linking Format. It's one of several object and executable file formats used on Unix systems. For our discussion, the interesting thing about ELF is its header format. Every ELF executable has ELF header, which is the following.

typedef struct
{
	unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
	Elf32_Half	e_type;			/* Object file type */
	Elf32_Half	e_machine;		/* Architecture */
	Elf32_Word	e_version;		/* Object file version */
	Elf32_Addr	e_entry;		/* Entry point virtual address */
	Elf32_Off	e_phoff;		/* Program header table file offset */
	Elf32_Off	e_shoff;		/* Section header table file offset */
	Elf32_Word	e_flags;		/* Processor-specific flags */
	Elf32_Half	e_ehsize;		/* ELF header size in bytes */
	Elf32_Half	e_phentsize;		/* Program header table entry size */
	Elf32_Half	e_phnum;		/* Program header table entry count */
	Elf32_Half	e_shentsize;		/* Section header table entry size */
	Elf32_Half	e_shnum;		/* Section header table entry count */
	Elf32_Half	e_shstrndx;		/* Section header string table index */
} Elf32_Ehdr;

In the above structure, there is "e_entry" field, which is starting address of an executable.
What's at address "0x080482d0", that is, starting address?

For this question, let's disassemble "simple". There are several tools to disassemble an executable. I'll use objdump for this purpose.

objdump --disassemble simple

The output is a little bit long so I'll not paste all the output from objdump. Our intention is see what's at address 0x080482d0. Here is the output.

080482d0 <_start>:
 80482d0:       31 ed                   xor    %ebp,%ebp
 80482d2:       5e                      pop    %esi
 80482d3:       89 e1                   mov    %esp,%ecx
 80482d5:       83 e4 f0                and    $0xfffffff0,%esp
 80482d8:       50                      push   %eax
 80482d9:       54                      push   %esp
 80482da:       52                      push   %edx
 80482db:       68 20 84 04 08          push   $0x8048420
 80482e0:       68 74 82 04 08          push   $0x8048274
 80482e5:       51                      push   %ecx
 80482e6:       56                      push   %esi
 80482e7:       68 d0 83 04 08          push   $0x80483d0
 80482ec:       e8 cb ff ff ff          call   80482bc <_init+0x48>
 80482f1:       f4                      hlt
 80482f2:       89 f6                   mov    %esi,%esi

Looks like some kind of starting routine called "_start" is at the starting address. What it does is clear a register, push some values into stack and call a function. According to this instruction, the stack frame should look like this.

Stack Top	-------------------
		0x80483d
		-------------------
		esi
		-------------------
		ecx
		-------------------
		0x8048274
		-------------------
		0x8048420
		-------------------
		edx
		-------------------
		esp
		-------------------
		eax
		-------------------


Now, as you already wonder,we've got a few questions regarding this stack frame.



   1. What are those hex values about?
   2. What's at address 80482bc, which is called by _start?
   3. Looks like the assembly instructions doesn't initialize any register with possibly meaningful values. Then who initializes the registers?



Let's answer these questions one by one.

Q1>The hexa values.

If you look at disassembled output from objdump carefully, you can answer this question easily.

Here is answer.

0x80483d0 :        This is the address of our main() function.

0x8048274 :         _init function.

0x8048420 :        _fini function _init and _fini is initialization/finalization function provided by GCC.

Right now, let's not care about these stuffs. And basically, all those hexa values are function pointers.

Q2>What's at address 80482bc?

Again, let's look for address 80482bc from the disassembly output.
If you look for it, the assembly is

80482bc:	ff 25 48 95 04 08    	jmp    *0x8049548


Here *0x8049548 is a pointer operation.
 It just jumps to an address stored at address 0x8049548.


More about ELF and dymanic linking

With ELF, we can build an executable linked dynamically with libraries.
Here "linked dynamically" means the actual linking process happens at runtime. Otherwise we'd have to build a huge executable containing all the libraries it calls (a "statically-linked executable). If you issue the command

"ldd simple"

	  libc.so.6 => /lib/i686/libc.so.6 (0x42000000)
	  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)

You can see all the libraries dynamically linked with simple. And all the dynamically linked data and functions have "dynamic relocation entry".

The concept is roughly like this.


   1. We don't know actual address of a dynamic symbol at link time. We can know the actual address of the symbol only at runtime.
   2. So for the dynamic symbol, we reserve a memory location for the actual address.
      The memory location will be filled with actual address of the symbol at runtime by loader.
   3. Our application sees the dynamic symbol indirectly with the momeory location by using kind of pointer operation. In our case, at address 80482bc, there is just a simple jump instruction.
      And the jump location is stored at address 0x8049548 by loader during runtime.
      We can see all dynamic link entries with objdump command.

      objdump -R simple

      	simple:     file format elf32-i386

      	DYNAMIC RELOCATION RECORDS
      	OFFSET   TYPE              VALUE
      	0804954c R_386_GLOB_DAT    __gmon_start__
      	08049540 R_386_JUMP_SLOT   __register_frame_info
      	08049544 R_386_JUMP_SLOT   __deregister_frame_info
      	08049548 R_386_JUMP_SLOT   __libc_start_main

      Here address 0x8049548 is called "jump slot", which perfectly makes sense. And according to the table, actually we want to call __libc_start_main.


What's __libc_start_main?

Now the ball is on libc's hand. __libc_start_main is a function in libc.so.6. If you look for __libc_start_main in glibc source code, the prototype looks like this.

extern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **),
		int argc,
		char *__unbounded *__unbounded ubp_av,
		void (*init) (void),
		void (*fini) (void),
		void (*rtld_fini) (void),
		void *__unbounded stack_end)
__attribute__ ((noreturn));

And all the assembly instructions do is set up argument stack and call __libc_start_main.
What this function does is setup/initialize some data structures/environments and call our main().
Let's look at the stack frame with this function prototype.

Stack Top     -------------------
                        0x80483d0                               main
                     -------------------
                        esi                                            argc
                     -------------------
                        ecx                                           argv
                    -------------------
                        0x8048274                             _init
                     -------------------
                        0x8048420                             _fini
                     -------------------
                        edx                                         _rtlf_fini
                     -------------------
                        esp                                         stack_end
                     -------------------
                        eax                                         this is 0
                     -------------------

According to this stack frame, esi, ecx, edx, esp, eax registers should be filled with appropriate values before __libc_start_main() is executed. And clearly this registers are not set by the startup assembly instructions shown before. Then, who sets these registers? Now I guess the only thing left. The kernel.
Now let's go back to our third question.
Q3>What does the kernel do?

When we execute a program by entering a name on shell, this is what happens on Linux.


   1. The shell calls the kernel system call "execve" with argc/argv.
   2. The kernel system call handler gets control and start handling the system call. In kernel code, the handler is "sys_execve". On x86, the user-mode application passes all required parameters to kernel with the following registers.

          * ebx : pointer to program name string
          * ecx : argv array pointer
          * edx : environment variable array pointer.

   3. The generic execve kernel system call handler, which is do_execve, is called. What it does is set up a data structure and copy some data from user space to kernel space and finally calls search_binary_handler(). Linux can support more than one executable file format such as a.out and ELF at the same time. For this functionality, there is a data structure "struct linux_binfmt", which has a function pointer for each binary format loader. And search_binary_handler() just looks up an appropriate handler and calls it. In our case, load_elf_binary() is the handler. To explain each detail of the function would be lengthy/boring work. So I'll not do that. If you are interested in it, read a book about it. As a picture tells a thousand words, a thousand lines of source code tells ten thousand words (sometimes). Here is the bottom line of the function. It first sets up kernel data structures for file operation to read the ELF executable image in. Then it sets up a kernel data structure: code size, data segment start, stack segment start, etc. And it allocates user mode pages for this process and copies the argv and environment variables to those allocated page addresses. Finally, argc, the argv pointer, and the envrioronment variable array pointer are pushed to user mode stack by create_elf_tables(), and start_thread() starts the process execution rolling.




When the _start assembly instruction gets control of execution, the stack frame looks like this.

Stack Top        -------------
                            argc
                        -------------
                            argv pointer
                        -------------
                            env pointer
                        -------------

And the assembly instructions gets all information from stack by

pop %esi 		<--- get argc
move %esp, %ecx		<--- get argv
			  actually the argv address is the same as the current
			  stack pointer.

And now we are all set to start executing.
What about the other registers?

For esp, this is used for stack end in application program. After popping all necessary information, the _start rountine simply adjusts the stack pointer (esp) by turning off lower 4 bits from esp register. This perfectly makes sense since actually, to our main program, that is the end of stack. For edx, which is used for rtld_fini, a kind of application destructor, the kernel just sets it to 0 with the following macro.

#define ELF_PLAT_INIT(_r)	do { \
	_r->ebx = 0; _r->ecx = 0; _r->edx = 0; \
	_r->esi = 0; _r->edi = 0; _r->ebp = 0; \
	_r->eax = 0; \
} while (0)

The 0 means we don't use that functionality on x86 linux.
About the assembly instructions

Where are all those codes from? It's part of GCC code. You can usually find all the object files for the code at
/usr/lib/gcc-lib/i386-redhat-linux/XXX and
/usr/lib where XXX is gcc version.
File names are crtbegin.o,crtend.o, gcrt1.o.


Summing up

Here is what happens.


   1. GCC build your program with crtbegin.o/crtend.o/gcrt1.o And the other default libraries are dynamically linked by default. Starting address of the executable is set to that of _start.
   2. Kernel loads the executable and setup text/data/bss/stack, especially, kernel allocate page(s) for arguments and environment variables and pushes all necessary information on stack.
   3. Control is pased to _start. _start gets all information from stack setup by kernel, sets up argument stack for __libc_start_main, and calls it.
   4. __libc_start_main initializes necessary stuffs, especially C library(such as malloc) and thread environment and calls our main.
   5. our main is called with main(argv, argv) Actually, here one interesting point is the signature of main. __libc_start_main thinks main's signature as main(int, char **, char **) If you are curious, try the following prgram.

      main(int argc, char** argv, char** env)
      {
          int i = 0;
          while(env[i] != 0)
          {
             printf("%s\n", env[i++]);
          }
          return(0);
      }


Conclusion

On Linux, our C main() function is executed by the cooperative work of GCC, libc and Linux's binary loader.

References

objdump                         "man objdump"

ELF header                     /usr/include/elf.h

__libc_start_main          glibc source
                                       ./sysdeps/generic/libc-start.c

sys_execve                     linux kernel source code
                                       arch/i386/kernel/process.c

do_execve                      linux kernel source code
                                       fs/exec.c

struct linux_binfmt       linux kernel source code
                                       include/linux/binfmts.h

load_elf_binary             linux kernel source code
                                       fs/binfmt_elf.c

create_elf_tables           linux kernel source code
                                       fs/binfmt_elf.c

start_thread                   linux kernel source code
                                      include/asm/processor.h
** 静态库
   ar cr libfoo.a 1.o 2.o
** getsockname getpeername
** raw socket中如何指定源地址
   虽然man raw说明,如果指定源地址为0,则内核会自动加上正确的源地址, 但我在ipv6上试没有成功...在raw socket中得到正确的源地址的方法是:
#+BEGIN_EXAMPLE
       void probeSrcAddr () {
	int probeFd = socket(AF_INET6, SOCK_DGRAM, 0);
	if (connect (probeFd, (struct sockaddr*)&toAddr, sizeof(toAddr))==-1) {
	    perror ("connect");
	}
	struct sockaddr_in6 source;
	bzero (&source,sizeof(struct sockaddr_in6));
	socklen_t sourceLen=sizeof(struct sockaddr_in6);
	if (getsockname(probeFd, (struct sockaddr*)&source, &sourceLen)==-1) {
	    perror ("getsockname");
	}
	memcpy (srcAddr,(char *)&source.sin6_addr,16);
      }
#+END_EXAMPLE

   iputils中的ping6.c ping.c都是用的这种方法

** SOCK_RAW, NF_PACKET, sniffer
   使用raw socket能够:
    - 修改整个Ip包
    - 自定义四层协议,如ospf
    - 监听所有的tcp,udp,icmp包,但不能拦截
  int sockfd=socket (PF_INET,SOCK_RAW,protocol),根据protocal的不同,有不同的功能:
    - 当protocol为IPPROTOCOL_TCP,IPPROTO_UDP,IPPROTO_ICMP时,这个socket被限定了用来收发tcp/udp/icmp包,即
      - 向sockfd写时,Ip包的协议字段自动被重写为tcp/udp/icmp
      - 从sockfd读时,可以读到所有收到的tcp/udp/icmp包,注意,这个sockfd并没有像SOCK_STREAM一样绑定端口号,也没有像
	SOCK_DGRAM一样sendto后绑定一个随机端口. SOCK_RAW没有端口号的概念. 所以 sockfd可以读到所有收到的tcp/udp/icmp包
    - 当protocol为SOCK_RAW (0) 的其它数值时,可以用来实现自己的四层协议
      - 向sockfd写时,ip包的协议字段自动重写为protocol的值
      - 从sockfd读时,可以读到ip层收到的所有Protocol为相应的值的ip包
	所以本质上这种情况和情况1是一样的,只不过对于tcp/udp/icmp,系统本身已经提供了直接的支持,注:对于某个协议,可以注册多个raw socket,
	ip层收到属于这个协议的ip包后,会依次传给每个raw socket处理. 这就是为什么 指定protocol为IPPROTOCOL_TCP后,我们自己的sockfd可以
	读到这个tcp包,而且不影响系统自身对tcp包的处理. 链路层的PF_PACKET(sniffer)也是这种处理方法,所以sniffer只能监听,而不能拦截
    - 总结:protocol的值对wirte sockfd的影响主要是:ip头中的协议字段会被自动修改为protocol的值,对read sockfd的影响:ip头为协议字段为protocol的包会被读到
    - 当protocol为IPPROTOCOL_RAW(0)时
      - 向sockfd写时,ip包完全不会被修改
      - 系统限制不能从这种sockfd中读,要实现这个功能,需要用 PF_PACKET
** weak symbol
   http://www.tortall.net/projects/yasm/manual/html/objfmt-elf-directives.html
   ref [[*c%20inline%20function][c++ inline function]] [[*gcc%20__attribute__%20syntax][gcc __attribute__ extension]]
   ELF allows defining certain symbols as “weak”. Weak symbols are similar to
   global symbols, except during linking, weak symbols are only chosen after
   global and local symbols during symbol resolution. Unlike global symbols,
   multiple object files may declare the same weak symbol, and references to a
   symbol get resolved against a weak symbol only if no global or local symbols
   have the same name.

   This functionality is primarily useful for libraries that want to provide
   common functions but not come into conflict with user programs. For example,
   libc has a syscall (function) called “read”. However, to implement a threaded
   process using POSIX threads in user-space, libpthread needs to supply a
   function also called “read” that provides a blocking interface to the
   programmer, but actually does non-blocking calls to the kernel. To allow an
   application to be linked to both libc and libpthread (to share common code),
   libc needs to have its version of the syscall with a non-weak name like
   “_sys_read” with a weak symbol called “read”. If an application is linked
   against libc only, the linker won't find a non-weak symbol for “read”, so it
   will use the weak one. If the same application is linked against libc and
   libpthread, then the linker will link “read” calls to the symbol in
   libpthread, ignoring the weak one in libc, regardless of library link
   order. If libc used a non-weak name, which “read” function the program ended
   up with might depend on a variety of factors; a weak symbol is a way to tell
   the linker that a symbol is less important resolution-wise.

   The `weak' attribute causes the declaration to be emitted as a weak
     symbol rather than a global.  This is primarily useful in defining
     library functions which can be overridden in user code, though it
     can also be used with non-function declarations.  Weak symbols are
     supported for ELF targets, and also for a.out targets when using
     the GNU assembler and linker.

** pthread signal,wait,lock,unlock顺序					:ATTACH:
   :PROPERTIES:
   :Attachments: 1.c
   :ID:       bxibmeh0bge0@sunway-lab.bupt.edu.cn
   :END:

** How do I get a core dump from a running program?

   - abort()
   - SIGABRT
   - gcore
   - gdb generate-core-file

   If you just want a program to terminate now and dump core, you can use the
   SIGABRT signal. This signal can be send from another process using kill. Or it
   can be send by the process itself using, kill, raise, or abort. If you want a
   core dump without killing the process, things start getting more tricky. You
   can create a child process by using the fork system call, and let the child
   dump core. The init program actually does this in its signal handlers. From the
   outside, the kernel offers no simple way to get a core dump from a process
   without killing it. But gdb have a gcore command that will do the hard work. On
   Fedora Core you can also call gcore from your shell (in which case it is just a
   script that call gdb).
** nohup,SIGHUP,daemon关系
   - SIGHUP 当终端关闭时，它会向本进程组发送SIGHUP信号,该终端进程组的所有进程都会收到
   - nohup foo.sh 可以使foo.sh忽略SIGHUP信号
   - daemon
     一个进程要成为daemon需要：
     后台运行(通过fork)
     setsid() ;;退出原来的进程组(一般是终端)，以免接收到发往原进程组的信号(如SIGHUP)
     chdir("/")
     umask(0)
     一般还要关闭各个fd

** brk 与 sbrk								:ATTACH:
   :PROPERTIES:
   :Attachments: brk.c
   :ID:       trz9m8l0xfe0@sunway-lab.bupt.edu.cn
   :END:

** 读取elf信息的几个程序
   - size
   - readelf
   - ldd
   - objdump
   - strings
   - nm
** pmap看进程的内存映射
   或cat /proc/<pid>/maps
** 关于linux共享库						 :SharedLibrary:
  - ldconfig,ld.so与ld.so.cache
  - /usr/lib
  - LD_LIBRARY_PATH
  - LD_DEBUG
  - gcc \-L选项
  - ld -rpath选项

ld.so.cache只在运行时起作用
LD_LIBRARY_PATH只在运行时起作用
\/usr/lib在编译时和运行时都起作用
gcc \-L只在编译时起作用.
ld的 -rpath 在运行时起作用,告诉加载器到哪去找so. gcc以前也有这个选项,现在这个选项只在ld中,在gcc中可以这样指定这个rpath选项:
    gcc ... -Wl,rpath,/home/sunway

ld.so的作用:
在程序运行之前载入共享库,库查找的顺序是
1. LD_LIBRARY_PATH
2. ld.so.cache
3. /usr/lib

ldconfig \-v 可以显示更新cache的过程,ldconfig \-p可以查看cache的内容

综上:
  - 如果要在编译时使用某个库,可以用gcc \-L选项,或者把so复制到/usr/lib
  - 如果要在运行时使用某个库,可以设定LD_LIBRARY_PATH,或复制到ld.so.conf指定的目录并ldconfig,或复制到/usr/lib,或使用ld的 -rpath 选项
** valgrind
** distcc
** switch..case中变量的声明
#+BEGIN_EXAMPLE
   switch (b) {
   int a=0;
   case 1:
      int c=0;
      break;
   case 2:
      {
         int d=0;
      }
   }
#+END_EXAMPLE

int a是合法的,int c是非法的,int d是合法的

因为case 1并不一定被执行,而整个switch都属于一个作用域,编译器如何知道case 1能不能
被执行?如果不能,引用了c的语句(包括整个switch结构)怎么办?编译器从逻辑上禁止了在
case里声明变量.

int a是合法的,因为它在所有case之间,肯定会被执行.

int d是合法的,因为它属于单独的作用域.

这个问题关键一点是:整个switch使用同一个作用域,而每个case不一定被执行.

** DONE 数组与指针 ( array vs. pointer)
   CLOSED: [2011-04-08 Fri 15:06]
   - State "DONE"       [2011-04-08 Fri 15:06]
   数组与指针的混淆,最根本的原因是这种语法糖:
#+BEGIN_EXAMPLE
   char * pointer=array;
#+END_EXAMPLE

   本来,做为C/C++中的一种基本类型, int a[10] 和 int x; 并没有明显的区别, a, x都是变量,都有地址和值, 但由于数组的值的结构与指针的相似性,C提供了上面提到的语法糖,即:
   要使用数组变量的地址时,不必再加&符号,而可以直接使用数组名字 (访问数组的值时使用a[0]这种语法,所以不会混淆).

   数组名即地址,所以给a再赋值是违法的,正如 &x 不能再赋值一样.

   另外,为何数组不能做为函数返回值:
   函数返回值有两种方式:
     - 通过寄存器直接返回,如各种基本类型和指针类型
     - 通过named-return-value返回,如结构体
   或函数可以返回,只能通过第二种情况, 但是, 由于数组大小不定,若 caller 和 callee 的数组长度不同,如何处理?
** c的参数与返回值
   除了数组,任何类型都可以做为函数的返回值,包括结构等
   - 对于<=32位的返回值,如int,short,float,指针等,直接通过%eax返回
   - 对于64位的返回值,通常通过两个寄存器返回,如%eax,%edx
   - 对于更大的结构体,通常在函数调用时把返回值的地址作为第一个参数,函数直接给这个指针赋值

   任何类型都可做为函数的参数,但数组有些例外:数组做为参数时弱化为指针
** sync,fsync,fflush的区别
   - sync Force changed blocks to disk, update the super block.
   - fsync(int fd),和sync作用类似，不过只针对一个fd
   - fflush(FILE *) 刷新FILE *的缓存。例如：
   printf("test");
   fflush(stdout);
   sleep(2);
   在sleep前test因为fflush而被显示出来。
   缓存（包括全缓存，行缓存）是标准IO库的概念，fflush只对标准IO起作用。
   对于write(STDOUT_FILENO,"test",5),没有缓存的概念，test直接被显示出来。

   综上：
   sync,fsync对应的是OS的磁盘cache,fflush对应的是标准IO库的缓存。标准IO的缓存在磁盘cache之上，当
   用fflush()刷新一个流时，可能仍需要用sync可能保证内容被写到磁盘上。
** Non-blocking synchronization (Lock-free)				:ATTACH:
   :PROPERTIES:
      :Attachments: L31_LockFree.pdf Lock-Free-1.pdf cas.c
      :ID:       n7ga2qc0xfe0@sunway-lab.bupt.edu.cn
      :END:
   http://en.wikipedia.org/wiki/Non-blocking_synchronization
   With few exceptions, non-blocking algorithms use atomic read-modify-write
   primitives that the hardware must provide, the most notable of which is
   compare and swap (CAS). Ultimately, all synchronizing algorithms must use
   these;
*** Live-lock
    http://en.wikipedia.org/wiki/Livelock#Livelock

    A livelock is similar to a deadlock, except that the states of the
    processes involved in the livelock constantly change with regard to one
    another, none progressing. [1] Livelock is a special case of resource
    starvation; the general definition only states that a specific process is
    not progressing. [2]

    A real-world example of livelock occurs when two people meet in a narrow
    corridor, and each tries to be polite by moving aside to let the other
    pass, but they end up swaying from side to side without making any progress
    because they both repeatedly move the same way at the same time.  RCU

*** CAS
    http://en.wikipedia.org/wiki/Compare-and-swap
    In computer science, the compare-and-swap CPU instruction ("CAS") (or the
    Compare & Exchange - CMPXCHG instruction in the x86 and Itanium
    architectures) is a special instruction that atomically compares the contents
    of a memory location to a given value and, if they are the same, modifies the
    contents of that memory location to a given new value.

    CAS是所有Lock-free算法(数据结构)的基础

    一个用c++表示的cas算法如下:
    bool CAS(int* addr, int expected, int fresh) {
       	if (*addr != expected) return false;
       	*addr = fresh;
       	return true;
    }
    实际上cas都是用的CPU支持的单条汇编指令,如CMPXCHG
    用CAS实现lock-free算法一般如下实现:
    要修改Data时:
    Data * p_;
    Data * pOld, * pNew = new Data;
    do {
       	pOld = p_;
       	*pNew=*p_;
       	//在这里修改 *pNew
       	//另:CAS的参数都是指针,因为CAS对应的汇编指令参数是处理内存地址
    } while (!CAS(&p_, pOld, pNew));

    CAS的例子见附件cas.c
    注意:当使用-O2编译cas.c时,volatile关键字是必须的,参考[[*volatile%20keyword%20in%20C][volatile]]

*** Implementations of Lock-free data structures
**** 由于结构简单或功能受限不需要CAS的Lock-free数据结构
***** RCU
      http://en.wikipedia.org/wiki/Read-copy-update
      http://www-128.ibm.com/developerworks/cn/linux/l-rcu/
***** Circular buffer
      http://en.wikipedia.org/wiki/Circular_buffer
**** Lock-free stack,list,etco
     见附件 L32_lockfree.pdf

     例:lock-free stack的push操作

#+BEGIN_EXAMPLE
     void push(int t) {
          Node* node = new Node(t);
          do {
              node->next = head;
	  } while (!cas(&head, node->next, node));
      }
#+END_EXAMPLE
** DONE gcc __attribute__ syntax
   CLOSED: [2008-09-21 日 14:08]
   - State "DONE"       [2008-09-21 日 14:08]
     http://www.ohse.de/uwe/articles/gcc-attributes.html
** DONE what is weak reference
   CLOSED: [2008-10-13 一 22:34]
   - State "DONE"       [2008-10-13 一 22:34]
   http://mindtrove.info/articles/python-weak-references/
   http://en.wikipedia.org/wiki/Weak_reference
** DONE zero copy and Scatter/Gather IO
   CLOSED: [2009-01-05 一 14:19]
   - State "DONE"       [2009-01-05 一 14:19]
     http://www.linuxjournal.com/article/6345
     http://en.wikipedia.org/wiki/Zero-copy
     http://www.ibm.com/developerworks/library/j-zerocopy/index.html

#+BEGIN_EXAMPLE
   normal read/write copy
     |
     +->mmap
       	 |
         +->sendfile syscall
	      |
	      +-->sendfile together with Gather/Scatter IO (Zero copy)
#+END_EXAMPLE

** DONE -shared与-fPIC						 :SharedLibrary:
   CLOSED: [2008-12-29 一 09:10]
   - State "DONE"       [2008-12-29 一 09:10]
   http://bottomupcs.sourceforge.net/csbu/x3809.htm

   对于共享库,代码本身就是位置无关的,但共享库中用到的全局数据是位置相关的,由于共享库的地址在运行时才能确定,所以共享库中要访问的全局数据的地址
   都是不确定的,全局数据的地址在运行时由loader确定. 比如:
#+BEGIN_EXAMPLE
 lib.c:
   extern int a;
   void fun() {
       a=1;
   }
   main.c:
   int a;
   main () {
       fun();
   }
#+END_EXAMPLE

   gcc -shared -fPIC (or not)  lib.c -o lib.so
   lib.so中全局数据a的地址编译时不确定,运行后a的地址由Loader添加到lib.so在内存的映像中
   至于loader如何将a的地址添加到lib.so中,可能有两种方法:
   1. a在a.out的.bss中,地址为A,loader载入lib.so后负责把lib.so .text段中所有对a的引用的地址改写成A
      这种方法需要改写lib.so的 .text段,导致lib.so的.text段无法被共享
      编译时不指定-fPIC时就是这种情况
   2. lib.so中对a的引用的地址是"GOT基址+偏移量"的形式,GOT即global offset table,loader载入lib.so后会把
      a的地址加入GOT表中对应于a的地方. 显示这种方法不需要修改lib.so的.text段,所以.text段可能被共享
      编译时指定-fPIC时是这种情况
      每个共享库都有一个GOT表
      GOT基址通常保存在一个寄存器中,如ebx,每次函数共享库的函数时,都会重设ebx使其指向相应的so的GOT基址
      lib.so每次访问a时真要先查GOT表才能确定a的地址,即多一次内存访问
      GOT紧跟在lib.so的.text之后,lib.so的.text编译时确定,所以lib.so被载入内存后,GOT基址也是确定的
      如图:
      lib.so载入前:
#+BEGIN_EXAMPLE
      	   +---------+
	   | lib.so  |
	   | .text段 o-----a的地址为(GOT+OFFSET(a)),例如 OFFSET(a)=1
	   +---------+
	   | GOT     |
	   +---------+
	   | .data   |
	   | .bss    |
	   +---------+
#+END_EXAMPLE
      lib.so载入后:
#+BEGIN_EXAMPLE
                          /----lib.so被载入到0xXXX
       	   +---------+----
	   | lib.so  |
       	   | .text段 |----a的地址没变,还是(GOT+OFFSET(a)),但GOT的地址已经确定为len of .text+0xXXX
	   +---------+	      而且GOT的第OFFSET(a)个表项的值已经被loader改写为a的地址
	   | GOT     |
	   +---------+
	   | .data   |
	   | .bss    |
	   +---------+
#+END_EXAMPLE

      -fPIC指将库编译成"位置无关代码",这里的"位置"并不是指lib.so被映射到线性地址空间的位置,而是指lib.so中引用的
      全局数据的地址是位置无关的

      另外,
      main.c:
      extern int a;
      main() {
          a=1;
      }
      lib.c:
      int a;
      如果main中要使用lib.so中定义的全局变量,链接后a还是在a.out的.bss段,而不是在lib.so的.bss段,否则如果另一个lib2.so
      要使用a还要去lib.so中找lib.so?

      另:strace的结果也显示出不加-fPIC时lib.so无法被共享
      没加-fPIC时,strace ./a.out的部分结果:
#+BEGIN_EXAMPLE
      ...
      open("./libmy.so", O_RDONLY)            = 3
      read(3,"\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\3\0\0004\0\0\0\300"..., 512) = 512
      fstat64(3, {st_mode=S_IFREG|0755, st_size=48065, ...}) = 0
      getcwd("/home/sunway"..., 128)          = 13
      mmap2(NULL, 44424, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) =0xb7efe000
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      mmap2(0xb7eff000, 40960, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1) = 0xb7eff000
      ..
      mprotect(0xb7efe000, 4096, PROT_READ|PROT_WRITE) = 0
      mprotect(0xb7efe000, 4096, PROT_READ|PROT_EXEC) = 0
      ..
#+END_EXAMPLE

      加了-fPIC:
#+BEGIN_EXAMPLE
      ..
      open("./libmy.so", O_RDONLY)            = 3
      read(3,"\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\3\0\0004\0\0\0\240"..., 512)= 512
      fstat64(3, {st_mode=S_IFREG|0755, st_size=48072, ...}) = 0
      getcwd("/home/sunway"..., 128)          = 13
      mmap2(NULL, 44392, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) =0xb7f22000
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      mmap2(0xb7f23000, 40960, PROT_READ|PROT_WRITE,
      MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1) = 0xb7f23000
      ..
      mprotect(0xb7f07000, 4096, PROT_READ)   = 0
      munmap(0xb7f0d000, 84037)               = 0
      ..
#+END_EXAMPLE

      唯一的区别就是末尾的mprotect(0xb7efe000, 4096, PROT_READ|PROT_WRITE) = 0.
      没加-fPIC时,libmy.so的.text用MAP_PRIVATE参数map进来,但后面又用mprotect设为可写..
      然后dynamic loader会修改这个内存区(以便确定全局数据的真实地址),然后就copy on
      write了

      静态库->硬盘占的多,内存占的多,加载快,运行快
      不加fPIC的动态库->硬盘占的不多,内存占的多,加载慢,运行快
      加了fPIC的动态库->硬盘占的不多,内存占的不多,加载慢,运行慢

* Kernel							    :ARCHIVE:
#+CATEGORY:Kernel
** 信号为什么会打断系统调用
   假设A阻塞在read()系统调用上,阻塞在read上,是指A通过system gate进入内核后,执行了以下语句:
       set_task_state(TASK_INTERRUPTABLE);
       add task to waitqueue of the fd
       schedule()
   当B给A发信号时,B的操作是修改A的sig,表示有信号发生.但B不能直接执行A的sig handler. 因为A的sig handler必须在A的上下文执行,
   所以sig handler只会在A从内核态转回用户态的时候发生. 为此,B会修改A的stat为TASK_RUNNING,借以唤醒A.

   当A被唤醒时,就从系统调用返回了,所以系统调用就被打断了.返回到用户态之前,会调用sig handler. 如果相应信号的sigaction flag设置了
   重启系统调用的标识,则处理完sig handler以后不会返回到用户态,而是重新启动被打断的系统调用.

   总之,系统调用会被信号打断,是因为sig handler必须在原进程的上下文执行,而sig handler又只有在原进程返回到用户态之前才会被调用.

** 组相联cache								:ATTACH:
    :PROPERTIES:
    :Attachments: cache.png
    :ID:       8dih1b81uoe0@sunway-lab.bupt.edu.cn
    :END:
    AMD64 的 cache 是这样的：

    Cache 的结构就像一个矩阵。
    行为 set , 列为 way
    一个 4 way 的 cache 组织中，一个 set 有 4 个 cache line 组成
    每个 cache line 由 3 个部分组成： tag 域、data 域 和 other information 域
    每个 cache line 为 64 bytes。

    虚拟地址经过 MMU 处理后的物理地址，为分为三个部分。

    index 域：得出 cache 的 set 值，如上图所求，从 index 得出 set 为 2

    tag 域：物理地址的 tag 分别与 set 中的每个 way 的 cache line 的 tag 进行比较，
    直到匹配（hit）。在每个 way 进行搜索是通过一个 n:1 的乘法器得出每个 way 的地点。

    offset 域：当 hit 时，通过 offset 域索引出 cache line 中 data 域的具体数据。
    相联存储器 http://baike.baidu.com/view/93241.htm
** spinlock
   form ldd

   5.5. Spinlocks Spinlocks are, by their nature, intended for use on
multiprocessor systems, although a uniprocessor workstation running a preemptive
kernel behaves like SMP, as far as concurrency is concerned. If a nonpreemptive
uniprocessor system ever went into a spin on a lock, it would spin forever; no
other thread would ever be able to obtain the CPU to release the lock. For this
reason, spinlock operations on uniprocessor systems without preemption enabled
are optimized to do nothing, with the exception of the ones that change the IRQ
masking status. Because of preemption, even if you never expect your code to run
on an SMP system, you still need to implement proper locking.

** 汇编(asm)指令的原子性 (atomic) ulk p186
   - Assembly language instructions that make zero or one aligned memory access are
     atomic.[2], e.g. movl mem,%eax, where mem is align to 4 bytes

          [2] A data item is aligned in memory when its address is a
          multiple of its size in bytes. For instance, the address of an
          aligned short integer must be a multiple of two, while the
          address of an aligned integer must be a multiple of four.
          Generally speaking, a unaligned memory access is not
          atomic.
  - Read-modify-write assembly language instructions (such as inc or dec) that read
    data from memory, update it, and write the updated value back to memory are
    atomic if no other processor has taken the memory bus after the read and before the
    write. Memory bus stealing never happens in a uniprocessor system.

  - Read-modify-write assembly language instructions whose opcode is prefixed by the
    lock byte (0xf0) are atomic even on a multiprocessor system. When the control
    unit detects the prefix, it "locks" the memory bus until the instruction is finished.
    Therefore, other processors cannot access the memory location while the locked
    instruction is being executed.

  - Assembly language instructions (whose opcode is prefixed by a rep byte (0xf2,
    0xf3), which forces the control unit to repeat the same instruction several times)
    are not atomic. The control unit checks for pending interrupts before executing a
    new iteration.

    - 只有一次访问对齐的地址的指令如movl mem,%eax是原子的,up,mp
    - lock前缀的汇编指令都是原子的,up and mp
    - 大部分汇编指令在up都是原子的,除了rep前缀的
    破坏原子性的两个原因:mp和中断,mp下可以通过lock前缀让指令具有原子性,而在up下,中断都是在每条汇编指令执行后执行的,所以
    up下大部分汇编指令都是原子的

** networking

   softnet_data主要用来和softirq打交道,如netif_rx_action,netif_tx_action

   ingress
   - interrupt
     - netif_rx
       - netif_rx_action
	 - netif_receive
   egress
   - dev_queue_xmit
     - netif_tx_action
       - hard_start_xmit
** 关于线程的user mode stack
   每个线程都有一个单独的user mode stack,这个stack的地址是clone时作为参数指定的,父进程保证给每个子线程分配一个新的stack
   因为clone使用了CLONE_VM flag生成线程,所以各个线程的虚地址空间是一样的,但又要求每个线程有不同的栈...实际上,线程的地址空间
   包含多个栈,每个栈单独给某一个线程使用,如图:
   [TEXT] [DATA] [HEAP] [LIB] [STACK FOR thread1] [STACK FOR thread2] ....
   既然各个线程的栈实际上在同一个虚地址空间,所以通过更改线程的esp,ebp可以"共享"其他线程的栈...

   一个进程创建的线程的用户栈在同一个地址空间里,这个问题的直接意义是:栈大小决定了单个进程能创建的线程个数!
   比如默认情况下栈大小是8M,则在3G虚地址空间里最多能容纳3G/8M=384个线程,若想增加线程个数,只能ulimit -s缩小栈大小

#+BEGIN_EXAMPLE lang:c

#include <pthread.h>
int * pesp;
int * pebp;
void callBack1 (void * p) {
    /* int a=1; */
    /* printf ("%p\n",&a); */
    int retval,retval2;
    int a=1000;
    __asm__ (
	"movl %%esp,%0\n\t"  \
	"movl %%ebp,%1\n\t"  \
	:"=m"(retval),"=m"(retval2)
	);
    *pesp=retval;
    *pebp=retval2;
    sleep (100);
}

void callBack2 (void * p) {
    int a;
    __asm__ (
	"movl %0,%%esp\n\t"			\
	"movl %1,%%ebp\n\t"			\
	:					\
	:"m"(*pesp),"m"(*pebp)
	);
    printf ("%d\n",a);

}

int
main(int argc, char *argv[]) {
    pesp=malloc (sizeof(int));
    pebp=malloc (sizeof(int));
    pthread_t p1,p2;
    pthread_create (&p1,NULL,callBack1,NULL);
    sleep (2);
    pthread_create (&p2,NULL,callBack2,NULL);
    pthread_join (p1,NULL);
    pthread_join (p2,NULL);
    return 0;
    }
#+END_EXAMPLE

** vfs,fs,page cache(disk cache)与io scheduler的关系			:ATTACH:
   :PROPERTIES:
   :Attachments: vfs.png
   :ID:       j2udxzl0efe0@sunway-lab.bupt.edu.cn
   :END:
   page cache位于vfs与fs之间,而不是位于generic block层,因为page cache中是以page为单位的,一个Page可以包含多个block,
   所以不能用block号为标识,实际上它是以file+offset为标识的,file是vfs的概念,所以只能放在vfs层之下
** clone,fork,vfork							:ATTACH:
   :PROPERTIES:
   :Attachments: clone.c
   :ID:       3fuhk9o0hfe0@sunway-lab.bupt.edu.cn
   :END:

** kernel stack与task_struct
   there is no "kernel stack space", each process gets an 8K (4K on some
   systems, if you choose that option) kernel stack space, and the kernel uses
   the current processes space.

   ok, it goes like this: each process has an associated task_struct, which is
   used for process managament. to allocate this struct, the kernel allocates 2
   pages (normally, but as mentioned, it can be only 1 page), which amounts to 8k,
   and places the task_struct at the bottom.  each time the host goes from user
   space to kernel space (interrupt, system call , etc...), these 2 pages are used
   for the kernel stack.  this is ok, since the stack begins at the top of the
   pages, and grows downwards (however, try a bit of recursion. you'll get funky
   effects...).

   so, your module does not have a stack of it's own, but rather uses whats
   available at the time of it's execution - either the 2 pages as i mentioned, or
   the stack of a kernel thread which called it.

   在内核中kernel stack的样子大致是:

   -------------------8k stack start
   kernel stack for the curent process
   .....
   .....
   thread_info struct(which contains task_struct)
   -------------------0k stack end   <-current宏, esp掩掉最后12位即可得到stack end的地址

   测试: esp与task_struct的关系
   test.c:
   int init_module(void) {
       int retval;
       __asm__ (
           "movl %%esp,%0\n\t"  \
	   :"=m"(retval)
       );
       struct thread_info * tmp=(struct thread_info *)(tmp&0xffffe000); //kernel stack大小为8k
       printk (KERN_ALERT "curr is %p\n",tmp->task);
   }
   ..
   然后kdb在printk设断点,insmod test.ko,发现kdb显示的current和打印出来的current是一样的:

** syscall(系统调用)
   http://www.kerneltravel.net/journal/iv/syscall.htm
   http://www.clinux.org/node/27837
   一个系统调用经历了 用户态->内核态->用户态 的过程
   1 用户态
     调用系统调用的三种方法:
    - 使用libc提供的库函数,如read(int fd,char * buff,int size)
    - 使用libc提供的库函数 syscall(int sys_num,...)
    - 使用嵌入汇编,如
#+BEGIN_EXAMPLE
        __asm__ (
	"int $0x80\n\t"				\
	:"=a"(retval)				\
	:"0"(325),				\
	"b"(23)				\
	);
#+END_EXAMPLE
      调用325号系统调用,并传入一个参数23

      其中read(int fd,char * buffer,int size) 等价于 syscall (3,...) # 内核中sys_read号为3
      这三种方法是等价的,它们所做的是:
      - 将系统调用号存入%eax
      - 将其他参数依次存入%ebx,%ecx...
      - 使用 int $0x80陷入内核

   2 内核态
     int $0x80后进入内核态,这期间所做的是:
     - 程序跳转到entry_32.S中的ENTRY(system_call)处,调用SAVE_ALL保存进程的上下文,并把%ebx,%ecx..中存的系统调用参数push到内核栈,以便系统调用
     服务函数能够使用这个参数
     - 检查%eax中的调用号是否超出系统已注册的调用号数目
     - syscall_call:
         call *sys_call_table(,%eax,4)   #sys_call_table定义在syscall_table_32.S,定义着不能的系统调用号对应的函数
	 movl %eax,PT_EAX(%esp)		# 保存返回值
     - 恢复SAVE_ALL保存的上下文
   3 用户态
     从内核态返回后%eax中保存着返回值,库函数将%eax的值返回到调用者后,整个系统调用过程结束
** DONE linux timer
   CLOSED: [2008-11-05 三 10:48]
   - State "DONE"       [2008-11-05 三 10:48]
   - State "WAIT"       [2008-11-04 二 20:48]
     一般2.6 linux的HZ为1000(TICK为1ms),即PIT或HPET每1ms向IRQ0中断一次timer_interrupt
     timer_interrupt所做的工作主要有:
       - 响应中断等
       - 其他的大部分工作在TIMER SOFTIRQ执行,包括:
	 + 检查内核的timer是否有到期的,有的话执行那个timer_list注册的函数,比如sleep,usleep,nanosleep系统调用
	   注册的函数一般是唤醒在timer_list上睡眠的进程,alarm,setitimer系统调用注册的函数一般是向原来注册的进程
	   发送SIGALARM
	 + 通过某一个可用的高精度时钟(按HPET,ACPI timer,TSC,PIT的顺序)的计数器,判断是否有丢失的IRQ0中断(因为内核在
	   执行某个ISR时一般会关中断,导致时钟中断丢失),将丢失的中断数加到jiffies里
	 + 更新xtime变量.xtime变量是time,gettimeofday,adjtime,clock_..这些获取/设置系统时间的系统调用的依据之一
	   (另一个依据是高精度计时器的counter,gettimeofday返回的是xtime+counter自上一次时钟中断的增量,所以
	   虽然xtime只精确到毫秒,gettimeofday可以精确到微秒)
	 + 更新内核中与时间相关的系统状态,如进程运行时间,system load等

	   可见,所有在timer函数和clock函数都依赖于时钟中断,而linux的时钟中断最高精度到1ms,所以nanosleep只能到微秒.
	   但gettimeofday被高精度计时器(HPET,TSC..)修正,所以可以精确到微秒

     - timer系统调用
       - setitimer
	 - alarm
       - select & poll
       - sleep
       - usleep
       - nanosleep
       - timerfd_...
       - posix's timer_... functions
     - clock系统调用
       - time
       - gettimeofday
       - adjtime
       - posix's clock_... functions

** DONE linux内存管理
   CLOSED: [2008-11-11 二 09:46]
   - State "DONE"       [2008-11-11 二 09:46]
   - State "WAIT"       [2008-11-06 四 20:59]
   - zone的概念
     linux将物理内存分成三个zone:
     - ZONE_DMA
       对应于0-16M这一段物理内存. 有些ISA设备有DMA操作,DMA直接使用物理地址,且只能使用0-16M这一段物理地址. 所以将这一段
       物理内存划为ZONE_DMA,除了DMA操作,其他的情况一般不会分配ZONE_DMA的内存,虽然ZONE_DMA的内存也可能被分配给其他任务
     - ZONE_NORMAL
       16M-896M这一段物理内存,这一段内存可能被内核直接寻址(线性地址=物理地址+3G),而不用通过页表进行. 内核本身需要动态分配
       的内存,一般从ZONE_NORMAL分配,因为访问ZONE_NORMAL内在的效率比ZONE_HIGHMEM的高,比如内核自己分配内存使用的slab分配器要
       求不能从ZONE_HIGHMEM分配page frame
     - ZONE_HIGHMEM
       896M以上的物理内存.内核为了使用ZONE_HIGHMEM,特意把线性地址空间的3896M-4G这128M的线性地址保留,以便用来映射ZONE_HIGHMEM
       的物理内存,ZONE_HIGHMEM一般给page cache和用户进程使用
   - buddy系统
     buddy系统解决external fragment问题,内核和用户进程请求内存最终都要通过buddy系统
     每一个zone都有自己的buddy系统
     - alloc_pages (gfp_mask,order),__get_free_pages (gfp_mask,order)
       根据gfp_mask的不同,__get_free_pages从不同的zone上分配2^order个物理上连续的page frame,并返回首地址,注意首地址是线性地址.
       若从ZONE_NORMAL,ZONE_DMA分配,则返回的地址即是物理地址+3G, order的最大值是10,所以buddy系统一次最多能2^10*4k=4m连续内存
       若从ZONE_HIGHMEM分配,返回的地址是通过page_address(page)得到,page_address所做的即是将ZONE_HIGHMEM的物理内存映射到3896M-4G
       的线性地址空间上,并返回映射的线性地址,这是内核访问ZONE_HIGHMEM的一种方法,称为 fixed mapping
     - buddy系统根据gfp_mask决定从哪个zone分配内存,比如:
       - 若__GFP_HIGHMEM set,则内核优先从ZONE_HIGH分配
       - 若__GFP_DMA set,内核必须从ZONE_DMA分配
       - 若__GFP_HIGHMEM not set,内核只能从ZONE_DMA,ZONE_NORMAL分配
   - slab分配器
     slab解决的是internal fragment问题,slab只能给内核自己分配内存,且不能使用ZONE_HIGHMEM
     slab系统包含多个kmem_cache,kmem_cache分为两种:
	  1. generic cache
	     这些cache是系统启动时预分配的,大小有13种,分别为32,64....131072 (128K),这类cache主要是给kmalloc使用的,当kmalloc分配n字节的内存时
	     ,它会找到与大小与n接近的generic cache,如n=65时,它会找到大小为128的那一个kmem_cache,从这个cache里分配一个128字节的对象.所以
	     generic cache最多会造成 50% 的internal fragment. 而且由于generic cache最大的大小为128K,所以kmalloc最多能一种分配128K
	  2. specific cache
	     specific cache为内核根据自己的需要动态创建的. cat /proc/slabinfo 可以发现各种大小的specific cache,它们大小并不需要是2^n
     一个kmem_cache分配多个slab,并根据slab时是否有空闲的object将这些slab分配到不同的链表上.
     每个slab管理一个或多个连续的page frame,可以包含多个object. slab可以看作是slab系统与buddy系统的接口,slab负责向buddy请求或释放page frame
     - kmalloc

   - vmalloc
     与slab一样,vmalloc也只是给内核自己使用,但它分配的内存不需要是物理连续的
     vmalloc分配的线性地址大约在3904M-4000M之间(剩下的到4G的线性地址留给fixed mapping),vmalloc也是调用buddy系统获得物理页,且它的__GFP_HIGHMEM set,所以vmalloc优先从ZONE_HIGHMEM
     分配page frame
     vmalloc与fixed mapping一样,可以映射ZONE_HIGHMEM的内存,但fixed mapping是基于简单的数组映射,它分配的page frame是连续的,
     vmalloc使用了内核页表来映射,所以它分配的page frame是不连续的.

* Protocol
#+CATEGORY:Protocol
** XMPP
** OMA
** SYNCML
** TCP
*** TODO [#B] TCP 超时与长连接
*** socket OOB (Out of Band) and TCP urgent flag
*** 慢启动
** HTTP
*** TODO [#B] Percent Encoding (UrlEncode)
    - Note taken on [2011-02-14 Mon 15:28] \\
      refer to `Percent Encoding @ Wikipedia` for details
*** DONE HTTP Cookie
    CLOSED: [2011-03-11 Fri 13:40]
    - State "DONE"       [2011-03-11 Fri 13:40]
    :PROPERTIES:
    :CUSTOM_ID: @HTTP_Cookie
    :END:
    refer HTTP_cookie @ wikipedia
    The term `cookie` was derived from `magic cookie`, which is a package a program receive and send back again unchanged. e.g. cookie in binder_node
    Terminology:
      - Session cookie
	cookie without Expire data or Max-age is considered to be a `session` cookie, and will expire after user close the browser.
      - Persistent cookie
	cookie with Expire data or Max-age is considered to be `persistent`, and is stored in external storage.
	note that: browser will delete cookies expired, and browser receives a `Set-Cookie` with the expiration data in the past, browser will delete
	the cookie *right away*.
      - Secure cookie
	there cookies can only be used through HTTPS,
	e.g.
	`Set-Cookie: name=xxx; *Secure*`, the `Secure` property demonstrate that the cookie is Secure cookie
      - HttpOnly cookie
	javascript can't touch this cookie.
	e.g.
	`Set-Cookie: name=xxx; HttpOnly`
      - Third-party cookie
	Third-party cookie are cookies set by server to another domain.
	e.g.
	server in foo.com send a http response as:
	`Set-Cookie: name=xxx; Domain=.bar.com;`
	then the cookie is a third-party cookie.
	usage of Third-party cookie should be well considered for privacy.
      - Super cookie
      - Zombie cookie
*** Http pipeline
*** Http Push
**** BOSH
**** WebSocket
**** Comet
**** chunked encoding
* Regexp
** 贪婪 vs. 非贪婪
* Cypher
** BASE64
   使用64个 ascii (a-z, A-Z, 0-9,...) 进行编码, 每三个字节(24 bits)变换成四个 6 bits值, 每个6 bits 值对应一个 ascii , 结尾不足三个字节的编码后以 = 填充.
   BASE64 可以将二进制数据编码为可见的 ASCII, 但因为它三个字节会编码为四个, 且标准规定每编码多少个字节后要强制插入一个换行, 导致会浪费30%多的空间.
** symmetric encryption
*** AES
*** DES
** asymmetric encryption
*** RSA
*** DSA
** digest
*** SHA1
*** MD5
** 数字签名
** 数字证书
* Network
#+CATEGORY:Network
** FTP两种工作模式：主动模式（Active FTP）和被动模式（Passive FTP）

   在主动模式下，FTP客户端随机开启一个大于1024的端口N向服务器的21号端口发起连接，
   然后开放N+1号端口进行监听，并向服务器发出 PORT N+1命令。服务器接收到命令后，
   会用其本地的FTP数据端口（通常是20）来连接客户端指定的端口N+1，进行数据传输。

   客户端:
#+BEGIN_EXAMPLE
   +-------------- -+  	  send N+1/2 port to serv  +--------------+
   | control port N |----------------------------> | listening 21 |
   |   	       	    |  conn to cli's data port 	   |   	       	  |
   | data port N+1  |<---------------/-------------+ data port 20 |
   | data port N+2  | <--------------              |		  |
   | ...	    |				   |		  |
   |		    |				   |		  |
   +----------------+  	       	       	       	   +--------------+
#+END_EXAMPLE



   在被动模式下，FTP库户端随机开启一个大于1024的端口N向服务器的21号端口发起连
   接，同时会开启N+1号端口。然后向服务器发送PASV命令，通知服务器自己处于被动模式。
   服务器收到命令后，会开放一个大于1024的端口P进行监听，然后用PORT P命令通知客户
   端，自己的数据端口是P。客户端收到命令后，会通过N+1号端口连接服务器的端口P，然
   后在两个端口之间进行数据传输。

   客户端:
#+BEGIN_EXAMPLE
   +-------------- -+ port M to tell cli           +--------------+
   | control port N |<-----------------------------|  listening 21|
   |   	       	    |  	       	       	       	   |   	       	  |
   | data port N+1  | ---------------/------------>+ data port M  |
   | data port N+2  | --------------               |		  |
   | ...	    |				   |		  |
   |		    |				   |		  |
   +----------------+  	       	       	       	   +--------------+
#+END_EXAMPLE



   总的来说，主动模式的FTP是指服务器主动连接客户端的数据端口，被动模式的FTP是指
   服务器被动地等待客户端连接自己的数据端口。被动模式的FTP通常用在处于防火墙之后
   的FTP客户访问外界FTp服务器的情况，因为在这种情况下，防火墙通常配置为不允许外
   界访问防火墙之后主机，而只允许由防火墙之后的主机发起的连接请求通过。因此，在
   这种情况下不能使用主动模式的FTP传输，而被动模式的FTP可以良好的工作。

** various tunnel
*** ipip
*** sit
*** gre
*** vtun
*** openvpn
*** pptp
*** l2tp
** 在Debian如何根据网线连接状况来决定是否应该启动网络并进行相关的配置呢？ :net:dhcp:
   Debian中的网络配置信息是记录在/etc/network/interfaces中的，我们通过修改这个配
   置文件来决定一个网络设备时如何进行设置的，决定网络设备是设置成为静态IP地址还
   是动态IP地址。
   一般情况下我们设置了该设备为动态IP地址，但却常常会遇到这样的一些情况。在网线
   未连接或者网络无法访问的情况下动态IP地址的设置将会失败，且尝试获取动态IP地址
   的行为将会一直持续下去直到获得IP地址，或者用户中断它的执行，或者超时。默认
   Debian系统的行为只有前两种，而没有超时的设置。我们会有这样的需求，希望在网线
   未连接的情况下就不要启动动态IP地址设置的网络设备了，直到网线连接的时候再进行
   网络配置。
   我们可以修改/etc/network/interfaces配置文件，在配置文件中加入对网线连接状况进
   行判断的相关命令调用。interfaces的语法中对于每一个网络设备，都有4个参数pre-up、
   up、down、post-down，这四个参数分别代表了一个网络设备在启动前、启动时、停机时
   和停机后四个状态。这四个参数都可以指定调用一些命令来进行一些设备在这些状态的
   时候所需要进行的工作。因此我们可以在pre-up中一个设备的网线连接状况进行检查，
   如果检查到网线未连接，则可以取消掉启动设备的这个操作。
   因此我编写了一个脚本进行这个检查：

#+BEGIN_EXAMPLE
   #!/bin/bash
   #file /etc/network/if-pre-up.d/check_if
   IFMSG=$(dmesg | grep"$1\:" | tail -n1| grep " Link is Up")
   if [ -z "$IFMSG" ] then
   exit 1
   else
   exit 0
   fi
#+END_EXAMPLE

   同时修改/etc/network/interfaces文件为：

#+BEGIN_EXAMPLE
   iface eth0 inet dhcp
   pre-up sh /etc/network/if-pre-up.d/check_if $IFACE
#+END_EXAMPLE

   这样就可以保证在启动eth0之前检查网线是否连接好了。
   后来根据对gentoo的研究发现check_if脚本可以修改为：

#+BEGIN_EXAMPLE
   #!/bin/sh
   IFMSG=$(mii-tool $1 | grep "link ok")
   if [ -z "$IFMSG" ] ; then
   exit 1
   else
   exit 0
   fi
#+END_EXAMPLE

   为了保证系统在网线连接良好，但是dhcp服务无法访问的时候已经能正常启动，必须修
   改/etc/dhclient.conf配置文件。将以下内容：

#+BEGIN_EXAMPLE
   #timeout 60;
   #retry 60;
   修改为：
   timeout 10;
   retry 10;
#+END_EXAMPLE

   这样就可以设置10秒为dhcp超时时间。为了保证设备在网线重新插入的时候再次进行
   dhcp的操作，则需要安装软件包ifplugd软件包。
** dhclient.conf						      :net:dhcp:
#+BEGIN_EXAMPLE
   timeout 60;
   retry 60;
   reboot 10;
   select-timeout 5;
   initial-interval 2;
   reject 192.33.137.209; #拒绝这个dhcp server的回应

   interface "ep0" {
    send host-name "andare.fugue.com";
    send dhcp-client-identifier 1:0:a0:24:ab:fb:9c;
    send dhcp-lease-time 3600;
    supersede domain-name "fugue.com rc.vix.com home.vix.com";
    prepend domain-name-servers 127.0.0.1; #自定义的dns
    request subnet-mask, broadcast-address, time-offset, routers,
    domain-name, domain-name-servers, host-name;
    require subnet-mask, domain-name-servers;
    script "/etc/dhclient-script";
    media "media 10baseT/UTP", "media 10base2/BNC";
   }
#+END_EXAMPLE
** ssh端口转发(隧道) 						       :net:ssh:
-D [bind_address:]port

Specifies a local "dynamic" application-level port forwarding. This works by
allocating a socket to listen to port on the local side, optionally bound to the
specified bind_address. Whenever a connection is made to this port, the
connection is forwarded over the secure channel, and the application protocol is
then used to determine where to connect to from the remote machine. Currently
the SOCKS4 and SOCKS5 protocols are supported, and ssh will act as a SOCKS
server. Only root can forward privileged ports. Dynamic port forwardings can
also be specified in the configuration file.

ssh -D 9999 foo.com
然后在fx中把代理设为socks5: 127.0.0.1:9999就可以把foo.com做为浏览器的socks5代理了

** ssh反向隧道							       :net:ssh:
   与 -D 选项相反, -R选项在远端主机上打开一个tcp监听端口A,并与本机的一个端口B建立
   一个反向隧道,对远端主机A端口的访问被转发到本机的B端口.
   例如:

   本机A: ssh -R 10000:localhost:21  far@far.com
   主机B: lftp far@far.com 10000 会连接到主机A的ftp服务器

   ssh反向隧道可以用于:
   本机位于NAT,防火墙之后

** ssh x11 forwarding						       :net:ssh:

#+BEGIN_EXAMPLE
|--------------------------+--------|
| server                   | client |
|--------------------------+--------|
| vim /etc/ssh/sshd_config | ssh -Y |
| X11Forwarding yes        |        |
|--------------------------+--------|
#+END_EXAMPLE

** nc									   :net:
nc - TCP/IP swiss army knife
nc可以用来创建任一TCP/UDP连接
- 选项：
  - p 指定端口
  - s 指定源地址
  - u 使用udp,默认使用tcp
  - w 读写和连接的超时(发送文件时很管用,因为文件读完后,EOF并不能使nc发送端关闭连接，使nc服务器端一直不返回)
  - l nc做为服务器模式监听,和 \-p 配合使用
- 使用：
  - 用nc传送文件：
    接收端： nc -l -p 1234 > dest.file
    发送端 :   cat source.file|nc -w 2 host:1234
  - 用nc测试tcp或udp服务器
    nc [-p port -s source -u] server port
    nc -l -p port [-u]
- 与telnet的比较：
  telnet也可以做为客户端测试网络程序，但：
  - telnet客户端不能指定端口，源地址，发送或接收到EOF并终止连接，而且只能使用TCP
  - telnet不能用来传送任意二进制数据，因为有些字符被解释为telnet的命令或选项，如^]
  - telnet命令不能做为服务器端,而 nc \-l 可以做为服务器
** scp&sftp							       :net:ssh:
scp很像cp,sftp很像lftp
  - scp user@host:/path/source.file dest.file
  - sftp user@host:/path
  - scp source.file user@host:/pathto/dest.file

** openvpn							       :net:vpn:
最近玩的一个东西-openvpn

在大运村想和同学打魔兽,想了一下,好像有几种选择:
   1. lan game,但因为我们都用的adsl,没法直接用lan game来玩
   2. hf,vs 因为我用的linux,用不了
   3. lancraft,同样因为用的linux,也用不了
   4. bn,在公网好像没有能连上的bn服务器
   5. 用vpn,然后在lan game里玩

要想用lan game来玩魔兽,要求两个条件:(A建立游戏,B要加入A的游戏)
   1. A建立游戏时会向局域网广播,udp源端口是6112,B要能收到这个广播才会在魔兽的lan game里看到A建的游戏
   2. 看到A建的游戏后,B双击进入游戏会建立一个tcp连接,端口也是6112

现在最大的问题是A建立游戏时广播不会被B收到,利用vpn可以解决这个问题. 但VPN也有许多
种,像pptp,l2tp,ipsec等,这些都是内核中实现的技术,还有一种叫openvpn,是纯用户空间的
vpn技术. 我先试了试pptp,设A运行linux,安装pptpd,C是同一个宿舍的另一台机器,C用
windows的拨号连接直接可以连接到linux上,但因为pptp建立的是一个点对点的连接,怎么让
A上的广播也通过这个接口发出去让C也收到? 因为A上向255.255.255.255广播时,究竟从
eth0还是eth1出去并不确定,和系统有关,bsd好像规定广播只对系统启动时第一个up的支持广
播的接口(见tcp/ip详解或unix网络编程,记不清了). 反正我的系统上对255.255.255.255的
广播都是从eth0出去,为了让广播也从vpn那个接口出去,可以用一个叫bcrelay的程序,这个是
随pptpd一块发布的,可以把到一个接口的广播都转发到另一个接口上. 问题到此似乎解决了,但
有一个很关键的问题,A和B都通过ADSL上网,而且都使用了宽带路由器,所以A B只有一个
192.168的私有地址,要想让B用拨号连接到A的pptpd,必须在A所在的宽带路由器上设NAT,但
vpn的nat穿越现在还有很多问题,pptp的情况类似于ftp,也就是说pptp连接建立的过程中会用
到别的随机端口,除非路由器的nat支持pptp-contrack,否则无法配置路由器的nat让B能连上
A的pptpd,而A用的路由器恰好不支持,结果A无法连上路由器之后的A的pptpd 正在绝望时我发
现了openvpn: openvpn是纯用户空间的vpn,只需要一个udp端口(或tcp端口,可以配置),内部
用ssl,绝对安全,而且跨平台. 因为openvpn只使用一个udp端口,所以穿跨nat没有问题.

用openvpn的大体步骤:
   1. A写openvpn的server.conf配置,里面主要写接口的类型,分配给B的地址范围,server证
书的路径. 接口类型里指定tap类型,B连接到A时生成的接口tap0可以被桥接到A本地的eth0,
形成一个局域网server证书是A运行openvpn自带的一些脚本得到的,B可以通过它识别server
   2. A用openvpn自带的脚本得到几个不同的client的证书,然后把它发给不同的client,比
如B,C
   3. B写vpn的client.conf配置,主要是指定从A收到的证书的路径和服务器的地址.

然后: A用openvpn建立一个tap0接口,用brctrl把tap0和eth0桥接起来,再运行openvpn
server.conf启动openvpn,B执行openvpn client.conf就会连接到A了,因为A事先把tap0和
eth0桥接起来了生成br0接口,所以eth0和B已经在一起局域网里了,A往br0的广播可以同时被
eth0所在的局域网和B收到,如果B把它那端的tap和它的eth0再桥接起来,估计A B两个局域网
都可以互通了. 当然在这之前需要在A的路由器上做 openvpn用的那个udp端口的DNAT,还需要
做udp和tcp 6112的DNAT,否则B看了A了也连不上A建的游戏. 如果是在校园网的环境用vpn玩
游戏,比如学十的想和学九的连,直接用pptp就可以,用openvpn也可以,但如果A把tap0和eth0
桥接起来,B也把tap0和eth0桥接起来会不会被封?

** brctrl							    :net:bridge:
#+BEGIN_EXAMPLE
brctrl addbr br0
brctrl addif eth0
brctrl addif eth1
ifconfig eth0 0.0.0.0
ifconfig eth1 0.0.0.0
ifconfig br0 192.168.0.102 netmask 255.255.255.0 broadcast 192.168.0.255
ifconfig br0 down
brctrl delbr br0
#+END_EXAMPLE
** dnsmasq							       :net:dns:


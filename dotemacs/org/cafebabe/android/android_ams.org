#+TITLE: ActivityManagerService
* ActivityManagerService
** Intent and IntentFilter                                          :intent:
*** Intent.setPackage(pkg)
     only match Activities in this `pkg`
*** Intent.component
*** IntentFilter.priority
     candidates ARE sorted by IntentFilter.priority when resolving intent, but
     - when resolve activity, ResolveActivity will reorder candidates in alphabet order....so nothing
     - when resolve service, only candidate with the highest priority are selected
     - when resolve broadcast, candidate priority are considered for OrderedBroadcast
*** IntentFilter matching
     CLOSED: [2011-01-19 Wed 16:07]
     - State "DONE"       [2011-01-19 Wed 16:07]
     how startActivity(or startService, sendBrocast) use Intent.{category,action,data} to find the correct intent receiver?
     AMS use [[PackageManager][PackageManager]] to resolve intent to get intent's component
**** startActivity
#+BEGIN_SRC text
  AMS:startActivity()
      AMS:startActivityMayWait()
          PM:resolveIntent()
              PM:queryIntentActivities()
                  // explicit intent
                  if (intent.getCommponent())
                      return the component
                  // implicit intent
                  if (intent.getPackage()==null)
                      PM:mActivities.queryIntent()
                          foreach activity:
                            buildResolveList()
                               foreach IntentFilter:
                                 filter.match()
                                 make sure filter has DEFAULT category
                  else
                      PM:mActivities.queryIntentForPackage()
                        foreach activity:
                            buildResolveList()
                               foreach IntentFilter:
                                 filter.match()
                                 make sure filter has DEFAULT category
              PM:chooseBestActivity()
                  // candidates here are sorted by [[IntentFilter.priority][IntentFilter.priority]]
                  if (candidates.size() == 1)
                      return it;
                  if we have saved a preference for a preferred activity
                      return findPreferredActivity()
                  else
                      return ResolverActivity // although candidates are sorted by IntentFilter.priority, ResolverActivity will
                                              // reorder them in alphabet order...weired~~
          Intent.setComponent()
          AMS:startActivityLocked()
            checkComponentPermission();
          ...
#+END_SRC
      - PM:resolveIntent
       	when PackagetManager need to detect whether there are activities in a certain package matching the Intent, it will resolve the inent as:
       	1) PM calls queryIntentForPackage, which will take a List of activities in the package as param
       	2) for every activity, call buildResolveList, which take a List of all IntentFilters of the activity as param
       	3) for every IntentFilter, call filter.match( intent.getAction(), resolvedType, scheme, intent.getData(), categories, TAG); to determine whether
	   the IntentFilter matches the Intent, if so, add the activity to the candidates.  Note that categories is a list of Category in the intent, since
	   intent can call addCategory() to add serveral categories requirement
       	4) filter.match() will check
	   1) action
	      intent action mustn't be null and must be in the IntentFilter's actions list
	   2) data
	      data must be a subset of IntentFilter's data list
	   3) category
	      if intent's categories is a subset of filter's categories, or intent's category is null , return ok
       	5) if filter.match() match, there is still one last check:
	   1) if the defaultOnly flag is set (in fact, startActivity will always set the flag when resolveIntent), and the candidate intentFilter also
	      has the DEFAULT category, returns ok.  this is just as if the Intent has added the DEFAULT category by default. BUT, since it is restriction
	      imposed by AMS, we can't override the behaviour by calling intent.removeCategory(DEFAULT)
	   2) note: the DEFAULT_ONLY flag and intentFilter's default category is mainly used by startActivity, use PM standalone (e.g. resolveActivity) doesn't
	      impose this restriction.
      - PM:chooseBestActivity
       	after PM:resolveIntent, a list of candidates are available, PM will choose the best activity
       	1) if there is only ONE candidates, return it
       	2) else, call findPreferredActivity to find if we have saved a preference for a preferred activity for this intent
       	3) else, return a ResolverActivity, which will show a ResolverActivity and promp user for the prefered activity. ResolverActivity will sort candidates
	   in alphabet order, regardless of IntentFilter's priority.
      - At last, if PM returns a ResolverActivity, AMS will actually start ResolverActivity, ResolverActivity's onClick will call startActivity() to start the real user prefered activity.

**** startService
#+BEGIN_EXAMPLE
  AMS:startServiceLocked()
    AMS:retrieveServiceLocked()
        if ret=mServicesByIntent.get(intent)
            return ret; //      * All currently running services indexed by the Intent used to start them.
        else
            PM:resolveService()  // just like resolveActivity
                PM:queryIntentServices()
                    if intent.getComponent()
                        use it;
                    else
                        PM:queryIntent() // return a list of candidates, note that the list is sorted according to [[IntentFilter.priority][IntentFilter.priority]]
                if candidates>1      // more than ONE candidate
                    use candidate.get(0)  // pick the first one. because the candidates are sorted according
                                             // to IntentFilter.priority, so the candidate with the highest priority is selected.
        checkComponentPermission()
#+END_EXAMPLE

**** sendBroadcast
just as startService, priority are considered, and a list of all candidates are return to support OrderedBroadcast
** Activity                                                       :activity:
*** AMS side
**** finishedActivityLocked
finishCurrentActivity eventually will not stop and destroy activity at
once, it will pose it in an array, when idle, it will call
activityIdle to purge the activities.

When is idle? There are 2 scen:
 1) thread.scheduleResumeActivity will pose one 'Idler' in the msg queue after onResume is finished. Idler will invoke AMS.activityIdle
 2)AMS is smart enough to pose on one delayed IDLE_TIMEOUT_MSG to the handler in case there is no Idler since onResume hangs. The delayed timeout is 10s.

 That is, onStop and onDestroy may be delayed for 10s after another activity's onResume is called.
 11/23/10 11:40 am
 finishActivityLocked
 startPausing

 ...

 activityPaused
 finishCurrentActivity --> mark the activity for destroy
 resumeTopActivity
 ...
 activity resumed --> pose idler timer to destroy activity marked befored

 11/17/10 6:46 pm
 assume that when A is finished and B will be resumed: first, A is paused, then B is resumed, and A is stopped and destroyed at last


 11/17/10 6:37 pm
 To prevent if activity.onPause doesn't return in a period of time(500ms), AMS will call sendMessageDelayed() in startPausingLocked() to send itself one PAUSE_TIMEOUT msg to force itself call activityPaused().
    
 That is, although activity.onPause() may block, AMS is assured to resume	next activity in 500ms.


 1. activity.finish() will call AMS's finishActivity() through
    AIDL, providing activity's IBinder as parameter so that AMS
    can recognize the corresponding HistoryRecord in AMS.

 2. AMS calls
 finishActivityLocked()
 startPausingLocked()
 thread.schedulePauseActivity()

 3. thread.schedulePauseActivity() will call activity.onPause(),
    then notify AMS that activity is paused through
    AMS.activityPaused()

 4. activityPaused()
 completePauseActivity()
 mark activity for stop when idle
 resumeTopActivity()

**** attachApplication

attachApplication is the 3rd step to start a new
activity. (1. startPausing, 2. activityPaused.)

When one new activityThread is created, after calling onCreate,
activityThread will invoke AMS.attachApplication to notify AMS that
process is OK, then AMS can call realStartActivity to launch the
activity.

**** bindApplication
AMS 使用 thread.bindApplication 告诉新建立的 activityThread 应该 "bind"
到哪个 application. 任何一个 ActivityThread 在刚启动时(通过 main) 时并
不知道它和哪个 application (apk) 相关的, 只有
AMS::thread.bindApplication 之后, ActivityThread 才和某个 app 相关, 通
过 ps 或 ddms 看这个进程的名字都会显示 app 相关的名字.
**** activityPaused

activityPaused is called by ActivityThread to notity AMS that the
mResumed activity is paused(or onPause is timeout)

after that, if prev should be finished (when finish activity), it will
call finishCurrentActivity to finish prev activity. Then
resumeTopActivity will be called again to really resume another
activity.

**** startActivityLocked

11/22/10 2:08 pm
AMS.startActivityLocked() is the very begining  entry to start activity.

Stack trace:
AMS side:
#+BEGIN_EXAMPLE
startActivity
  startActivityUnchecked
     moveTaskToFront
        finishTaskMoved
            resumeTopActivity
#+END_EXAMPLE

when resumeTopActivity, it will firstly call startPausing to pause mResumedActivity A.

after A's onPause return, ActivityThread will notify AMS through AMS.ActivityPaused, which will then call resumeTopActivity again to resume  activity.

When invoked for the 2nd time, it will try call r.app.thread.scheduleResumeActivity to resume our activity,  then return. but before calling onResume, AMS
will firstly invoke mWindowManager.setAppVisibility(next, true) if the activity is invisible, which will call onRestart and onStart before onResume.

If exception occurs, it means the activity is already finished, or it's process is not started at all, it will call
#+BEGIN_EXAMPLE
startSpecificActivityLocked,
  realStartActivityLocked
    thread.scheduleLaunchActivity

or
startSpecificActivityLocked,
  startProcessLocked
#+END_EXAMPLE

for the 2nd scenero, when activityThread is started in
startProcessLocked, it will call AMS.attachApplication to notify AMS
that the process is ready, attachApplication will then call
realStartActivity again to real kaunch the activity.

**** resumeTopActivityLocked
resumeTopActivity will firstly call startPausing to pause the
mResumedActivity, then return directory.

When mResumedActivity is paused or timeout (500ms), AMS.activityPaused
will be called, which will invoke resumeTopActivity again to finally
resume(or launch) the activity.

**** Timeout
***** Pause timeout
***** Idle timeout

idle timeout is the timeout to stop and destroy activity A after
activity B is resumed. in the normal case, B's scheduleResumeActivity
will pose an Idler after onResume to ensure that A will be finish via
activityIdle. Howerer, if B's onResume hangs, a delay IDLE_TIMEOUT_MSG
is a must for AMS to make sure A will be finished in 10s.

**** HistoryRecord
HistoryRecord is used in two ways:
- it is the shadow structure of `Activity` in AMS
- it is used as a IBinder token by AMS, e.g. when AMS want to resume activity, it will send the activity's corresponding HistoryRecord as a token to
  ActivityThread, so that ActivityThread knows which activity to resume.
  - r.app.thread
  - r.resultRecord
  - r.sourceRecord
  - r.intent
***** AMS.mHistory stores all the HistoryRecord of AMS.
**** startPausingLocked
11/22/10 6:43 pm
startPausing is called in resumeTopActivity to pause the mResumed activity before resume or launch the target activity
**** startSpecificActivity
11/23/10 1:06 pm
it is called when resumeTopActivity (2nd time when prev is paused) to start (instead of resume) target activity.

It may call realStartActivity to start the activity or call startProcess to start a new process.
***** startProcess
***** realStartActiviry
11/23/10 1:10 pm
real start an activity instead of resume or start a new process.

This is called in 2 scen:
1) startSpecificActivity in resumeTopActivity
2) attachApplication, since when attachApplication, the process
   definitly exist and activity is surely not started
   yet. resumeTopActivity is redunctant, calling realStartActivity is
   enough.
*** ActivityThread side
**** ActivityRecord

ActivityRecord will save the real Activity instance and some other
info.  It corresponds to AMS::HistoryRecord. ActivityRecord use one
Map<IBinder,ActivityRecord> to save process's all activities.

Evey ActivityThread.scheduleXxx () takes an 'Token' (an IBinder) as
para so that ActivityThread can get the corres ActivityRecord from the
map.

**** IApplicationThread
***** schedulePausingActivity
schedulePausingActivity will firstly call activity.onPaused, and wait for
return, then it will notify AMS through AMS.activityPaused that the
activity is paused.
***** scheduleResumeActivity
it will call onResume, when onResume returns, it will add one Idler to
AMS's queue, to make sure AMS will be norified when queue is idle to stop
and destroy pending need-to-finish act ivies
***** scheduleLaunchActivity
when called by AMS.realStartActivity, scheduleLaunchActivity will
sequencially call onCreate, onStart,
onRestoreInstanceState,onPostCreate,onResume.
*** Activity side
  - onStop, onRestart is only related to activity visibility. they
    are invoked by mWindowManager.setAppVisibility() due to
    visibility change.
   - onStart may be called due to visibility change or life cycle
     change.
   - onPause, onDestroy, onResume is the core concept related to
     activity life cycle, they are called only when life cycle is
     changed.
**** finish
**** onPause

only when starting another *Activity*, will the former activity's
onPause be called; that is, Dialog, PopupWindow will not trigger
activity's onPause

**** onStop

may only be called after onPause if the paused activity is totally
invisible to the user, onStop will be called that is, if the resumed
activity is opaque, the paused activity's onStop would not be called

resumeTopActivity will call mWindowManager.setAppVisibility(prev,
false); // cause prev.onStop be called to stop prev activity

**** onDestroy
**** onResume
**** onRestart
      resumeTopActivity will cal  mWindowManager.setAppVisibility(next, true);  // cause next.onRestart and next.onStart be called
      to call onRestart and onStart
**** onStart
**** onCreate
*** Task stack
*** NativeActivity
*** Activity Result

*** PENDING Launcher
     see also [[Launcher & Task]]
*** Task
**** why relaunch an activity A from launcher will bring the task to foreground

note that: startActivity from launcher will always use Intent flags of NEW_TASK

#+begin_src java
  startActivityUnchecked()
    if NEW_TASK && ((MULTIPLE_TASK not set)||...): // see MULTIPLE_TASK flag later, true
      taskTop = findTaskLocked(intent, r.info)
        // findTaskLocked will return the top activity in any existing task matching the given intent
        // typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered
        // How taskAffinity is null? if activity's taskAffinity property is set to "" (see [[Notification]]), then it's taskAffinity will be set to null
  
      if (taskTop != null): // there is already an existing task for the activity A, true
        if (r.realActivity.equals(taskTop.task.realActivity)): // activity A is the same as the matching task's root activity, true
          if FLAG_ACTIVITY_SINGLE_TOP is set:
            deliverNewIntentLocked(taskTop, r.intent);  // onNewIntent is called
            resumeTopActivityLocked(null);
              mWindowManager.setAppVisibility(prev, false); // cause onStop be called
              mWindowManager.setAppVisibility(next, true);  // cause onRestart and onStart be called
            return START_DELIVERED_TO_TOP;
          else if r.intent.filterEquals(taskTop.task.intent):  // if activity A's calling intent is equal with the intent used to start
                                                               // the task's root activity, intent equality will consider intent action,category,
                                                               // data,type,component..., but *excluding any intent extra*, true
            resumeTopActivity()
              if resumedActivity == topRunningActivity:        // need not resume, in this case, resumedActivity is launcher, while topRunningActivity
                                                               // is Activity A, false
                return;
              else:
                pause resumeActivity and resume topRunningActivity  // true
                mWindowManager.setAppVisibility(prev, false); // cause onStop be called
                mWindowManager.setAppVisibility(next, true);  // cause onRestart and onStart be called
  
            return START_TASK_TO_FRONT;                        // move the task to foreground
    else: // if NEW_TASK
      if (top.realActivity.equals(r.realActivity)):
        if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
          or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
          or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
          resumeTopActivityLocked(null);
          deliverNewIntentLocked(top, r.intent);
          return START_DELIVERED_TO_TOP;
      create or start the activity                           // false
  
#+end_src

To summarize:

when relaunching an activity from launcher, because the intent used to
relaunch the activity is the same as the former task's root activity's
intent (both are MAIN & LAUNCHER..), AMS will try to resume the
activity instead of relaunching it. startActivity with *NEW\_TASK* and
the *same* intent as the task's intent will bring the task to
foreground (through resumeTopActivity) instead of launching it. this
behavior is similar with that the task's top activity has the
SINGLE\_TOP launchMode.

Note about MULTIPLE\_TASK intent flag: Used in conjunction with
FLAG\_ACTIVITY\_NEW_TASK to disable the behavior of bringing an
existing task to the foreground.  When set, a new task is always
started to host the Activity for the Intent, regardless of whether
there is already an existing task running the same thing.

**** startActivityUnchecked & affinity, launchMode, intentFlags

#+BEGIN_EXAMPLE
01-06 15:01:48.800 E/sunway  (  383): startActivityLocked for Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.android.settings/.Settings }
01-06 15:01:48.810 E/sunway  (  383): startActivityUncheckedLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.810 E/sunway  (  383): startActivityLocked:ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.810 E/sunway  (  383): before setAppStartingWindow
01-06 15:01:48.830 E/sunway  (  383): after setAppStartingWindow
01-06 15:01:48.830 E/sunway  (  383): resumeTopActivityLocked: next is ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.840 E/sunway  (  383): start pausing for ActivityRecord{41aabee0 com.android.launcher/com.android.launcher2.Launcher}
01-06 15:01:48.950 E/sunway  (  383): activity paused
01-06 15:01:48.950 E/sunway  (  383): resumeTopActivityLocked: next is ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.950 E/sunway  (  383): resumeTopActivityLocked: really resume
01-06 15:01:48.950 E/sunway  (  383): startSpecificActivityLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:48.950 E/sunway  (  383): startProcessLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.050 E/sunway  (  383): resumeTopActivityLocked: next is ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.050 E/sunway  (  383): resumeTopActivityLocked: really resume
01-06 15:01:49.050 E/sunway  (  383): startSpecificActivityLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.050 E/sunway  (  383): startProcessLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.100 E/sunway  (  383): attachApplicationLocked for 1480
01-06 15:01:49.100 E/sunway  (  383): realStartActivityLocked for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.100 E/sunway  (  383): scheduleLaunchActivity for ActivityRecord{416d0380 com.android.settings/.Settings}
01-06 15:01:49.140 W/asset   ( 1480): sunway: add sprd overlay package for vendor /vendor/overlay/framework/sprd-framework-res.apk
01-06 15:01:49.240 W/asset   ( 1480): sunway: add sprd overlay package for vendor /vendor/overlay/framework/sprd-framework-res.apk

#+END_EXAMPLE

*FLAG\_ACTIVITY\_NEW\_TASK* is defininitly the most important property related to android task management.
***** source code comment
#+BEGIN_EXAMPLE
  private final int startActivityUncheckedLocked(HistoryRecord r,
            HistoryRecord sourceRecord, Uri[] grantedUriPermissions,
            int grantedMode, boolean onlyIfNeeded, boolean doResume) {
        Slog.e("sunway","flag");
        final Intent intent = r.intent;
        final int callingUid = r.launchedFromUid;
        int launchFlags = intent.getFlags();
  
        // We'll invoke onUserLeaving before onPause only if the launching
      // activity did not explicitly state that this is an automated launch.
      mUserLeaving = (launchFlags&Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0;
      if (DEBUG_USER_LEAVING) Slog.v(TAG,
              "startActivity() => mUserLeaving=" + mUserLeaving);
  
      // If the caller has asked not to resume at this point, we make note
      // of this in the record so that we can skip it when trying to find
      // the top running activity.
      if (!doResume) {
          r.delayedResume = true;
      }
  
      HistoryRecord notTop = (launchFlags&Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP)
              != 0 ? r : null;
  
      // If the onlyIfNeeded flag is set, then we can do this if the activity
      // being launched is the same as the one making the call...  or, as
      // a special case, if we do not know the caller then we count the
      // current top activity as the caller.
      if (onlyIfNeeded) {
          HistoryRecord checkedCaller = sourceRecord;
          if (checkedCaller == null) {
              checkedCaller = topRunningNonDelayedActivityLocked(notTop);
          }
          if (!checkedCaller.realActivity.equals(r.realActivity)) {
              // Caller is not the same as launcher, so always needed.
              onlyIfNeeded = false;
          }
      }
  
      if (grantedUriPermissions != null && callingUid > 0) {
          for (int i=0; i<grantedUriPermissions.length; i++) {
              grantUriPermissionLocked(callingUid, r.packageName,
                      grantedUriPermissions[i], grantedMode, r);
          }
      }
  
      grantUriPermissionFromIntentLocked(callingUid, r.packageName,
              intent, r);
  
      if (sourceRecord == null) {
          // This activity is not being started from another...  in this
          // case we -always- start a new task.
          if ((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
              Slog.w(TAG, "startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: "
                    + intent);
              launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
          }
      } else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          // The original activity who is starting us is running as a single
          // instance...  this new activity it is starting must go on its
          // own task.
          launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
      } else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
              || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
          // The activity being started is a single instance...  it always
          // gets launched into its own task.
          launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
      }
  
      if (r.resultTo != null && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
          // For whatever reason this activity is being launched into a new
          // task...  yet the caller has requested a result back.  Well, that
          // is pretty messed up, so instead immediately send back a cancel
          // and let the new task continue launched as normal without a
          // dependency on its originator.
          Slog.w(TAG, "Activity is launching as a new task, so cancelling activity result.");
          sendActivityResultLocked(-1,
                  r.resultTo, r.resultWho, r.requestCode,
              Activity.RESULT_CANCELED, null);
          r.resultTo = null;
      }
  
      boolean addingToTask = false;
      if (((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &&
              (launchFlags&Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0)
              || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
              || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
          // If bring to front is requested, and no result is requested, and
          // we can find a task that was started with this same
          // component, then instead of launching bring that one to the front.
          if (r.resultTo == null) {
              // See if there is a task to bring to the front.  If this is
              // a SINGLE_INSTANCE activity, there can be one and only one
              // instance of it in the history, and it is always in its own
              // unique task, so we do a special search.
  
              // sunway:
              // 对于launchMode不为SINGLE_INSTANCE的情况, taskTop是根
              // 据affinity(或activity component)查找到的已存在的task的top activity; 对于
              // SINGLE_INSTANCE的情况, taskTop为该single activity
              // Q: 系统如何在NEW_TASK时查找是否已经存在一个`密切`的task?
  
              HistoryRecord taskTop = r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE
                      ? findTaskLocked(intent, r.info)
                      : findActivityLocked(intent, r.info);
  
              // sunway:
              // 对于NEW_TASK, 已经找到一个已经存在的TASK或single instance
              // activity
  
              if (taskTop != null) {
                  if (taskTop.task.intent == null) {
                      // This task was started because of movement of
                      // the activity based on affinity...  now that we
                      // are actually launching it, we can assign the
                      // base intent.
                      taskTop.task.setIntent(intent, r.info);
                  }
                  // If the target task is not in the front, then we need
                  // to bring it to the front...  except...  well, with
                  // SINGLE_TASK_LAUNCH it's not entirely clear.  We'd like
                  // to have the same behavior as if a new instance was
                  // being started, which means not bringing it to the front
                  // if the caller is not itself in the front.
  
  
                  HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);
  
                  // sunway:
                  // our task or single_instance activity is in background,
                  // move it to front
  
                  if (curTop.task != taskTop.task) {
                      r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
                      boolean callerAtFront = sourceRecord == null
                              || curTop.task == sourceRecord.task;
  
                      // sunway:
                      // 如果: 1. new task 2. task在后台 3. caller在前台 (或
                      // sourceRecord==null),则将task移到前台, 所以, 一个后台的
                      // task里的一个thread无法通过 new_task &
                      // activity.startActivity将task移动到前台
  
                      if (callerAtFront) {
                          // We really do want to push this one into the
                          // user's face, right now.
                          moveTaskToFrontLocked(taskTop.task, r);
                      }
                  }
                  // If the caller has requested that the target task be
                  // reset, then do so.
                  if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
                      // sunway:
                      // reset task ... take a deep breath;
                      taskTop = resetTaskIfNeededLocked(taskTop, r);
                  }
                  if (onlyIfNeeded) {
                      // We don't need to start a new activity, and
                      // the client said not to do anything if that
                      // is the case, so this is it!  And for paranoia, make
                      // sure we have correctly resumed the top activity.
                      if (doResume) {
                          resumeTopActivityLocked(null);
                      }
                      return START_RETURN_INTENT_TO_CALLER;
                  }
  
                  if ((launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
                          || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
                          || r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
                      // In this situation we want to remove all activities
                      // from the task up to the one being started.  In most
                      // cases this means we are resetting the task to its
                      // initial state.
  
                      // sunway:
                      // 在大多数情况下, task或single instance activity
                      // 在此之前已经被移动到前台,performClearTaskLocked只会
                      // finish该task中位于r之上的activity, 除非...移动到前台
                      // 时失败(例如callerAtFront为假,这时会有意想不到的效
                      // 果)
  
                      // sunway:
                      // performClearTaskLocked会finish位于r,top之间的所有
                      // activity,一般情况下不会finish `基准`activity (对于
                      // CLEAR_TOP,即是r,对于SINGLE_TASK,SINGLE_INSTANCE,即是
                      // task的root activity, 除非...基准activity是MULTIPLE
                      // launch mode且其SINGLE_TOP为假
  
                      // 总结: 对于一般的startActivity(不包含
                      // RESET_TASK_IF_NEEDED intent flag), CLEAR_TOP是可以
                      // finish某些activity的机会,如果想让一个activity在每次
                      // startActivity时finish掉之前的并create新的且只有一个实
                      // 例 (例如某些通知功能的activity),可以:
                      // 1. 使用NEW_TASK和CLEAR_TOP
                      // 2. launchMode为MULTIPLE,且SINGLE_TOP为假
                      // 3. 为防止CLEAR_TOP误杀同task的其他activity, 可以设其
                      // affinity为其他唯一值或者直接使用空串, 确保task中只有
                      // 它一个activity (类似于singleInstance)
  
                      // Q: 看起来start SINGLE_TASK 的 root activity 也会导致
                      // performClearTask .... 并perforClearTask并不
                      // 能保证developer中声称的SINGLE_TASK的属性:SINGLE_TASK必
                      // 须是task的root activity; 实际上这段代码的效果是: 设
                      // A,B的affinity相同, A启动B,其中B是
                      // SINGLE_TASK,则结果是A,B; B再启动A,结果A,B,A; A再启动
                      // B, 结果是A,B, 和CLEAR_TOP有啥区别?
                      // 若想达到文档中声称的SINGLE_TASK效果,必须保证B一开始就
                      // 是task的root activity.....那只能给它设一个唯一的
                      // affinity(或affinity为null)才行
                      // Q: 为什么会有这个问题?
                      // A: 相比之下,SINGLE_INSTANCE的行为是正常的,根本原因是
                      // 因为前面对taskTop的查找: 对于SINGLE_INSTANCE, 是从整
                      // 个mHistory去找唯一的一个activity实例. 而对于
                      // SINGLE_TASK, 则是从上到下根据affinity找\emph{第一个}
                      // 匹配的task, 考虑这种情况:
                      // 有A,B,C,D四个activity, 使用相同的affinity, 其中的A是
                      // SINGLE_TASK, 设当前有两个task, 'A,C,D'和'B'. 然后另外
                      // 某处startActivity(B), 假设系统找到第一个匹配的
                      // task是'A,C,D'... 是否要为B生成一个new task?
                      // 所以根本原因是task的管理还是过于简单, \emph{task的查找方法
                      // 无法满足SINGLE_TASK语义}.
                      // 做为workaround,可以通过确保SINGLE_TASK的activity为唯
                      // 一的affinity来弥补task查找方法的不足.
  
  
                      HistoryRecord top = performClearTaskLocked(
                              taskTop.task.taskId, r, launchFlags, true);
  
                      // sunway:
                      // 若top不为null, 说明CLEAR_TOP真的只是 `clear top`, 则需
                      // 要调用top的onNewIntent
  
  
                      if (top != null) {
                          if (top.frontOfTask) {
                              // Activity aliases may mean we use different
                              // intents for the top activity, so make sure
                              // the task now has the identity of the new
                              // intent.
                              top.task.setIntent(r.intent, r.info);
                          }
                          logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
                          deliverNewIntentLocked(top, r.intent);
                      } else {
                          // sunway:
                          // 若top为null,说明CLEAR_TOP把`基准`activity也clear掉
                          // 了...这种情况的发生只有一种可能:`基准`activity是
                          // MULTIPLE & SINGLE_TOP, `基准`activity被clear掉后,
                          // 需要通过addingToTask标记通知后续代码:该activity需
                          // 要重新添加一个新的实例到task中, addingToTask的意思
                          // 是:addNewInstanceToTask
  
                          // A special case: we need to
                          // start the activity because it is not currently
                          // running, and the caller has asked to clear the
                          // current task to have this activity at the top.
                          addingToTask = true;
                          // Now pretend like this activity is being started
                          // by the top of its task, so it is put in the
                          // right place.
                          sourceRecord = taskTop;
                      }
                  } else if (r.realActivity.equals(taskTop.task.realActivity)) {
                      // sunway:
                      // 我们想要start的是task的root activity, 若使用的intent
                      // 也是相同的, 系统认为我们只是想moveTaskToFront, 所以不
                      // 生新create一个activity,则只是resume这个task的top
                      // activity.
                      // 实际上,这段代码反映的是launcher的行为: laucher每次点
                      // 击桌面图标时,对同一个图标,使用的intent是一样的,且要启
                      // 动的activity也必然是task的root activity
                      // 通过模拟launcher的这种行为,我们也可以只是将某个task移
                      // 动到前台,而不做其他任何事
  
  
  
                      // In this case the top activity on the task is the
                      // same as the one being launched, so we take that
                      // as a request to bring the task to the foreground.
                      // If the top activity in the task is the root
                      // activity, deliver this new intent to it if it
                      // desires.
                      if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
                              && taskTop.realActivity.equals(r.realActivity)) {
                          logStartActivity(EventLogTags.AM_NEW_INTENT, r, taskTop.task);
                          if (taskTop.frontOfTask) {
                              taskTop.task.setIntent(r.intent, r.info);
                          }
                          deliverNewIntentLocked(taskTop, r.intent);
                      } else if (!r.intent.filterEquals(taskTop.task.intent)) {
                          // In this case we are launching the root activity
                          // of the task, but with a different intent.  We
                          // should start a new instance on top.
                          addingToTask = true;
                          sourceRecord = taskTop;
                      }
                  } else if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
                      // sunway:
                      // 这里基本上是NEW_TASK所判断的最后一个条件了: 若
                      // RESET_TASK_IF_NEED设置, 则addingToTask为false,阻止了
                      // 后续的处理. 效果和前面提到的launcher行为类似,但要启动
                      // 的activity不必是root activity.
                      // 一般情况下,只有launcher会使用这个标志
  
  
                      // In this case an activity is being launched in to an
                      // existing task, without resetting that task.  This
                      // is typically the situation of launching an activity
                      // from a notification or shortcut.  We want to place
                      // the new activity on top of the current task.
                      addingToTask = true;
                      sourceRecord = taskTop;
                  } else if (!taskTop.task.rootWasReset) {
                      // In this case we are launching in to an existing task
                      // that has not yet been started from its front door.
                      // The current task has been brought to the front.
                      // Ideally, we'd probably like to place this new task
                      // at the bottom of its stack, but that's a little hard
                      // to do with the current organization of the code so
                      // for now we'll just drop it.
                      taskTop.task.setIntent(r.intent, r.info);
                  }
                  if (!addingToTask) {
                      // We didn't do anything...  but it was needed (a.k.a., client
                      // don't use that intent!)  And for paranoia, make
                      // sure we have correctly resumed the top activity.
                      if (doResume) {
                          resumeTopActivityLocked(null);
                      }
                      return START_TASK_TO_FRONT;
                  }
              }
          }
      }
  
      // sunway:
      // finally we are here....
      // 在三种情况下代码会走到这里:
      // case 1. NEW_TASK为真, 但taskTop为null...说明现在系统里找不到一个已经存在的
      // `密切`的task, 真的需要`new`一个task了
      // case 2. NEW_TASK==true, taskTop!=null, 但addingToTask为真, 即需要在taskTop
      // 上 new activity instance
      // case 3. 根本没有指定NEW_TASK标志,新的activity使用当前的task (使用当前的
      // task并不意味着要直接new activity instance, 因为SINGLE_TOP,
      // CLEAR_TOP...还要考虑)
      //
      //
      //
      //String uri = r.intent.toURI();
      //Intent intent2 = new Intent(uri);
      //Slog.i(TAG, "Given intent: " + r.intent);
      //Slog.i(TAG, "URI is: " + uri);
      //Slog.i(TAG, "To intent: " + intent2);
      if (r.packageName != null) {
          // If the activity being launched is the same as the one currently
          // at the top, then we need to check if it should only be launched
          // once.
          HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
          if (top != null && r.resultTo == null) {
              if (top.realActivity.equals(r.realActivity)) {
                  if (top.app != null && top.app.thread != null) {
                      // sunway:
                      // case 2,3;
                      // SINGLE_TOP并非NEW_TASK的专利
                      // A,B,C (c single top)
                      if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
                          || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
                          || r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK) {
                          logStartActivity(EventLogTags.AM_NEW_INTENT, top, top.task);
                          // For paranoia, make sure we have correctly
                          // resumed the top activity.
                          if (doResume) {
                              resumeTopActivityLocked(null);
                          }
                          if (onlyIfNeeded) {
                              // We don't need to start a new activity, and
                              // the client said not to do anything if that
                              // is the case, so this is it!
                              return START_RETURN_INTENT_TO_CALLER;
                          }
                          deliverNewIntentLocked(top, r.intent);
                          return START_DELIVERED_TO_TOP;
                      }
                  }
              }
          }
  
      } else {
          if (r.resultTo != null) {
              sendActivityResultLocked(-1,
                      r.resultTo, r.resultWho, r.requestCode,
                  Activity.RESULT_CANCELED, null);
          }
          return START_CLASS_NOT_FOUND;
      }
  
      boolean newTask = false;
  
      // Should this be considered a new task?
      if (r.resultTo == null && !addingToTask
              && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
          // sunway:
          // case 1, 新建一个task, NEW_TASK
  
          // todo: should do better management of integers.
          mCurTask++;
          if (mCurTask <= 0) {
              mCurTask = 1;
          }
          r.task = new TaskRecord(mCurTask, r.info, intent,
                  (r.info.flags&ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
          if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
                  + " in new task " + r.task);
          newTask = true;
          addRecentTaskLocked(r.task);
  
      } else if (sourceRecord != null) {
          if (!addingToTask &&
                  (launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) {
              // sunway
              // case 3;
              // CLEAR_TOP并非NEW_TASK的专利
              // 由于这里没有经过NEW_TASK的 moveToFront, 导致CLEAR_TOP更容易伤
              // 到其他task的activity
  
              // In this case, we are adding the activity to an existing
              // task, but the caller has asked to clear that task if the
              // activity is already running.
  
              HistoryRecord top = performClearTaskLocked(
                      sourceRecord.task.taskId, r, launchFlags, true);
              if (top != null) {
                  logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
                  deliverNewIntentLocked(top, r.intent);
                  // For paranoia, make sure we have correctly
                  // resumed the top activity.
                  if (doResume) {
                      resumeTopActivityLocked(null);
                  }
                  return START_DELIVERED_TO_TOP;
              }
          } else if (!addingToTask &&
                  (launchFlags&Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) {
              // sunway:
  
              // case 3;
              // REORDER_TO_FRONT是非NEW_TASK的专利
              // 若当前task的stack为A,B,C; C调用startActivity(B),则执行后的结
              // 果为A,C,B;
              // 即B会被reorder to front
              //
              // 到目前为止可以导致onNewIntent的标志:
              // 1. SINGLE_INSTANCE, SINGLE_TASK
              // 2. MULTIPLE & SINGLE_TOP
              // 3. REORDER_TO_FRONT
  
  
              // In this case, we are launching an activity in our own task
              // that may already be running somewhere in the history, and
              // we want to shuffle it to the front of the stack if so.
              int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
              if (where >= 0) {
                  HistoryRecord top = moveActivityToFrontLocked(where);
                  logStartActivity(EventLogTags.AM_NEW_INTENT, r, top.task);
                  deliverNewIntentLocked(top, r.intent);
                  if (doResume) {
                      resumeTopActivityLocked(null);
                  }
                  return START_DELIVERED_TO_TOP;
              }
          }
          // An existing activity is starting this new activity, so we want
          // to keep the new one in the same task as the one that is starting
          // it.
          r.task = sourceRecord.task;
          if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
                  + " in existing task " + r.task);
  
      } else {
          // This not being started from an existing activity, and not part
          // of a new task...  just put it in the top task, though these days
          // this case should never happen.
          final int N = mHistory.size();
          HistoryRecord prev =
              N > 0 ? (HistoryRecord)mHistory.get(N-1) : null;
          r.task = prev != null
              ? prev.task
              : new TaskRecord(mCurTask, r.info, intent,
                      (r.info.flags&ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
          if (DEBUG_TASKS) Slog.v(TAG, "Starting new activity " + r
                  + " in new guessed " + r.task);
      }
      if (newTask) {
          EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, r.task.taskId);
      }
      logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);
  
      // sunway:
      //
      // 经过九九八十一难,到这里才真正调用onCreate;回想前面的种种, 有些
      // activity被kill掉了, 有些被移动到前台并被resume了, 能收到onNewIntent调
      // 用都算不错了; 能真正因为startActivity导致onCreate被调用的有多少?
  
      startActivityLocked(r, newTask, doResume);
      return START_SUCCESS;
  }
  
  
  
  
  ate HistoryRecord findTaskLocked(Intent intent, ActivityInfo info) {
      ComponentName cls = intent.getComponent();
      if (info.targetActivity != null) {
          cls = new ComponentName(info.packageName, info.targetActivity);
      }
  
      TaskRecord cp = null;
  
      final int N = mHistory.size();
      for (int i=(N-1); i>=0; i--) {
          HistoryRecord r = (HistoryRecord)mHistory.get(i);
          if (!r.finishing && r.task != cp
                  && r.launchMode != ActivityInfo.LAUNCH_SINGLE_INSTANCE) {
  
              // sunway:
              // launchMode!=SINGLE_INSTANCE这个条件可用避免这种情况:
              // 当前mHistory对于同一个affinity有多个task (只有一种可能:一个为正常的task,
              // 其他的均为SINGLE_INSTANCE); 通过这个条件判断,可以避免findTask
              // 时找到SINGLE_INSTANCE的task (这种task即使找到也不可能往上添加
              // 其他activity, 结果还是要新建一个task, 但实际上该
              // SINGLE_INSTANCE下面明明有一个可用的`正常`task...最后会导致task越
              // 来越多)
  
              cp = r.task;
              //Slog.i(TAG, "Comparing existing cls=" + r.task.intent.getComponent().flattenToShortString()
              //        + "/aff=" + r.task.affinity + " to new cls="
              //        + intent.getComponent().flattenToShortString() + "/aff=" + taskAffinity);
              if (r.task.affinity != null) {
                  if (r.task.affinity.equals(info.taskAffinity)) {
                      //Slog.i(TAG, "Found matching affinity!");
                      return r;
                  }
              } else if (r.task.intent != null
                      && r.task.intent.getComponent().equals(cls)) {
                  //Slog.i(TAG, "Found matching class!");
                  //dump();
                  //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
                  return r;
              } else if (r.task.affinityIntent != null
                      && r.task.affinityIntent.getComponent().equals(cls)) {
                  //Slog.i(TAG, "Found matching class!");
                  //dump();
                  //Slog.i(TAG, "For Intent " + intent + " bringing to top: " + r.intent);
                  return r;
              }
          }
      }
  
      return null;
  }
  
  
  private final HistoryRecord resetTaskIfNeededLocked(HistoryRecord taskTop,
          HistoryRecord newActivity) {
      // sunway:
      // resetTaskIfNeeded, 是RESET_TASK_IF_NEED intent flag导致的调用
      // launcher在启动activity时会使用NEW_TASK & RESET_TASK_IF_NEED 标志
      // 所以该标志和launch有关, 实际上, activity的四个属性:
      // 1. CLEAR_TASK_ON_LAUNCH
      // 2. FINISH_ON_TASK_LAUNCH
      // 3. ALLOW_TASK_REPARENTING
      // 4. ALWAYS_RETAIN_TASK_STATE
      // 都只是和这个标志有关
      // 另外, CLEAR_WHEN_TASK_RESET intent flag 也只和这个标志有关.
      // Q: RESET_TASK是干什么?
      // Q: IF_NEEDED是什么意思?
  
      boolean forceReset = (newActivity.info.flags
              &ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
  
      // sunway:
      // ACTIVITY_INACTIVE_RESET_TIME 为 30 分钟
      // 当task.getInactiveDuration > 30 min时, 表示该task需要被forceReset了, 这也
      // 许就是IF_NEEDED的要表达的意思(之一)?
  
  
      if (taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME) {
          if ((newActivity.info.flags
                  &ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0) {
              // sunway:
              // 若root activity设置了这个属性,可以避免空闲30分钟后整个task被
              // reset (reset case 1)
              // 但对case 2,3 无效
              forceReset = true;
          }
      }
  
      // sunway:
      // 所谓 reset task, 是指要从当前task中找出哪些activity需要被reset
      // (finish), 主要分为三种情况:
      // case 1. 整个task的所有activity被需要被reset
      // case 2. 某个或某些activity需要被reset
      // case 3. 还要考虑更复杂的ALLOW_TASK_REPARENTING属性
  
      final TaskRecord task = taskTop.task;
  
      // We are going to move through the history list so that we can look
      // at each activity 'target' with 'below' either the interesting
      // activity immediately below it in the stack or null.
      HistoryRecord target = null;
      int targetI = 0;
      int taskTopI = -1;
      int replyChainEnd = -1;
      int lastReparentPos = -1;
  
      // sunway:
      // 遍历mHistory的所有activity, top --> bottom
  
      for (int i=mHistory.size()-1; i>=-1; i--) {
          HistoryRecord below = i >= 0 ? (HistoryRecord)mHistory.get(i) : null;
  
          if (below != null && below.finishing) {
              continue;
          }
          if (target == null) {
              target = below;
              targetI = i;
              // If we were in the middle of a reply chain before this
              // task, it doesn't appear like the root of the chain wants
              // anything interesting, so drop it.
              replyChainEnd = -1;
              continue;
          }
  
          final int flags = target.info.flags;
  
          // sunway:
          // 当前activity需要被finish on task launch?
          // IF_NEEDED (之二)?
  
          final boolean finishOnTaskLaunch =
              (flags&ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
          final boolean allowTaskReparenting =
              (flags&ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
  
          if (target.task == task) {
              // sunway:
              // 我们只能reset要reset的task, 其他的task不能碰
  
              // We are inside of the task being reset...  we'll either
              // finish this activity, push it out for another task,
              // or leave it as-is.  We only do this
              // for activities that are not the root of the task (since
              // if we finish the root, we may no longer have the task!).
              if (taskTopI < 0) {
                  taskTopI = targetI;
              }
              if (below != null && below.task == task) {
                  final boolean clearWhenTaskReset =
                          (target.intent.getFlags()
                                  &Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
                  if (!finishOnTaskLaunch && !clearWhenTaskReset && target.resultTo != null) {
                      // If this activity is sending a reply to a previous
                      // activity, we can't do anything with it now until
                      // we reach the start of the reply chain.
                      // XXX note that we are assuming the result is always
                      // to the previous activity, which is almost always
                      // the case but we really shouldn't count on.
                      if (replyChainEnd < 0) {
                          replyChainEnd = targetI;
                      }
                  } else if (!finishOnTaskLaunch && !clearWhenTaskReset && allowTaskReparenting
                          && target.taskAffinity != null
                          && !target.taskAffinity.equals(task.affinity)) {
  
                      // sunway:
                      // 若当前处理的activity是从别的地方`收养`的
                      // (allowTaskReparenting为真,且它的affinity和要reset的
                      // task的affinity不同), 而且它不想死,那么放了它(从哪来的
                      // 回哪去,或者自立门户)
                      //
                      //
                      // If this activity has an affinity for another
                      // task, then we need to move it out of here.  We will
                      // move it as far out of the way as possible, to the
                      // bottom of the activity stack.  This also keeps it
                      // correctly ordered with any activities we previously
                      // moved.
                      HistoryRecord p = (HistoryRecord)mHistory.get(0);
                      if (target.taskAffinity != null
                              && target.taskAffinity.equals(p.task.affinity)) {
                          // If the activity currently at the bottom has the
                          // same task affinity as the one we are moving,
                          // then merge it into the same task.
                          target.task = p.task;
                          if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
                                  + " out to bottom task " + p.task);
                      } else {
                          mCurTask++;
                          if (mCurTask <= 0) {
                              mCurTask = 1;
                          }
                          target.task = new TaskRecord(mCurTask, target.info, null,
                                  (target.info.flags&ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0);
                          target.task.affinityIntent = target.intent;
                          if (DEBUG_TASKS) Slog.v(TAG, "Start pushing activity " + target
                                  + " out to new task " + target.task);
                      }
                      mWindowManager.setAppGroupId(target, task.taskId);
                      if (replyChainEnd < 0) {
                          replyChainEnd = targetI;
                      }
                      int dstPos = 0;
                      for (int srcPos=targetI; srcPos<=replyChainEnd; srcPos++) {
                          p = (HistoryRecord)mHistory.get(srcPos);
                          if (p.finishing) {
                              continue;
                          }
                          if (DEBUG_TASKS) Slog.v(TAG, "Pushing next activity " + p
                                  + " out to target's task " + target.task);
                          task.numActivities--;
                          p.task = target.task;
                          target.task.numActivities++;
                          mHistory.remove(srcPos);
                          mHistory.add(dstPos, p);
                          mWindowManager.moveAppToken(dstPos, p);
                          mWindowManager.setAppGroupId(p, p.task.taskId);
                          dstPos++;
                          if (VALIDATE_TOKENS) {
                              mWindowManager.validateAppTokens(mHistory);
                          }
                          i++;
                      }
                      if (taskTop == p) {
                          taskTop = below;
                      }
                      if (taskTopI == replyChainEnd) {
                          taskTopI = -1;
                      }
                      replyChainEnd = -1;
                      addRecentTaskLocked(target.task);
                  } else if (forceReset || finishOnTaskLaunch
                          || clearWhenTaskReset) {
  
                      // sunway:
                      // 经过若干次循环后,确定了要reset的activity的范围,开始reset
                      // 其中, CLEAR_WHEN_TASK_RESET和CLEAR_TOP行为相似,都使
                      // 该activity以上被finish,但前者会限制上限为当前task
  
                      // If the activity should just be removed -- either
                      // because it asks for it, or the task should be
                      // cleared -- then finish it and anything that is
                      // part of its reply chain.
                      if (clearWhenTaskReset) {
                          // In this case, we want to finish this activity
                          // and everything above it, so be sneaky and pretend
                          // like these are all in the reply chain.
                          replyChainEnd = targetI+1;
                          while (replyChainEnd < mHistory.size() &&
                                  ((HistoryRecord)mHistory.get(
                                              replyChainEnd)).task == task) {
                              replyChainEnd++;
                          }
                          replyChainEnd--;
                      } else if (replyChainEnd < 0) {
                          replyChainEnd = targetI;
                      }
                      HistoryRecord p = null;
                      for (int srcPos=targetI; srcPos<=replyChainEnd; srcPos++) {
                          p = (HistoryRecord)mHistory.get(srcPos);
                          if (p.finishing) {
                              continue;
                          }
                          if (finishActivityLocked(p, srcPos,
                                  Activity.RESULT_CANCELED, null, "reset")) {
                              replyChainEnd--;
                              srcPos--;
                          }
                      }
                      if (taskTop == p) {
                          taskTop = below;
                      }
                      if (taskTopI == replyChainEnd) {
                          taskTopI = -1;
                      }
                      replyChainEnd = -1;
                  } else {
                      // If we were in the middle of a chain, well the
                      // activity that started it all doesn't want anything
                      // special, so leave it all as-is.
                      replyChainEnd = -1;
                  }
              } else {
                  // Reached the bottom of the task -- any reply chain
                  // should be left as-is.
                  replyChainEnd = -1;
              }
  
          } else if (target.resultTo != null) {
              // If this activity is sending a reply to a previous
              // activity, we can't do anything with it now until
              // we reach the start of the reply chain.
              // XXX note that we are assuming the result is always
              // to the previous activity, which is almost always
              // the case but we really shouldn't count on.
              if (replyChainEnd < 0) {
                  replyChainEnd = targetI;
              }
  
          } else if (taskTopI >= 0 && allowTaskReparenting
                  && task.affinity != null
                  && task.affinity.equals(target.taskAffinity)) {
              // sunway:
              // 如果其它task中有从当前task`过继`过去的activity, 那么也会reset
              // 它,或者会把它move回当前task (根据IF_NEEDED)
  
              // We are inside of another task...  if this activity has
              // an affinity for our task, then either remove it if we are
              // clearing or move it over to our task.  Note that
              // we currently punt on the case where we are resetting a
              // task that is not at the top but who has activities above
              // with an affinity to it...  this is really not a normal
              // case, and we will need to later pull that task to the front
              // and usually at that point we will do the reset and pick
              // up those remaining activities.  (This only happens if
              // someone starts an activity in a new task from an activity
              // in a task that is not currently on top.)
              Slog.e("sunway", "AMS:206");
              if (forceReset || finishOnTaskLaunch) {
                  Slog.e("sunway", "AMS:208");
                  if (replyChainEnd < 0) {
                      replyChainEnd = targetI;
                  }
                  HistoryRecord p = null;
                  for (int srcPos=targetI; srcPos<=replyChainEnd; srcPos++) {
                      p = (HistoryRecord)mHistory.get(srcPos);
                      if (p.finishing) {
                          continue;
                      }
                      Slog.e("sunway", "AMS:218");
                      if (finishActivityLocked(p, srcPos,
                              Activity.RESULT_CANCELED, null, "reset")) {
                          taskTopI--;
                          lastReparentPos--;
                          replyChainEnd--;
                          srcPos--;
                      }
                  }
                  replyChainEnd = -1;
              } else {
                  Slog.e("sunway", "AMS:229");
                  if (replyChainEnd < 0) {
                      replyChainEnd = targetI;
                  }
                  for (int srcPos=replyChainEnd; srcPos>=targetI; srcPos--) {
                      HistoryRecord p = (HistoryRecord)mHistory.get(srcPos);
                      if (p.finishing) {
                          continue;
                      }
                      if (lastReparentPos < 0) {
                          lastReparentPos = taskTopI;
                          taskTop = p;
                      } else {
                          lastReparentPos--;
                      }
                      mHistory.remove(srcPos);
                      p.task.numActivities--;
                      p.task = task;
                      mHistory.add(lastReparentPos, p);
                      if (DEBUG_TASKS) Slog.v(TAG, "Pulling activity " + p
                              + " in to resetting task " + task);
                      task.numActivities++;
                      mWindowManager.moveAppToken(lastReparentPos, p);
                      mWindowManager.setAppGroupId(p, p.task.taskId);
                      if (VALIDATE_TOKENS) {
                          mWindowManager.validateAppTokens(mHistory);
                      }
                  }
                  replyChainEnd = -1;
  
                  // Now we've moved it in to place...  but what if this is
                  // a singleTop activity and we have put it on top of another
                  // instance of the same activity?  Then we drop the instance
                  // below so it remains singleTop.
                  if (target.info.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
                      for (int j=lastReparentPos-1; j>=0; j--) {
                          HistoryRecord p = (HistoryRecord)mHistory.get(j);
                          if (p.finishing) {
                              continue;
                          }
                          if (p.intent.getComponent().equals(target.intent.getComponent())) {
                              if (finishActivityLocked(p, j,
                                      Activity.RESULT_CANCELED, null, "replace")) {
                                  taskTopI--;
                                  lastReparentPos--;
                              }
                          }
                      }
                  }
              }
          }
  
          target = below;
          targetI = i;
      }
  
      return taskTop;
      // sunway:
      // 总结:
      // RESET_TASK是指有些activity会被finish,有些会被move (ALLOW_TASK_REPARENTING)
      // IF_NEEDED因为有三层含义:
      //   1. task inactive超过30 min后会被CLEAR_TASK_ON_LAUNCH
      //   2. 有些activity若设置了FINISH_ON_TASK_LAUNCH属性或有
      //      CLEAR_WHEN_TASK_RESET intent flag, 会被finish
      //   3. 有些activity若设置了ALLOW_TASK_REPARENTING, 会被moved, 或者被finish
      // 一般只有launcher会 reset task
  }
#+END_EXAMPLE
***** analysis
#+BEGIN_EXAMPLE
      startActivityUnchecked(HistoryRecord r, HistoryRecord sourceRecord, ...)
      // r is the activity to be start; sourceRecord is the activity that issues the startActivity, for notification, service..., sourceRecord is null
        if (sourceRecord==null):
	// This activity is not being started from another...  in this case, always start new task
	  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
        else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
	// original Activity is SINGLE_INSTANCE launchMode
	  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;
	else if (r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE
	         or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
	  launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK;

	if (r.resultTo != null && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
	  // NEW_TASK is set, but requires Activity result, so just cancel the result
          sendActivityResultLocked(-1,...)

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (((launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0 ...):
	  HistoryRecord taskTop=findTaskLocked(intent, r.info);
	     // find the target task complies with r, according to affinity, compnent, .... from mHistory, top --> bottom
	     // findTaskLocked will return the top activity in any existing task matching the given intent
	     // typically, the search will compare taskAffinity, but sometimes, taskAffinity could be null, if so, componentName is considered
	     // How taskAffinity is null? if activity's taskAffinity property is set to "" (see `Notification`), then it's taskAffinity will be set to null
	  if (taskTop!=null):
	  // found an target task, may try to foreground the task
	  // else jump to endif of ..launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK..
	    HistoryRecord curTop = topRunningNonDelayedActivityLocked(notTop);
	    // find the current top activity's task
	    if (curTop.task != taskTop.task):
	    // target task is in background, will try to foreground target task, unless ...
	      boolean callerAtFront = sourceRecord == null  || curTop.task == sourceRecord.task;
	      // whether the startActivity action is issued from an obscured activity
	      // we prefer that an obscured activity can't moveTaskToFront
	      if (callerAtFront):
	        moveTaskToFrontLocked(taskTop.task, r);
		// move all the activities belonging to target task to the top of mHistory
	      if ((launchFlags&Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0):
	        // reset task if need, another dragon~
	        taskTop = resetTaskIfNeededLocked(taskTop, r);
            if ((launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0
                 or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK
                 or r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE):
	      HistoryRecord top = performClearTaskLocked(taskTop.task.taskId, r, launchFlags, true);
	      // clear the *mHistory* from top to the target *artivity*
	      // note that: if target is successfully moved to front beforehand,
	      // clearTask will actually only clear the target task, instead of the whole mHistory
	        // for each activity from mHistory.top downto target activity, finish it!
		// for the target activity, if it has the SINGLE_TOP flag, do nothing and return it, else finish it!
	      if (top!=null):
	        // target activity has the SINGLE_TOP flag, thus not finished
		deliverNewIntentLocked(top, r.intent);
	      else:
	        // target activity has been finished, place a new one on the task
		addingToTask = true;  // future actions will be taken if addingToTask is true, which means we need add the target activity to target task
		                      // addingToTask means `startNewActivity`
	    else if (r.realActivity.equals(taskTop.task.realActivity)): // else of clear_top
	      // In this case the top activity on the task is the
              // same as the one being launched, so we take that
              // as a request to bring the task to the foreground.
	      if (!r.intent.filterEquals(taskTop.task.intent)):
	      // we are trying to restart target task's root activity, but with a different intent, we should start a new instance on top
	      // else, do nothing (since the target task is already brought to front)
	        addingToTask = true;
            // if CLEAR_TOP ends here
	    if (!addingToTask):
	    // new instance should not be started, e.g. CLEAR_TOP will SINGLE_TOP; starting target task's root activity with the same intent
	      resumeTopActivity()
	      return;
	// if NEW_TASK end here

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// when we reach here:
	// 1. activity w/o NEW_TASK
	// 2. activity w/ NEW_TASK but doesn't found the target task

        HistoryRecord top = topRunningNonDelayedActivityLocked(notTop);
	if (top.realActivity.equals(r.realActivity)):
	  if ((launchFlags&Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0
	    or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP
            or r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK):
	      resumeTopActivityLocked(null);
	      deliverNewIntentLocked(top, r.intent);
	      return;
	if (!addingToTask  && (launchFlags&Intent.FLAG_ACTIVITY_NEW_TASK) != 0):
	  // case 2.
          r.task = new TaskRecord(mCurTask, r.info, intent,...)
	else if (!addingToTask && (launchFlags&Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0):
	  // case 1.
	  HistoryRecord top = performClearTaskLocked(sourceRecord.task.taskId, r, launchFlags, true);
	  if (top != null):
	    deliverNewIntentLocked(top, r.intent);
	    return;
	else if (!addingToTask && (launchFlags&Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0):
	  // case 1.
	  // In this case, we are launching an activity in our own task
          // that may already be running somewhere in the history, and
          // we want to shuffle it to the front of the stack if so.
	  int where = findActivityInHistoryLocked(r, sourceRecord.task.taskId);
	    // if sourceRecord.task is not the top task in mHistory, return -1, else return the index of r in mHistory
	  HistoryRecord top = moveActivityToFrontLocked(where);
          deliverNewIntentLocked(top, r.intent);
          resumeTopActivityLocked(null);
	  return;
        // if NEW_TASK ends here

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// all launchMode and flag is considered, if control flow still reach here ... startActivity!
	startActivityLocked(r, newTask, doResume);
	return;
#+END_EXAMPLE
      simplified procedure:

#+BEGIN_EXAMPLE
      if NEW_TASK:
        if found target task:
          moveTaskToFront()
	  clearTop
	  starting with the same intent with target task?
      single_top
      new task
      clear_top
      reorder_to_front
      startActivity
#+END_EXAMPLE

      To summarize:
      1. FLAG\_ACTIVITY\_NEW\_TASK may be set implicitly, e.g.
	 - starting activity from service, notification ..., where sourceRecord==null
	 - target activity is SINGLE\_INSTANCE, SINGLE\_TASK
	 - sourceRecord is in SINGLE\_INSTANCE
      2. FLAG\_ACTIVITY\_NEW\_TASK has two means:
	 1. if target task exists: `moveTaskToFront`
	 2. if not: start new task
      3. moveTaskToFront must meet 3 conditions:
	 1. NEW\_TASK
	 2. target task exists and is in background
	 3. sourceRecord is null or sourceRecord is the top activity,
	    that is, only notification, service and curTop activity can move a background task to front through NEW\_TASK
      4. CLEAR\_TOP
	 CLEAR\_TOP will clear all the activities in *mHistory* on top of target activity, so  CLEAR\_TOP should be used in two ways:
	 1. in most cases, CLEAR\_TOP should be used in conjunction with NEW\_TASK, so that, before clear top, the target task is moveTaskToFront,
	    thus the succeeding CLEAR\_TOP will be restrict to the target task
	 2. CLEAR\_TOP can be used w/o NEW\_TASK, but make sure the sourceRecord is the foreground task, or else all the activities on top of it will
	    be finished.
      5. REORDER\_TO\_FRONT
	 1. should *ONLY* be called by foreground task, or else the flag will not take effect
	 because CLEAR\_TOP condition is judged before REORDER\_TO\_FRONT, so if CLEAR\_TOP is set, REORDER\_TO\_FRONT is ignored
	 What's more: REORDER\_TO\_FRONT will only take effect if NEW\_TASK
      6. deliverNewIntent
	 deliverNewIntent will occurs in two cases:
	 1. SINGLE\_TOP, w/ or w/o NEW\_TASK
	 2. REORDER\_TO\_FRONT
**** Launcher & Task 
**** resetTaskIfNeededLocked
      FLAG\_ACTIVITY\_NEW\_TAKS && FLAG\_ACTIVITY\_RESET\_TASK\_IF\_NEEDED will trigger resetTaskIfNeededLocked

      Typically, only launcher will set those two flags to resetTaskIfNeededLocked, but we still can set those flags manually to
      trigger resetTaskIfNeededLocked

#+BEGIN_EXAMPLE
      resetTaskIfNeededLocked
        // whether the launching activity has the property `CLEAR_TASK_ON_LAUNCH`
        boolean forceReset = (newActivity.info.flags &ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH) != 0;
	// if the target task has been inactive for ACTIVITY_INACTIVE_RESET_TIME (30 min)
	// and the target's *root* activity doesn't have the ALWAYS_RETAIN_TASK_STATE property, also set forceReset to true
	// that is what the phrase `IfNeed` means
	if (taskTop.task.getInactiveDuration() > ACTIVITY_INACTIVE_RESET_TIME):
          if ((newActivity.info.flags &ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE) == 0):
            forceReset = true;
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	foreach HistoryRecord of the target task in mHistory (from top --> bottom):
	  // should the activity be finished on task launch?
	  boolean finishOnTaskLaunch = (flags&ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH) != 0;
	  // should the activity has ALLOW_TASK_REPARENTING property?
          boolean allowTaskReparenting = (flags&ActivityInfo.FLAG_ALLOW_TASK_REPARENTING) != 0;
	  // should the activity clear it's top when task reset?
          boolean clearWhenTaskReset = (target.intent.getFlags()&Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0;
	  if (!finishOnTaskLaunch && !clearWhenTaskReset && allowTaskReparenting
	      && !target.taskAffinity.equals(task.affinity)):
	    // if the activity is ALLOW_TASK_REPARENTING and it's affinity is different with target task ...
	    // that is , the activity is reparent from somewhere else ... , so detach it, instead of kill it.
	    // however, ALLOW_TASK_REPARENTING can only overide forceReset: finishOnTaskLaunch and clearWhenTaskReset can still kill it.
	    // ALLOW_TASK_REPARENTING is flexible: it can be attached/detached from a TO-BE-RESET task.
	  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	  if (forceReset || finishOnTaskLaunch || clearWhenTaskReset ):
	    if (clearWhenTaskReset):
	      // finish all the actvities of the target task above the launching activity.
	    finish current activity
	  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
          else if (taskTopI >= 0 && allowTaskReparenting && task.affinity.equals(target.taskAffinity)):
	    // We are inside of another task...  if this activity has an affinity for our task, then either remove it if we are
            // clearing or attach it to our task
#+END_EXAMPLE

      To summarize:
      - CLEAR\_TASK\_ON\_LAUNCH property will clear the task when re-launch the task from launcher, (only meaningful for root activity)
      - if task has been inactive for 30 min, it will also be CLEAR\_TASK\_ON\_LAUNCH, unless RETAIN\_TASK\_STATE property is set
	RETAIN\_TASK\_STATE is closely related to the 30 min thresh-hold, (only meaningful for root activity)
      - FINISH\_ON\_TASK\_LAUNCH property vs. CLEAR\_WHEN\_TASK\_RESET intent flag (not only meaningful for root activity)
      - ALLOW\_TASK\_REPARENTING is flexible: it can be detached/attached from a TO-BE-RESET task

**** affinity
      2010-11-15
      1. One task's affinity is the root activity's task affinity.
      2. activity's task affinity, if not specified in manifest, is set to the activity's package name, by default.
      3. activity's task affinity can be *null*:
	 if activity's taskAffinity property is set to "" (see [[Notification]]), then it's taskAffinity will be set to null
      4. Affinity will affect activity in two ways:
	 1. When activity A calls startActivity(B) to start B activity, B will be
	    put into the same task as A, but if the calling intent set the flag
	    FLAG_NEW_TASK
	    2. if there is already ONE task whose affinity is identical with B's
               affinity (including the origina task), B will be put into that
               task. so, if orig task's affinity is the same as B's affinity,B will still be placed into the orig task
	    3. if there is no task whose affinity is identical with B's
               affinity, B will be put into a new task. So the FLAG_NEW_TASK is
               a little ambiguous, maybe it should be named
               FLAG_NEW_OR_EXIST_TASK.
	 2. If A call startActivity(B) to start B activity, and the calling
	   task's affinity is same as B's affinity, and B has set the activity
	   property: AllowTaskReparenting, then B will be `reparented` to the
	   calling task.
**** launch mode
***** standard
***** singleTop
***** singleInstance
***** singleTask
**** Intent flag
***** FLAG_ACTIVITY_NEW_TASK
***** FLAG_ACTIVITY_CLEAR_TOP
***** FLAG_ACTIVITY_SINGLE_TOP
***** FLAG_ACTIVITY_REORDER_TO_FRONT
***** FLAG_ACTIVITY_RESET_TASK_IF_NEEDED [launch related]
***** FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET [launch related]
       stronger CLEAR_TOP?
***** FLAG_ACTIVITY_MULTIPLE_TASK
***** FLAG_ACTIVITY_FORWARD_RESULT
***** FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
**** Properties
***** FINISH_ON_TASK_LAUNCH  [launch related]
***** CLEAR_TASK_ON_LAUNCH  [launch related]
activity must be taks's root activity
***** ALLOW_TASK_REPARENTING
***** ALWAYS_RETAIN_TASK_STATE
**** moveTaskToBack
**** isTaskRoot
** Service                                                         :service:
*** startService
#+BEGIN_EXAMPLE
	startServiceLocked()
	   retrieveServiceLocked()
	     checkComponentPermission()
	   bringUpServiceLocked()
	      if serviceRecord.app and app.thread is not null,
	           sendServiceArgs()
	              thread.scheduleServiceArgs()
	                  service.onStartCommand()
	       else
	           getProcessRecord(appName)
	           if app or thread is not null (process is ready)
	               realStartService()
	                  thread.scheduleCreate..
	           else
	               startProcess()
	                  start ActivityThread
	               add service to mPendingSer..
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  New process:
    ActivityThread::attach()
      AMS::attachApplication()
        foreach mPendingServices:
          realStartService()
            thread.scheduleCreate..
#+END_EXAMPLE
*** bindService &  unbindService
**** ServiceConnection
      ServiceConnection itself is binder proxy, which only implement one method:
#+BEGIN_EXAMPLE
      void connected(ComponentName name, IBinder service) throws RemoteException;
#+END_EXAMPLE
      through ServiceConnection.connected(), service can notify the *client* about service bound/unbound.

      so the client must implement the ServiceConnection stub, actually, ActivityThread maintains one
#+BEGIN_EXAMPLE
      HashMap<Context, HashMap<ServiceConnection, ServiceDispatcher>> mServices
#+END_EXAMPLE
      while ServiceDispatcher maintains the ServiceConnection stub. AMS will notify the client directly through ServiceConnection stub in ActivityThread
      To summarize:
	 1. ServiceConnection is a stub implement in ActivityThread, AMS use it to notify client
	 2. ServiceConnection are maintained by ActivityThread, Activity.destroy will not affect the connection.
**** bindService
#+BEGIN_EXAMPLE
      int bindService(IServiceConnection connection,...);; connection is the binder proxy supplied by client
        mServiceConnections.put(binder, c); ;; AMS save the proxy for later use
         if ((flags&Context.BIND_AUTO_CREATE) != 0):  ;; if BIND_AUTO_CREATE flag is set, will bring up the service
           bringUpServiceLocked(s, service.getFlags(), false);
	     ;; may start process --> create service --> start service ...
           return 0;
         if (s.app != null && b.intent.received):
	   connection.connected(s.name, b.intent.binder); ;; notify client by onServiceConnected
#+END_EXAMPLE
**** unbindService
#+BEGIN_EXAMPLE
        mServiceConnections.remove(connection);
        s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());
	if ((c.flags&Context.BIND_AUTO_CREATE) != 0):
          bringDownServiceLocked(s, false);
	    if (!force && r.startRequested):  // startService will set r.startRequested to true, that why unbindService won't bring down service if it is
	                                      // started by startService
              return;
	    if (r.connections.size() > 0):
	      for each connection:
                if ((cr.flags&Context.BIND_AUTO_CREATE) != 0):  // if there is still any other connection that is BIND_AUTO_CREATE,
		                                                  // skip bring down the service
                  return;
	      for each connection:
                c.conn.connected(r.name, null);   // service is about to be brought down, notify all connections through onServiceDisconnected
	  r.app.thread.scheduleStopService(r);
#+END_EXAMPLE
	To summarize:
	  unbindService will normally stop service, unless:
	     1. the connection is not a BIND_AUTO_CREATE connection
	     2. service is started by startService
	     3. that are still other BIND_AUTO_CREATE connections bound to the service
*** ServiceRecord
d12/28/10 8:12 pm
similar with AMS::HistoryRecord. mainly save the r.ap and r.app.thread so as to interact with the service's process. .  But there is no correspondant like ActivityRecord in ActivityThread, since service needn't interqact with WMS, and it's life cycle is quite simple. (create, start, stop)
*** STICKY service
STICKY mainly make sense when process has crashed due to uncaught exception.
see also [[Android Process Crash and Restart]]
** Broadcast                                                     :broadcast:
*** OrderedBroadcast
**** AbortBroadcast()
**** GetResult..()
**** priority
broadcast receiver's intent filter's `priority` will be used to by the AMS to determine the order in which the broadcast is send to
**** SetResult..()
*** protected-broadcast
PACKAGE_REMOVED/PACKAGE_ADDED/BOOT_COMPLETED are all protected-broadcasts, only the process with "system" uid can send the broadcast
#+BEGIN_EXAMPLE
     broadcastIntentLocked()
       if (callingUid == Process.SYSTEM_UID || callingUid == Process.PHONE_UID || callingUid == Process.SHELL_UID || callingUid == 0) :
         // Always okay.
       else:
         if (ActivityThread.getPackageManager().isProtectedBroadcast(intent.getAction())) :
	   throw new SecurityException(msg);
#+END_EXAMPLE

To summarize: 

`protected-broadcasts` means `those broadcasts can only
be sent by SYSTEM,PHONE,SHELL or root`

*** SendBroadcast
every call to sendBroadcast will init a new receiver instance.
#+BEGIN_EXAMPLE
  AMS:broadcastIntentLocked()
    // find out who will recv this broadcast
    if intent.getComponent():
      receivers.add(r);
    else:
      if !Intent.FLAG_RECEIVER_REGISTERED_ONLY:
        receivers=PM.queryIntentReceivers();
      registeredReceivers = ReceiverResolver.queryIntent(); ;;ReceiverResolver is a in-memory storage that stores runtime-registered receivers
    // now, `receivers` stores receivers from PM, `registeredReceivers` stores receivers from ReceiverResolver
    if !ordered:
      BroadcastRecord r=new BroadcastRecord(registeredReceivers);
      mParallelBroadcasts.add(r);
      add/update mStickyBroadcasts if the broadcast is STICKY 
      ;; note: mStickyBroadcasts is only re-broadcasted on registerReceiver()
      scheduleBroadcastsLocked()
        sendMessage(BROADCAST_INTENT_MSG);
          processNextBroadcast();
            foreach BroadcastRecord in mParallelBroadcasts:
              foreach receiver in BroadcastRecord:
                deliverToRegisteredReceiver();
                  ;; make sure receiver has the requiredPermission imposed by the sender,  e.g. PERMISSION_BOOT_COMPLETED, sender can imposed a
                  ;; requiredPermission through sendBroadcast(intent,requiredPermission)
                  if r.requiredPermission!=null:
                    checkComponentPermission(r.requiredPermission,filter.receiverList.pid, filter.receiverList.uid, -1);
                  ;; make sure the sender has the requiredPermission imposed by the receiver's filter
                  if filter.requiredPermission != null:
                    checkComponentPermission(filter.requiredPermission,r.callingPid, r.callingUid, -1);
                  performReceive();
                    if app.thread !=null:
                      app.thread.scheduleRegisteredReceiver();
                        ReceiverDispatcher.performReceive() ;; for registeredReceivers, receiver class are identified by ReceiverDispatcher (which is send to
                                                            ;; AMS during registerReceiver()
                          new Args() {
                            run():
                              receiver.onReceive();
                              if ordered:
                                AMS:finishReceiver(); ;; not called here
                          }
                          H.post(Args);
      registeredReceivers=null; ;; since registeredReceivers is broadcasted already as mParallelBroadcasts, it should not be merged with receivers
    ;; if  !ordered, registeredReceivers are broadcasted all at once, without TIMEOUT consideration! SO, registeredReceivers in non-ordered broadcast
    ;; will never cause ANR!
    ;; if ordered, both registeredReceivers and receivers are merged in a single list, so that both registeredReceivers and receivers are broadcasted in
    ;; order
    merge_into_one_receiver_list();
    scheduleBroadcastsLocked();
      sendMessage();
        processNextBroadcast();
          r=OrderedBroadcast.get(0);
          if r.nextReceiver>r.receivers.size():
            removeMessages(BROADCAST_TIMEOUT_MSG);
          r.receiverTime=now();
          if current receiver is the first one of r:
            sendMessageAtTime(BROADCAST_TIMEOUT_MSG,r.receiverTime+BROADCAST_TIMEOUT);
          if current receiver is a registeredReceivers:
            scheduleBroadcastsLocked(get Current Receiver); ;; direct call
          else:
            if app!=null:
              app.thread.scheduleReceiver();
                handlerReceiver()
                  receiver = (BroadcastReceiver)cl.loadClass(component).newInstance(); ;; for static receivers, receivers are identified by component name
                  receiver.onReceive(context.getReceiverRestrictedContext(),...)
                  AMS:finishReceiver(); ;; notify AMS that it can process next broadcast.
            else:
              startProcess();
              mPendingBroadcast=r; ;; mPendingBroadcast will broadcasted when process is ready and attached to AMS
  
     BROADCAST_TIMEOUT_MSG's handle Message() will check whether r.receiverTime is updated, if so, that means one of Ra's receiver has returned, so
     handler will not cause an ANR
#+END_EXAMPLE
To summarize:
   1. dynamic registered receiver
      *the same BroadcastReceiver instance is used for Multi-broadcast*
      - in non-ordered broadcast
	1. doesn't cause ANR
	2. all dynamic receivers are invoked in parallel manner (by ActivityThread's handler), i.e. one receiver's onReceive() will not block another
	   receiver's correspondent.
      - in ordered broadcast
	ANR and parallel/serial manner is the same as static registered receivers

   2. static registered receiver
      *every time broadcast is received, a new static registered receiver instance is initiated*
      - always invoked in a serial manner, i.e. one static receiver's onReceive() will block other static receiver's correspondents, no matter
	whether it is ordered. (maybe because static receiver's process is not assumed to be running, AMS need a simplified way to start all the processes)
   3. for a certain broadcast, the ANR timing begins when the first receiver is about to be handled, and ends when the last receiver has been handled,
      and, what's most important: take one broadcast contains 10 static receivers for example, _the total ANR timing can be 10*10s at most_, instead of 10s.
      because although the BROADCAST_TIMEOUT is set to be 10s, every receiver will update r.receiverTime in AMS.finishReceiver(), and the timeout handler
      will issues an ANR only when *now-r.receiverTime > BROADCAST_TIMEOUT (10s)*

   4. sendBroadcast will make sure both the sender and the receiver has been granted the requiredPermission imposed by the counterpart.
      see also protected-broadcast for another sendBroadcast limitation.

   5. Intent.FLAG_RECEIVER_REGISTERED_ONLY
*** BroadcastRecord
*** Sticky
** ProcessRecord
*** processName
** AppDeathRecipient
see also [[binder's death]]
see also [[Android Process Crash and Restart]]
** ActivityThread
ActivityThread stands for the client (contract to AMS) side *process*.

Actually, the class itself is not a Thread at all. It is a normal java
class, and has ONE main(), which act as the entry point of a java
process. 

#+BEGIN_EXAMPLE
  ActivityThread.main()
    Looper.prepare()
    ActivityThread thread = new ActivityThread();
    thread.attach(false);
    Looper.loop();
#+END_EXAMPLE

that is ,
  - ActivityThread.main() will start loop in the main thread, the
    looper is the so-call `mainLooper`

  - thread.attach() will:
    - establish reverse connection (AMS --> ActivityThread) with AMS,
      (set IApplicationThread IBinder to AMS.app.thread), so that AMS
      can use the IApplicationThread to interact with ActivityThread,
      e.g. scheduleResumeaCtivity, scheduleLaunchActivity. AMS use
      [[@AppDeathRecipient]] to reset app.thread to null, which means the
      process has gone.

** What's the `system` process?

简单的说:
1. system 进程是 system_server 所在的进程
2. system 进程是 zygote 启动的第一 个 java 进程
3. system 进程的 ServerThread 负责启动各种 service, 并且是 system 进程
   的 main looper (或 system 进程对应的 activity thread 的looper) 所在
   的线程.
4. system 进程的 oom adj 为 SYSTEM_ADJ, 并且为 persistent, 其在 AMS 登
   记的进程名为 `system`: system 是一个 java 进程, 但它的进程名却有两
   个: ps 显示的是 `system_server`, AMS 里登记的是 `system`
   

*** system 进程及 ActivityThread 的初始化
1. system_server 通过 app_process 被启动 (参考 zygote init)
2. system_server 的一个单独的线程 ServerThread 负责启动各个 service,
   其中包含 AMS
3. AMS.main 会初始化一个 ActivityThread 做为 mSystemThread
   #+BEGIN_SRC text
     AMS.main
       ActivityThread.systemMain()
         ActivityThread thread = new ActivityThread();
         thread.attach(true);
   #+END_SRC
   由于 mSystemThread 初始化在 ServerThread 线程, 所以它使用的 Looper
   就是 ServerThread 的 Looper. (MyLooper 返回一个 ThreadLocal 变量)
4. ServerThread 启动完 AMS 后会调用 AMS.setSystemProcess 方法, 将
   system_server 进程注册到 AMS, 并做为 `system` 进程

   #+BEGIN_SRC text
     ProcessRecord app = mSelf.newProcessRecordLocked(
                           mSystemThread.getApplicationThread(), info,
                           info.processName, false);
     app.persistent = true;
     app.pid = MY_PID; // system_server 的 pid, 1000
     app.maxAdj = ProcessList.SYSTEM_ADJ;
     // app.processName 为 "system" !
     mSelf.mProcessNames.put(app.processName, app.uid, app);
   #+END_SRC

#+TITLE: Android Resource
* Android Resource
** android resource 分类
android/res 目录下定义了各种各样的 resource,  但写法与用法却有所区别,  从直接上
看, 可以分为两类:
1. 静态的资源 (值是不变的)

同时定义了 resID, type, value 的 resource, 例如:

   - colors.xml 中定义的各种颜色
   - strings.xml 中定义的各个字符串
   - drawable 目录下定义的各个图片
   - styles.xml 和 themes.xml 中定义的各个 style
   - config.xml 中定义的各个配置信息
   - layout.xml
   - menu.xml
   - ids.xml

id 是一类特殊的 resource, 它们没有值, 只是利用了它们的 resID 的唯一性. 如果
把 resID 看做它们的值的话, 它们也属于静态的资源.

2.  动态的资源 (值是变化的)

只定义了 resID 和 type, 没有定义值. 这种 resource 定义了一种 可配置的 "属性
".  例如 attrs.xml 中通过 declare-styleable 定义的 style 的各个 attribute.

某些 resource 可以指定这些属性, 例如
   - layout
   - menu
   - style

layout 可以通过 AttributeSet, TypedArray, obtainStyledAttributes 访问其
attribute resource

** LoadedApk
ContextImpl 中有一个重要的成员叫 mPackageInfo, 是一个 LoadedApk 对象, 从名字就可
以看出来, 这个对象是代表着一个 `已加载` 的 APK, 而一个 APK 主要包含三部分信息:

1. AndroidManifest, 这部分在 LoadedApk 中叫做 ApplicationInfo
2. Assets 和 Resources, 这部分被称为 mResDir
3. classes.dex,  这部分通过 LoadedApk 的 mClassLoader 让外部可以访问. 实际上,
   ContextImpl.getClassLoader 返回的就是 LoadedApk.getClassLoader 即 mClassLoader

#+CAPTION: LoadedApk
#+BEGIN_SRC ditaa :file 1.png


        +------------+                          +--------------+
        |  Context   +------------+------------>+  Resources   |
        +-----+------+            |             +-------+------+
              |                   |                     |
              v                   |                     v
      +-------+------+            |             +-----+--------+     +----------------------+
      |  LoadedApk   |            +------------>| AssetManager |-----+ resource related {d} |
      +------+-------+                          +------+-------+     | cGRE                 |
             |                                         ^             +----------------------+
             |                                         |
       +-----+--------+-------------+     +------------+-------------+
       |              |             |     |                          |
       v              |             v     |                          |           b
 +-----+-----------+  |     +-------+-----+-----+       +------------+----------+
 |  Manifest       |  |     | Assets/Resources  |       |   default assets      |
 |(ApplicationInfo)|  |     |     (mResDir)     |       |  (framework-res.apk)  |
 +-----------------+  |     +-------------------+       +-----------+-----------+
                      |                                             |
       +--------------+                                             |
       |                                                            |
       v                                                            |
 +-----+---------+      +-------------------+      +----------------+------------------+
 | classes.dex   |------+  code related {d} |      |    overlay for default assets     |
 |(mClassLoader) |      |  cGRE             |      | (vendor/overlay/framework-res.apk |
 +---------------+      +-------------------+      +-----------------------------------+

#+END_SRC

#+RESULTS:
[[file:1.png]]

** Compile Resource
*** 编译后的 apk 的资源文件布局
原 res 目录下的所有资源文件在通过 aapt 处理后有两种情况:

1. values 下的所有文件, 包括 strings.xml, ids.xml, colors.xml ... 都会被直接保存
   到 resources.arsc 中, 因为这些资源只会对应一下简单的值, 而不需要对应一个 xml
   文件.
2. res 中除 values 的其他资源文件会在 resources.arsc 中生成一些 resID 与 xml 路
   径的对应信息, 用于 getResources 时的查找. 并且这些资源文件会被转换为 axml 格
   式后打包到 apk 中.

*** AXML
axml 指通过 aapt 转换后的一种格式, 类似于 WBXML. 另外, axml 生成过程中也会做一些
资源引用的预处理, 例如下面是被 AXMLPrinter2 dump 出来的 axml 的内容:

#+BEGIN_SRC xml
  <TextView
      android:id="@7F050000"
      android:layout_width="-1"
      android:layout_height="-2"
      android:text="@android:0104000A"
      >
  </TextView>
#+END_SRC

可见, "wrap_content" 被替换为 -1, 而 android:id, android:text 等 resType 为
REFERENCE 的项其内容被提前解析为对应的 resID

** Get Resource
*** Context.getResources
#+BEGIN_SRC java
  ContextImpl.getResources
    return mResources

  ContextImpl.init
    mResources = mPackageInfo.getResources(mainThread);
      // LoadedApk
      mResources = mainThread.getTopLevelResources(mResDir, this);
        // ActivityThread
        AssetManager assets = new AssetManager();
          // AssetManager.java
          init(); // init is a native method, which will attach the C++
                  // AssetManager to the java object, and addDefaultAssets: framework-res.apk
            am->addDefaultAssets();
              addAssetPath("framework/framework-res.apk", NULL);
                mAssetPaths.add(ap);
                // add overlay for defautl assets
                if ap=="framework/framework-res.apk":
                  overlay="/vendor/overlay/framework-res.apk";
                  mAssetPaths.add(overlay);

            env->SetIntField(clazz, gAssetManagerOffsets.mObject, (jint)am);

        assets.addAssetPath(resDir)
          // AssetManager.java
          AssetManager* am = assetManagerForJavaObject(env, clazz);
          am.addAssetPath();
        return new Resources(assets,...);
#+END_SRC

Note that: `Resources` is built on top of `Assets`, that is, `Resources` is a
sort of `Assets`

*** Resource.getText
#+BEGIN_SRC java
  Resource.getText
    mAssets.getResourceText(resID);
      int block = loadResourceValue(resID,...);
      // AssetManager jni
        ResTable& res(am->getResources());
        // am->getResources 会扫描所有的 asset path, 并添加到 ResTable 中
        // 基本过程就是从 asset path 中解析出 resources.arsc 文件, 然后调用 ResTable.add 方法
          am->getResTable();
            N = mAssetPaths.size();
            for i in 1..N:
              Asset ass=get_asset_from_zip_or_directory
              res.add(ass,..,idmap);
              // ResTable
                parsePackage(asset,...)
                  id=pkg.id; // 每个 res apk 中都有一个 id 属性, 一般应用的 id 为 7f, overlay 为 0, android 为 1, extended 为 2
                  idx = mPackageMap[id]; // 第一次 parse pkg.id 为 id 的 res apk 时, idx 必为0
                  if idx==0:
                    idx = mPackageGroups.size()+1;
                    tmpName=pkg.name
                    group = new PackageGroup(this, String16(tmpName), id);
                    mPackageGroups.add(group);
                    mPackageMap[id] = (uint8_t)idx;
                  else:
                    group = mPackageGroups.itemAt(idx-1);
                  group->packages.add(package);
                  // more: parse types
                // parsePackage ends here
              // ResTable.add ends here. after all asset package is added to ResTable, ResTable has generate a Tree-like structure.
        // === jni loadResourceValue
        int block = res.getResource(resID,&value,...);
          // ResTable
          p = getResourcePackageIndex(resID);
            // Res_GETPACKAGE(resID) 是一个宏, 返回 res 最高8位
            // 所以 mPackageMap 是一个 256 长度的数组, 一般情况下, 似乎只有 1 和 7f 是有值的, 因为
            // 一般的 app 只会使用 default assets (resID 均为 01xxxxxx) 和 本 package 的 asset (resID 均为 7fxxxxxx)
            return mPackageMap[Res_GETPACKAGE(resID)+1]-1;

          // Look through all resource packages, starting with the MOST
          // RECENTLY ADDED.
          PackageGroup*  grp = mPackageGroups[p];
          size_t N = grp->packages.size();
          for i in N .. 0:
          // implies `starting with the MOST RECENTLY ADDED`
            if pacakge IS overlay: // pacakge.resourceIdMap!=null
              overlayResId=idmapLookup(package.resourceIdMap,id,..);
              T=Res_GETTYPE(overlayResID);
              E=Res_GETENTRY(overlayResID);
            FIND_BEST_RESOURCE in package
            if bestItem.isMoreSpecificThan(thisConfig):
              bestItem = thisConfig;
              bestPackage = package;
          // for ends here
          return bestPackage->header->index;
        copyValue(env, outValue, &res, value, ref, block, typeSpecFlags, &config);
      // loadResourceValue ends here
      return mStringBlocks[block].get(tmpValue.data);
    // getResourceTexte ends here
#+END_SRC
**** To summaries
- ResTable 是核心的数据结构, 它有两个任务:
  1. 解析 AssetManager 通过 addAssetPath 添加的所有 asset, 并形成一个由
     PackageGroup -> Package -> Type -> Entity ( & Config) 组成的树形结构
  2. 通过在树形结构里查找, 获得和 resID 最匹配的资源
*** LayoutInflater
#+BEGIN_SRC java
  LayoutInflater.inflate(id,rootView)
    // rootView: the view that the inflated view will be attached to, can be null
    XmlResourceParser parser = getContext().getResources().getLayout(resource);
      // Resources.java
      loadXmlResourceParser(id,"layout");
        getValue(id, value, true);
          mAssets.getResourceValue(id, 0, outValue, resolveRefs);
          // AssetManager.java
            int block = loadResourceValue(ident, (short) density, outValue, resolveRefs);
            // similar with AssetManager.getResourceText
            if (outValue.type != TypedValue.TYPE_STRING):
              return true;
            outValue.string = mStringBlocks[block].get(outValue.data);
        // getValue ends here
        // now value.string contains the layout's xml path
        return loadXmlResourceParser(value.string, id, value.assetCookie,type);
          // find the cached XmlBlock according to `ID`
          final int num = mCachedXmlBlockIds.length;
            for (int i=0; i<num; i++):
              if (mCachedXmlBlockIds[i] == id):
                return mCachedXmlBlocks[i].newParser();
          // cache miss
          XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file);
            // native. assetCookie means which package is opened for this XmlBlock
            openXmlAssetNative(cookie, fileName);
          // fill cache
          mCachedXmlBlockIds[pos] = id;
          mCachedXmlBlocks[pos] = block;
          return block.newParser();
      // loadXmlResourceParser ends here
    // now parse the layout xml and inflate the view
    inflate(parser, root, attachToRoot);
      AttributeSet attrs = Xml.asAttributeSet(parser);
      // now attrs contains all the `attr` of the layout, e.g. id, android:layout_height,
      // android:layout_weight, android:text, android:src, or use-defined attr in
      // attr.xml
      String name = parser.getName();
      // get the root tag, e.g. <include> <merge> or <view> ... etc.
      if (TAG_MERGE.equals(name)):
        // if this is a merge, a root view must be supplied
        if (root==null):
          throw new InflateException("<merge /> can be used only with a valid "
            + "ViewGroup root and attachToRoot=true");
        rInflate(parser, root, attrs, false);
      else:
        if (TAG_1995.equals(name)):
          // TAG_1995?
          temp = new BlinkLayout(mContext, attrs);
        else:
          temp = createViewFromTag(root, name, attrs);
            // <view class="xx.xx.xx"
            if (name.equals("view")):
              name = attrs.getAttributeValue(null, "class");
            // else, <xx.xx.xx.xx
            // LayoutInflater.setFactory() can set the mFactory, thought which
            // user can intercept the LayoutInflater, typically, the mFactory is
            // left unset.
            view = mFactory.onCreateView(name, mContext, attrs);
            // mFactory doesn't work
            if (view == null):
              if (-1 == name.indexOf('.')): // creating <ListView ..? get it from framework
                // name contains no `.`? means we are using the system widget, e.g.
                // <ListView, <Button ...
                view = onCreateView(parent, name, attrs);
                  // PhoneLayoutInflater
                  onCreateView(parent, name, attrs)
                    for (String prefix : sClassPrefixList)::
                      // sClassPrefixList? it's values is defined in
                      // PhoneLayoutInflater as: {"android.widget.",
                      // "android.webkit."}
                      View view = createView(name, prefix, attrs);
                      if view!=null:
                        return view
              else: // creating <com.xx.xx.view? leave prefix to null
                view = createView(name, null, attrs);
                  // * Low-level function for instantiating a view by name. This
                  // * attempts toinstantiate a view class of the given <var>name</var>
                  // found in this LayoutInflater's ClassLoader.
                  clazz = mContext.getClassLoader().loadClass(
                            prefix != null ? (prefix + name) : name).asSubclass(View.class);
                  // view class is inited by  mContext.getClassLoader(), and, because we can obtain a LayoutInflater
                  // through LayoutInflater.from(Context), or through Context.getSystemService(),  we can
                  // inflate view from other package

                  // LayoutInflater.Filler ....
                  if (mFilter != null && clazz != null):
                      if (mFilter.onLoadClass(clazz)):
                        failNotAllowed(name, prefix, attrs);
                  // view's ctor will be invoked with two args: context, AttrbuteSet
                  constructor = clazz.getConstructor(new Class[] {
                          Context.class, AttributeSet.class});
                  constructor.newInstance(new Objectp[mContext, attr]);
                    // view ctor
                    TypedArray a = context.obtainStyledAttributes(
                        attrs,
                        com.android.internal.R.styleable.View,defStyle, 0);
                    foreach attr in a:
                      case : com.android.internal.R.styleable.View_background:
                        background=a.getDrawable(attr);
                      case : com.android.internal.R.styleable.View_padding:
                        padding=a.getDimensionPixelSize(attr,-1);
                      case : com.android.internal.R.styleable.View_id:
                        mId=a.getResourceId(attr,NO_ID;
                      ...
            return view;
          // createViewFromTag ends here
      // now that view is created, generate layout_params
      // layout_params is collected from attrs
      params = root.generateLayoutParams(attrs);
      temp.setLayoutParams(params);
      // recursively inflate all its children
      rInflate(parser, temp, attrs, true);
        // rInflate is very similar with inflate, except for that:
        // 1. parser, attrs is already there, no need to find and  re-parse the
        // layout xml
        // 2. it recursively descend down the xml hierarchy to inflate all the children
        // 3. the last parameter `true` indicates that it will invoke parent.onFinishInflate
      root.addView(temp, params);
      // if MERGE ends here
    // inflate ends here

#+END_SRC
**** To summaries
1. get XmlResourceParser from Resource (maybe cached)
2. get AttrbuteSet, obtainStyledAttributes, generateLayoutParams
3. get the view name and kick off the ClassLoader
   - <ListView>
   - <xx.xx.xx>
   - <View class=xx.xx.xx>
4. rInflate: recursively inflate all the children
5. LayoutInflater.Filter & LayoutInflater.Factory
6. onFinishInflate

*** MenuInflater
*** Preference Inflater
*** Stub Inflater
*** misc
**** Configuration Qualifiers: Providing resources and supporting multiple screen.

http://developer.android.com/guide/topics/resources/providing-resources.html
http://developer.android.com/guide/practices/screens_support.html

选择合适的资源分为三步:

1. match
   把同一个 package 中所有 config 与 requestedConfig 进行 match, 不匹
   配的直接去掉
2. isBetterThan
   对 match 剩下的 config 进行比较, 找到这个 package 中最合适的 config
3. isMoreSpecificThan
   对多个 package 中最合适的 config 再进行比较, 找到所有 package 中最
   合适的 config

***** match

density 在 match 阶段会被认为是都是 match 的, 因为系统对任何 density
的图片都可以通过 scale 来和当前的屏幕匹配. 后续的 isBetterThan 会从各
种 density 的图片中找到最合适的.

#+BEGIN_SRC java
  bool ResTable_config::match(const ResTable_config& settings) const {
      if (imsi != 0) {
          if (mcc != 0 && mcc != settings.mcc) {
              return false;
          }
          if (mnc != 0 && mnc != settings.mnc) {
              return false;
          }
      }
      if (locale != 0) {
          if (language[0] != 0
              && (language[0] != settings.language[0]
                  || language[1] != settings.language[1])) {
              return false;
          }
          if (country[0] != 0
              && (country[0] != settings.country[0]
                  || country[1] != settings.country[1])) {
              return false;
          }
      }
      if (screenConfig != 0) {
          const int screenSize = screenLayout&MASK_SCREENSIZE;
          const int setScreenSize = settings.screenLayout&MASK_SCREENSIZE;
          // Any screen sizes for larger screens than the setting do not
          // match.
          if (screenSize != 0 && screenSize > setScreenSize) {
              return false;
          }

          const int screenLong = screenLayout&MASK_SCREENLONG;
          const int setScreenLong = settings.screenLayout&MASK_SCREENLONG;
          if (screenLong != 0 && screenLong != setScreenLong) {
              return false;
          }

          const int uiModeType = uiMode&MASK_UI_MODE_TYPE;
          const int setUiModeType = settings.uiMode&MASK_UI_MODE_TYPE;
          if (uiModeType != 0 && uiModeType != setUiModeType) {
              return false;
          }

          const int uiModeNight = uiMode&MASK_UI_MODE_NIGHT;
          const int setUiModeNight = settings.uiMode&MASK_UI_MODE_NIGHT;
          if (uiModeNight != 0 && uiModeNight != setUiModeNight) {
              return false;
          }

          if (smallestScreenWidthDp != 0
              && smallestScreenWidthDp > settings.smallestScreenWidthDp) {
              return false;
          }
      }
      if (screenSizeDp != 0) {
          if (screenWidthDp != 0 && screenWidthDp > settings.screenWidthDp) {
              //ALOGI("Filtering out width %d in requested %d", screenWidthDp, settings.screenWidthDp);
              return false;
          }
          if (screenHeightDp != 0 && screenHeightDp > settings.screenHeightDp) {
              //ALOGI("Filtering out height %d in requested %d", screenHeightDp, settings.screenHeightDp);
              return false;
          }
      }
      if (screenType != 0) {
          if (orientation != 0 && orientation != settings.orientation) {
              return false;
          }
          // density always matches - we can scale it.  See isBetterThan
          if (touchscreen != 0 && touchscreen != settings.touchscreen) {
              return false;
          }
      }
      if (input != 0) {
          const int keysHidden = inputFlags&MASK_KEYSHIDDEN;
          const int setKeysHidden = settings.inputFlags&MASK_KEYSHIDDEN;
          if (keysHidden != 0 && keysHidden != setKeysHidden) {
              // For compatibility, we count a request for KEYSHIDDEN_NO as also
              // matching the more recent KEYSHIDDEN_SOFT.  Basically
              // KEYSHIDDEN_NO means there is some kind of keyboard available.
              //ALOGI("Matching keysHidden: have=%d, config=%d\n", keysHidden, setKeysHidden);
              if (keysHidden != KEYSHIDDEN_NO || setKeysHidden != KEYSHIDDEN_SOFT) {
                  //ALOGI("No match!");
                  return false;
              }
          }
          const int navHidden = inputFlags&MASK_NAVHIDDEN;
          const int setNavHidden = settings.inputFlags&MASK_NAVHIDDEN;
          if (navHidden != 0 && navHidden != setNavHidden) {
              return false;
          }
          if (keyboard != 0 && keyboard != settings.keyboard) {
              return false;
          }
          if (navigation != 0 && navigation != settings.navigation) {
              return false;
          }
      }
      if (screenSize != 0) {
          if (screenWidth != 0 && screenWidth > settings.screenWidth) {
              return false;
          }
          if (screenHeight != 0 && screenHeight > settings.screenHeight) {
              return false;
          }
      }
      if (version != 0) {
          if (sdkVersion != 0 && sdkVersion > settings.sdkVersion) {
              return false;
          }
          if (minorVersion != 0 && minorVersion != settings.minorVersion) {
              return false;
          }
      }
      return true;
  }

#+END_SRC

***** isBetterThan

isBetterThan(targetConfig, requestedConfig) is used to check `whether
this config is better than targetConfig according to requestedConfig'

其中density 的判断比较特殊, 基本上, 两个原则:

1. 接近的优先
2. 大的更优先

具体的: 

1. 若 requestedConfig 比 thisConfig 和 targetConfig 都大, 则从
   thisConfig 和 targetConfig 中选择大的

2. 若 requestedConfig 比 thisConfig 和 targetConfig 都小, 则从
   thisConfig 和 targetConfig 中选择小的

3. 若 requestedConfig 位于 thisConfig 和 targetConfig 之间, 则系统会在
   两者间选一个中间点 r, requestedConfig 位于 thisConfig 和 中间点之间
   的,选择 thisConfig, 否则选择 targetConfig. 中间点 r 的选择不是简单的
   取了个中间值, 而要使用了一个公式来获得:


#+BEGIN_CENTER
   #+BEGIN_LaTeX
   % 其中的h为 thisConfig 与 targetConfig 的最大值, l 为 thisConfig 与
   % targetConfig 的最小值. 
   $(2l-r)*h = r^2$

   $\frac{2l}{r}-1=\frac{r}{h}$

   $r = \frac{-h+\sqrt{h^2+8hl}}{2}$
   #+END_LaTeX
#+END_CENTER   


通过 gnuplot 画图可以观察到:

#+BEGIN_SRC gnuplot :file plot.png
set title "x->h, y->l, z->r"
set output "plot.png"
splot [0:1000] [0:1000] [0:1000] (-x + sqrt(x**2+8*x*y))/2 , x/2+y/2
#+END_SRC

#+RESULTS:
[[file:plot.png]]

固定 h 为 100
#+BEGIN_SRC gnuplot :file plot2.png
set title "x=100"
set output "plot2.png"
plot [0:200] [0:200] (-100 + sqrt(100**2+8*100*x))/2 , 100/2+x/2
#+END_SRC

#+RESULTS:

r 始终偏向 l (h>l), 且 h-l 越大, 越偏向 l

例如:
1. h=320, l=120, request=240, 则 r=160 (<220), 选择 h
2. h=240, l=120, request=160, 则 r=147 (<180), 选择 h

#+BEGIN_SRC java
  bool ResTable_config::isBetterThan(const ResTable_config& o,
                                     const ResTable_config* requested) const {
      if (requested) {
          if (imsi || o.imsi) {
              if ((mcc != o.mcc) && requested->mcc) {
                  return (mcc);
              }
  
              if ((mnc != o.mnc) && requested->mnc) {
                  return (mnc);
              }
          }
  
          if (locale || o.locale) {
              if ((language[0] != o.language[0]) && requested->language[0]) {
                  return (language[0]);
              }
  
              if ((country[0] != o.country[0]) && requested->country[0]) {
                  return (country[0]);
              }
          }
  
          if (smallestScreenWidthDp || o.smallestScreenWidthDp) {
              // The configuration closest to the actual size is best.
              // We assume that larger configs have already been filtered
              // out at this point.  That means we just want the largest one.
              if (smallestScreenWidthDp != o.smallestScreenWidthDp) {
                  return smallestScreenWidthDp > o.smallestScreenWidthDp;
              }
          }
  
          if (screenSizeDp || o.screenSizeDp) {
              // "Better" is based on the sum of the difference between both
              // width and height from the requested dimensions.  We are
              // assuming the invalid configs (with smaller dimens) have
              // already been filtered.  Note that if a particular dimension
              // is unspecified, we will end up with a large value (the
              // difference between 0 and the requested dimension), which is
              // good since we will prefer a config that has specified a
              // dimension value.
              int myDelta = 0, otherDelta = 0;
              if (requested->screenWidthDp) {
                  myDelta += requested->screenWidthDp - screenWidthDp;
                  otherDelta += requested->screenWidthDp - o.screenWidthDp;
              }
              if (requested->screenHeightDp) {
                  myDelta += requested->screenHeightDp - screenHeightDp;
                  otherDelta += requested->screenHeightDp - o.screenHeightDp;
              }
              //ALOGI("Comparing this %dx%d to other %dx%d in %dx%d: myDelta=%d otherDelta=%d",
              //    screenWidthDp, screenHeightDp, o.screenWidthDp, o.screenHeightDp,
              //    requested->screenWidthDp, requested->screenHeightDp, myDelta, otherDelta);
              if (myDelta != otherDelta) {
                  return myDelta < otherDelta;
              }
          }
  
          if (screenLayout || o.screenLayout) {
              if (((screenLayout^o.screenLayout) & MASK_SCREENSIZE) != 0
                  && (requested->screenLayout & MASK_SCREENSIZE)) {
                  // A little backwards compatibility here: undefined is
                  // considered equivalent to normal.  But only if the
                  // requested size is at least normal; otherwise, small
                  // is better than the default.
                  int mySL = (screenLayout & MASK_SCREENSIZE);
                  int oSL = (o.screenLayout & MASK_SCREENSIZE);
                  int fixedMySL = mySL;
                  int fixedOSL = oSL;
                  if ((requested->screenLayout & MASK_SCREENSIZE) >= SCREENSIZE_NORMAL) {
                      if (fixedMySL == 0) fixedMySL = SCREENSIZE_NORMAL;
                      if (fixedOSL == 0) fixedOSL = SCREENSIZE_NORMAL;
                  }
                  // For screen size, the best match is the one that is
                  // closest to the requested screen size, but not over
                  // (the not over part is dealt with in match() below).
                  if (fixedMySL == fixedOSL) {
                      // If the two are the same, but 'this' is actually
                      // undefined, then the other is really a better match.
                      if (mySL == 0) return false;
                      return true;
                  }
                  if (fixedMySL != fixedOSL) {
                      return fixedMySL > fixedOSL;
                  }
              }
              if (((screenLayout^o.screenLayout) & MASK_SCREENLONG) != 0
                  && (requested->screenLayout & MASK_SCREENLONG)) {
                  return (screenLayout & MASK_SCREENLONG);
              }
          }
  
          if ((orientation != o.orientation) && requested->orientation) {
              return (orientation);
          }
  
          if (uiMode || o.uiMode) {
              if (((uiMode^o.uiMode) & MASK_UI_MODE_TYPE) != 0
                  && (requested->uiMode & MASK_UI_MODE_TYPE)) {
                  return (uiMode & MASK_UI_MODE_TYPE);
              }
              if (((uiMode^o.uiMode) & MASK_UI_MODE_NIGHT) != 0
                  && (requested->uiMode & MASK_UI_MODE_NIGHT)) {
                  return (uiMode & MASK_UI_MODE_NIGHT);
              }
          }
  
          if (screenType || o.screenType) {
              if (density != o.density) {
                  // density is tough.  Any density is potentially useful
                  // because the system will scale it.  Scaling down
                  // is generally better than scaling up.
                  // Default density counts as 160dpi (the system default)
                  // TODO - remove 160 constants
                  int h = (density?density:160);
                  int l = (o.density?o.density:160);
                  bool bImBigger = true;
                  if (l > h) {
                      int t = h;
                      h = l;
                      l = t;
                      bImBigger = false;
                  }
  
                  int reqValue = (requested->density?requested->density:160);
                  if (reqValue >= h) {
                      // requested value higher than both l and h, give h
                      return bImBigger;
                  }
                  if (l >= reqValue) {
                      // requested value lower than both l and h, give l
                      return !bImBigger;
                  }
                  // saying that scaling down is 2x better than up
                  if (((2 * l) - reqValue) * h > reqValue * reqValue) {
                      return !bImBigger;
                  } else {
                      return bImBigger;
                  }
              }
  
              if ((touchscreen != o.touchscreen) && requested->touchscreen) {
                  return (touchscreen);
              }
          }
  
          if (input || o.input) {
              const int keysHidden = inputFlags & MASK_KEYSHIDDEN;
              const int oKeysHidden = o.inputFlags & MASK_KEYSHIDDEN;
              if (keysHidden != oKeysHidden) {
                  const int reqKeysHidden =
                      requested->inputFlags & MASK_KEYSHIDDEN;
                  if (reqKeysHidden) {
  
                      if (!keysHidden) return false;
                      if (!oKeysHidden) return true;
                      // For compatibility, we count KEYSHIDDEN_NO as being
                      // the same as KEYSHIDDEN_SOFT.  Here we disambiguate
                      // these by making an exact match more specific.
                      if (reqKeysHidden == keysHidden) return true;
                      if (reqKeysHidden == oKeysHidden) return false;
                  }
              }
  
              const int navHidden = inputFlags & MASK_NAVHIDDEN;
              const int oNavHidden = o.inputFlags & MASK_NAVHIDDEN;
              if (navHidden != oNavHidden) {
                  const int reqNavHidden =
                      requested->inputFlags & MASK_NAVHIDDEN;
                  if (reqNavHidden) {
  
                      if (!navHidden) return false;
                      if (!oNavHidden) return true;
                  }
              }
  
              if ((keyboard != o.keyboard) && requested->keyboard) {
                  return (keyboard);
              }
  
              if ((navigation != o.navigation) && requested->navigation) {
                  return (navigation);
              }
          }
  
          if (screenSize || o.screenSize) {
              // "Better" is based on the sum of the difference between both
              // width and height from the requested dimensions.  We are
              // assuming the invalid configs (with smaller sizes) have
              // already been filtered.  Note that if a particular dimension
              // is unspecified, we will end up with a large value (the
              // difference between 0 and the requested dimension), which is
              // good since we will prefer a config that has specified a
              // size value.
              int myDelta = 0, otherDelta = 0;
              if (requested->screenWidth) {
                  myDelta += requested->screenWidth - screenWidth;
                  otherDelta += requested->screenWidth - o.screenWidth;
              }
              if (requested->screenHeight) {
                  myDelta += requested->screenHeight - screenHeight;
                  otherDelta += requested->screenHeight - o.screenHeight;
              }
              if (myDelta != otherDelta) {
                  return myDelta < otherDelta;
              }
          }
  
          if (version || o.version) {
              if ((sdkVersion != o.sdkVersion) && requested->sdkVersion) {
                  return (sdkVersion > o.sdkVersion);
              }
  
              if ((minorVersion != o.minorVersion) &&
                  requested->minorVersion) {
                  return (minorVersion);
              }
          }
  
          return false;
      }
      return isMoreSpecificThan(o);
  }
#+END_SRC

***** isMoreSpecificThan'
  select more specific resource package from resource packages
  (e.g. when there are overlay packages)

**** get application resources?
1. use PackageContext

   Context.createPackageContext
2. use PackageManager

   PackageManager.getResourceForApplication
   PackageManager.getText
   ...

两种做法在底层的工作原理都是一样的:

依赖于 ~Resources r = mContext.mMainThread.getTopLevelResources~
** Overlay
Overlay 是 ics 对 AssetManager 的一个扩展, 使得 app 其可以使用
`framework-res.apk 和 app 自身的 resource` 之外的 resource. 但是, 我们通过
~AssetManager.addAssetPath()~ 不是已经使 app 使用任意其他 resource package 了么?

Yes, 但有一个问题:

Q: 如何保证`任意其他`的 resource package 与 base package 使用的 resID 是一致的?
即: 在 base package 和 resource package 中, R.string.foo 对应的 resID 必须是一样
的.

A: 由于 resID 是 aapt 根据 res/ 中总体的 resource 情况动态分配的, 所以如何想保证
base package 和 resource package 生成的 resID 是一致的, 必须保证两个package 的
resource 的情况是一样的, 即 res 目录下除了各个 resource 的值可以不同之外, 其它必
须是一致的, 包括定义的 resource 及 它们在资源文件中的位置等.


Q: 如果我只是想在 resource package 中重新定义几个资源而不是所有资源...怎么办?

A: Overlay 就是为了解决这个问题, 换句话说, overlay 不是为了解决 app 使用其它
resource package 的问题, 而是为了解决 app 如何使用一个 resID 与 base package 不
一致的 resource package 的问题, 通过 overlay, resource package 的维护变得简单很
多.

*** 生成 Overlay package
Overlay package 与普通的 package 只有一点不同:

Overlay package 的所有 resID 都为0x00xxxxxx, 即: package id 为 0. 当用户调用
addAssetPath 时, 系统会根据这个值判断它为 overlay package, 然后才会为它生成 idmap

*** idmap
*** Overlay 的处理过程
Overlay package 被使用之前, 需要确保 idmap 已经生成并且不是 stale 的, 一般情况下,
PackageManager 会去处理这件事, 但也不排除 AssetManager 在 addAssetPath 时也会处
理, 例如 AssetManager 在加载 framework-res.apk 时对 framework-res overlay 的处
理:

**** 加载
#+BEGIN_SRC java
if (strncmp(path.string(), "/system/framework/", 18) == 0):
  overlayPath="/vendor/overlay/system/framework-res.apk";
  asset_path oap;
  oap.path = overlayPath;
  oap.idmap = idmapPathForPackagePath(overlayPath); // 查找 /data/resource-cache 中对应的 idmap 是否存在
  if (isIdmapStaleLocked(ap.path, oap.path, oap.idmap)): // 不存在 idmap 或 idmap 是旧的 (crc 不符)
    createIdmapFileLocked(ap.path, oap.path, oap.idmap);
  mAssetPaths.add(oap);
#+END_SRC

overlay package 被加入到 mAssetPaths 后, AssetManager 在生成 ResTable 是就会根
据 oap.idmap 知道这是一个 overlay package 了.
**** 解析
#+BEGIN_SRC java
  // ResTable.add
  ResTable::add(const void* data, size_t size, void* cookie, Asset* asset, bool copyData, const Asset* idmap)
    if idmap!=null:
      header->resourceIDMap = idmap; // ResTable 中 package 的 header 保存着该 overlay package 的 idmap
    ...
    if (idmap != NULL):
      idmap_id=getIdmapPackageId(header->resourceIDMap,..); // idmap_id 是 idmap 中保存的 base package id
      parsePackage((ResTable_package*)chunk, header, idmap_id);
        pkg_id = idmap_id != 0 ? idmap_id : dtohl(pkg->id);
        // GOT IT! 虽然 Overlay package 中保存的 pkg id 是 0, 但 ResTable 在解析 overlay package 时会把它加到它对应的 base package 的 package group 中!

#+END_SRC
**** 查询
因为 Overlay package 的 pkg id 在 ResTable::parsePackage 时被重写为 base
package 的 pkg id, 所以查找 base package 的 resID 时取得的 package group 也会包
含该 overlay package, 在查找 resID 时, overlay package 与 base package 唯一不同
的一点是:
#+BEGIN_SRC java
  for pacakge in pacakge_group:
    if (package->header->resourceIDMap):
      uint32_t overlayResID = 0x0;
      status_t retval = idmapLookup(package->header->resourceIDMap,
                                    package->header->resourceIDMapSize,
                                    resID, &overlayResID);
      if (retval == NO_ERROR && overlayResID != 0x0) {
          // for this loop iteration, this is the type and entry we really want
          LOGV("resource map 0x%08x -> 0x%08x\n", resID, overlayResID);
          T = Res_GETTYPE(overlayResID);
          E = Res_GETENTRY(overlayResID);
    ...
#+END_SRC
*** Overlay 机制的缺陷
Overlay 机制主要是通过 idmap 完成 `original ID->overlay ID` 的映射而起作用的, 但
是, 如果资源查找过程中涉及到 reference 时, idmap 提供的这种单向的 map 无法起作用,
例如, 以 LayoutInflater 为例:

假设通过 idmap 找到了这个 overlay package 中定义的 layout:

#+BEGIN_SRC xml
  <LinearLayout
      android:id="@+id/orig_id"
      android:style="@R.style.orig_style">
    </LinearLayout>
#+END_SRC

由于 xml 中的引用在 aapt 编译阶段就会被翻译为对应的 resID, 则这个 xml 实际上为:

#+BEGIN_SRC xml
  <LinearLayout
      android:id="@00yyyyyy"
      android:style="@00xxxxxx">
    </LinearLayout>
#+END_SRC

其中 @00xxxxxx 是 overlay package 中定义的 orig_style, AssetManager 在尝试获取这
个 resID 的值是直接失败, 因为这种 id 在 AssetManager 看来不是一个合法的 resID
...

更严重的问题是, orig package 中定义的 view id 和 overlay 中定义的 view id 不同,
会导致 findViewById 失败.

** Various resouce
*** attrs.xml, styles.xml, themes.xml
**** R.attr
attrs.xml 中定义一个资源的例子:
#+BEGIN_SRC xml
  <attr name="colorForeground" format="color" />
  <attr name="textAppearance" format="reference" />
  <declare-styleable name="AlertDialog">
    <attr name="listItemLayout" format="reference" />
    <attr name="progressLayout" format="reference" />
  </declare-styleable>
#+END_SRC

Q: 这个例子中定义的 `attr` (通过 R.attr 访问) 与 strings.xml 或 config.xml 中定义的
R.string 有何不同?

A: attr 统统没有定义值, 那访问 R.attr.textAppearance 时它对应的值是多少?  取决
了 attr 使用的 `Context`

attrs.xml 中 ~declare-styleable~ 其实就是定义了一个该 `attr` 能出现的
`Context`,  例如 framework-res 中定义的 `Context` 有:

- *Theme*
- ViewGroup_Layout
- Window
- AlertDialog
- View
- ....

**** R.style
所谓 Style, 不过是一群 ~attr->value~ 的集合, 这与高级语言的结构体很类似: Style
也是一种的 `value`

#+BEGIN_SRC xml
  <style name="Widget.TextView.ListSeparator">
      <item name="android:background">@android:drawable/dark_header_dither</item>
      <item name="android:layout_width">match_parent</item>
      <item name="android:layout_height">wrap_content</item>
      <item name="android:textStyle">bold</item>
      <item name="android:textColor">?textColorSecondary</item>
      <item name="android:textSize">14sp</item>
      <item name="android:gravity">center_vertical</item>
      <item name="android:paddingLeft">8dip</item>
  </style>

Style 的名字也暗示了这个 style 可以做为什么的 style, 例如, Widget.TextView.ListSeparator 表示它可以做为 ListView 的 style,
提供一种可做为 List Seperator 的 TextView 样式. 但 Style 名字只是一个暗示, 并不是一个强制的要求, 用户可以将 ActionBar 的 style 设为
Widget.TextView.ListSeparator, 但因为 ActionBar 本身有可能在 obtainStyledAttributes 时从该 style 中根据获取不取它想要的属性, 所以可能
导致这种 style 没有效果.

#+END_SRC
***** R.theme
#+BEGIN_SRC xml
  <style name="Theme.Holo.Light.Dialog">
    <item name="android:windowFrame">@null</item>
    <item name="android:windowTitleStyle">@android:style/DialogWindowTitle.Holo.Light</item>
    <item name="android:windowBackground">@android:drawable/dialog_full_holo_light</item>
    <item name="android:windowIsFloating">true</item>
    <item name="android:windowContentOverlay">@null</item>
    <item name="android:windowAnimationStyle">@android:style/Animation.Holo.Dialog</item>
    <item name="android:windowSoftInputMode">stateUnspecified|adjustPan</item>
    <item name="android:windowActionBar">false</item>
    <item name="android:windowActionModeOverlay">true</item>
    <item name="android:windowCloseOnTouchOutside">@bool/config_closeDialogWhenTouchOutside</item>

    <item name="android:colorBackgroundCacheHint">@null</item>

    <item name="android:buttonBarStyle">@android:style/Holo.Light.ButtonBar.AlertDialog</item>
    <item name="borderlessButtonStyle">@android:style/Widget.Holo.Light.Button.Borderless.Small</item>

    <item name="textAppearance">@android:style/TextAppearance.Holo.Light</item>
    <item name="textAppearanceInverse">@android:style/TextAppearance.Holo.Light.Inverse</item>

    <item name="listPreferredItemPaddingLeft">16dip</item>
    <item name="listPreferredItemPaddingRight">16dip</item>
  </style>
#+END_SRC

themes.xml 是 styles.xml 的特例, 它有两点需要注意:
1. 解析 TYPE_ATTRIBUTE 资源 (具体包括 解析 xml 中 ? 或 obtainStyledAttributes 中 defStyle)
2. 根据解析结果提供默认 style

#+BEGIN_CENTER
ListView, ImageView, TextView, ActionBar 等会在代码中或 xml 中会通过 TYPE_ATTRIBUTE 类型的
资源引用一个默认的 style, 只有 theme 可以处理这种类型的资源的解析, 通过这种解析,
theme 就可以给它们提供一个默认 style,
#+END_CENTER

**** 访问 attr
#+BEGIN_SRC xml
  <ImageView
      android:style="@style/my_style"
      android:src="@drawable/test">
  </ImageView>

  <style name="my_style"
         android:layout_height="wrap_content"
         android:layout_width="wrap_content">
  </style>
#+END_SRC

因为 style 只是 ~attr->value~ 的集合, 我们可以将 xml 展开为:

#+BEGIN_SRC xml
  <ImageView
      android:layout_height="wrap_content"
      android:layout_width="wrap_content"
      android:src="@drawable/test">
  </ImageView>
#+END_SRC

那么在该 ImageView 的 context 下, R.attr.src 的值为 ~@drawable/test~, 而
R.attr.layout_width 的值为 ~wrap_content~.

在代码中, 获取 attr 的值是通过:

~TypedArray obtainStyledAttributes(AttributeSet set,int[] attrs, int
defStyleAttr, int defStyleRes)~

其中:

- set

作用类似于 `Context`, 因为它包含有该 xml tag 下所有的属性的key-value 对.

- defStyleAttr

这个属性相当于将 xml 修改为:

#+BEGIN_SRC xml
  <ImageView
      android:style="?R.attr.defStyleAttr"
      android:layout_height="wrap_content"
      android:layout_width="wrap_content"
      android:src="@drawable/test">
  </ImageView>
#+END_SRC

- defStyleRes

这个属性相当于将 xml 修改为:

#+BEGIN_SRC xml
  <ImageView
      android:style="@R.style.defStyleAttr"
      android:layout_height="wrap_content"
      android:layout_width="wrap_content"
      android:src="@drawable/test">
  </ImageView>
#+END_SRC
**** ? vs. @
**** How to define a STYLE
**** To summaries:
attr 是最特殊的一类 resouce:
- 它的值有上下文的区别,

  这个特性决定了它可以用来定义各种 xml tag 的 `属性`
- theme 可以通过 TYPE_ATTRIBUTE 类型的资源提供默认 style
*** config.xml
*** ids.xml
** Theme
*** Theme 三板斧:
- Theme.applyStyle
- Theme.obtainStyledAttributes
- Theme.resolveAttribute
*** Example
MyView 想要获得当前默认 theme 下 attribute 为 R.attr.test_style 的 style 中
   定义的 test_attr 值.

#+BEGIN_SRC xml
  <resources>
    <style name="TestTheme" parent="android:Theme.Holo">
      <item name="test_style">@style/TestStyle</item>
    </style>
    <style name="TestStyle" parent="android:Theme.Holo">
      <item name="test_attr">9</item>
    </style>
  </resources>
#+END_SRC

或

#+BEGIN_SRC xml
  <resources>
    <style name="TestTheme" parent="android:Theme.Holo">
        <item name="test_style">?attr/test_style_int</item>
        <item name="test_style_int">@style/TestStyle</item>
    </style>
    <style name="TestStyle" parent="android:Theme.Holo">
      <item name="test_attr">9</item>
    </style>
  </resources>
#+END_SRC

1. 方法一
   #+BEGIN_SRC java
     TypedValue outValue;
     getTheme().resolveAttribute(R.attr.test_style, outValue, true);
     int resId=outValue.resouce_id;
     getTheme().applyStyle(resId, true)
     getTheme().resolveAttribute(R.attr.test_attr, outValue2, true);
     int width=outValue2.getDimension();
   #+END_SRC

2. 方法二
   #+BEGIN_SRC java
     TypedValue outValue;
     getTheme().resolveAttribute(R.attr.test_style, outValue, true);
     int resId=outValue.resouce_id;
     TypedArray array=getTheme().obtainStyledAttributes(null, new int[] {R.attr.test_attr}, 0, resId);
     array.getDimension(0, default);
   #+END_SRC

3. 方法三
   #+BEGIN_SRC java
     array=getTheme().obtainStyledAttributes(null, new int[] {R.attr.test_attr}, R.attr.test_style, 0);
     array.getDimension(0, default);
   #+END_SRC

`style-attr-style` 可以构成一种层次化的结构, 通过方法一总是可以遍历这种层次结构, 但
是当层次为 $2$ 时, 用方法三更方便一些.

另外, 如方法一中所示, 在处理这种层次结构时, getTheme().applyStyle() 实际上采用了
一种偷懒的做法: 通过 applyStyle(style), 层次结构被变为一种平面结构, 而平面结构必
然会导致相同的 attr 的重叠, 所以 applyStyle() 的第二个 boolean 参数决定了相同的
attr 的覆盖关系.
** misc
*** aapt & AXMLPrinter2
*** aapt
Android Asset Packaging Tool
**** basic usage
#+BEGIN_QUOTE
aapt 不仅可以操作 resource,  实际上, 它可以操作 apk 中除了代码以外其它部分, 如
Manifest, Asset, Resource
#+END_QUOTE

- aapt package -S res/ -M AndroidManifest.xml -I android.jar -J ./

  在当前目录下根据 res/ 生成 R.java

- aapt package -S res/ -A ./asset -M AndroidManifest.xml -I android.jar -F
  ./1.apk

  生成 apk (不包含 classes.dex)

- aapt package -S res/ -A ./asset -M AndroidManifest.xml -I
  android.jar -F ./1.apk -c zh,mdpi

  生成的 apk 只包含 resource qualifiers 为 zh 或 mdpi 的资源

- aapt dump resources xxx.apk

  显示 ResTable

**** internal
*** framework-res.apk
**** android 和 com.android.internal
framework-res.apk 中包含 framework/base/core/res 下所有的 resources, 但生成的 R
文件有两个, 一个是 android.R, 一个是 com.android.internal.R, 区分的依据是
framework/base/core/res/res/values/public.xml, 这个文件大致为:

#+BEGIN_EXAMPLE
<resources>
  <private-symbols package="com.android.internal" />

<!-- ===============================================================
     Resources for version 1 of the platform.
     =============================================================== -->
  <eat-comment />
  <public type="attr" name="theme" id="0x01010000" />
  <public type="attr" name="label" id="0x01010001" />
  <public type="attr" name="icon" id="0x01010002" />
  ...
<!-- ===============================================================
     Resources added in version 2 of the platform.
     =============================================================== -->
  <public type="attr" name="marqueeRepeatLimit" id="0x0101021d" />
  ...
#+END_EXAMPLE

即, framework-res.apk 包含了 public 和 private 的 resources:

- public resouce

public.xml 中包含了各个版本的 SDK 中定义的 resource , 这些 resource 的 id 不是通
过 aapt 生成的, 而且事先在 public.xml 中指定的, 并且这些 id 被置于 android.R 中
并被包含在 SDK 的 android.jar 中

- private resouce

其它未在public.xml 中指定的 resource 的 ID 被置于 com.android.internal.R 中, 这
个类在 SDK 中不存在, 只存在 framework.jar 中并被标为 ~@hide~
*** get application resources?
1. use PackageContext

   Context.createPackageContext
2. use PackageManager

   PackageManager.getResourceForApplication
   PackageManager.getText
   ...

两种做法在底层的工作原理都是一样的:

依赖于 ~Resources r = mContext.mMainThread.getTopLevelResources~
*** official Android README about `resource and overlay`
This official document resides in `framework/base/libs/utils/README`


#+BEGIN_EXAMPLE
Android Utility Function Library
================================


If you need a feature that is native to Linux but not present on other
platforms, construct a platform-dependent implementation that shares
the Linux interface.  That way the actual device runs as "light" as
possible.

If that isn't feasible, create a system-independent interface and hide
the details.

The ultimate goal is *not* to create a super-duper platform abstraction
layer.  The goal is to provide an optimized solution for Linux with
reasonable implementations for other platforms.



Resource overlay
================


Introduction
------------

Overlay packages are special .apk files which provide no code but
additional resource values (and possibly new configurations) for
resources in other packages. When an application requests resources,
the system will return values from either the application's original
package or any associated overlay package. Any redirection is completely
transparent to the calling application.

Resource values have the following precedence table, listed in
descending precedence.

 * overlay package, matching config (eg res/values-en-land)

 * original package, matching config

 * overlay package, no config (eg res/values)

 * original package, no config

During compilation, overlay packages are differentiated from regular
packages by passing the -o flag to aapt.


Background
----------

This section provides generic background material on resources in
Android.


How resources are bundled in .apk files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Android .apk files are .zip files, usually housing .dex code,
certificates and resources, though packages containing resources but
no code are possible. Resources can be divided into the following
categories; a `configuration' indicates a set of phone language, display
density, network operator, etc.

 * assets: uncompressed, raw files packaged as part of an .apk and
           explicitly referenced by filename. These files are
           independent of configuration.

 * res/drawable: bitmap or xml graphics. Each file may have different
                 values depending on configuration.

 * res/values: integers, strings, etc. Each resource may have different
               values depending on configuration.

Resource meta information and information proper is stored in a binary
format in a named file resources.arsc, bundled as part of the .apk.

Resource IDs and lookup
~~~~~~~~~~~~~~~~~~~~~~~
During compilation, the aapt tool gathers application resources and
generates a resources.arsc file. Each resource name is assigned an
integer ID 0xppttiii (translated to a symbolic name via R.java), where

 * pp: corresponds to the package namespace (details below).

 * tt: corresponds to the resource type (string, int, etc). Every
       resource of the same type within the same package has the same
       tt value, but depending on available types, the actual numerical
       value may be different between packages.

 * iiii: sequential number, assigned in the order resources are found.

Resource values are specified paired with a set of configuration
constraints (the default being the empty set), eg res/values-sv-port
which imposes restrictions on language (Swedish) and display orientation
(portrait). During lookup, every constraint set is matched against the
current configuration, and the value corresponding to the best matching
constraint set is returned (ResourceTypes.{h,cpp}).

Parsing of resources.arsc is handled by ResourceTypes.cpp; this utility
is governed by AssetManager.cpp, which tracks loaded resources per
process.

Assets are looked up by path and filename in AssetManager.cpp. The path
to resources in res/drawable are located by ResourceTypes.cpp and then
handled like assets by AssetManager.cpp. Other resources are handled
solely by ResourceTypes.cpp.

Package ID as namespace
~~~~~~~~~~~~~~~~~~~~~~~
The pp part of a resource ID defines a namespace. Android currently
defines two namespaces:

 * 0x01: system resources (pre-installed in framework-res.apk)

 * 0x7f: application resources (bundled in the application .apk)

ResourceTypes.cpp supports package IDs between 0x01 and 0x7f
(inclusive); values outside this range are invalid.

Each running (Dalvik) process is assigned a unique instance of
AssetManager, which in turn keeps a forest structure of loaded
resource.arsc files. Normally, this forest is structured as follows,
where mPackageMap is the internal vector employed in ResourceTypes.cpp.

mPackageMap[0x00] -> system package
mPackageMap[0x01] -> NULL
mPackageMap[0x02] -> NULL
...
mPackageMap[0x7f - 2] -> NULL
mPackageMap[0x7f - 1] -> application package



The resource overlay extension
------------------------------

The resource overlay mechanism aims to (partly) shadow and extend
existing resources with new values for defined and new configurations.
Technically, this is achieved by adding resource-only packages (called
overlay packages) to existing resource namespaces, like so:

mPackageMap[0x00] -> system package -> system overlay package
mPackageMap[0x01] -> NULL
mPackageMap[0x02] -> NULL
...
mPackageMap[0x7f - 2] -> NULL
mPackageMap[0x7f - 1] -> application package -> overlay 1 -> overlay 2

The use of overlay resources is completely transparent to
applications; no additional resource identifiers are introduced, only
configuration/value pairs. Any number of overlay packages may be loaded
at a time; overlay packages are agnostic to what they target -- both
system and application resources are fair game.

The package targeted by an overlay package is called the target or
original package.

Resource overlay operates on symbolic resources names. Hence, to
override the string/str1 resources in a package, the overlay package
would include a resource also named string/str1. The end user does not
have to worry about the numeric resources IDs assigned by aapt, as this
is resolved automatically by the system.

As of this writing, the use of resource overlay has not been fully
explored. Until it has, only OEMs are trusted to use resource overlay.
For this reason, overlay packages must reside in /system/overlay.


<<Resource ID mapping>>
~~~~~~~~~~~~~~~~~~~
Resource identifiers must be coherent within the same namespace (ie
PackageGroup in ResourceTypes.cpp). Calling applications will refer to
resources using the IDs defined in the original package, but there is no
guarantee aapt has assigned the same ID to the corresponding resource in
an overlay package. To translate between the two, a resource ID mapping
{original ID -> overlay ID} is created during package installation
(PackageManagerService.java) and used during resource lookup. The
mapping is stored in /data/resource-cache, with a @idmap file name
suffix.

The idmap file format is documented in a separate section, below.


Package management
~~~~~~~~~~~~~~~~~~
Packages are managed by the PackageManagerService. Addition and removal
of packages are monitored via the inotify framework, exposed via
android.os.FileObserver.

During initialization of a Dalvik process, ActivityThread.java requests
the process' AssetManager (by proxy, via AssetManager.java and JNI)
to load a list of packages. This list includes overlay packages, if
present.

When a target package or a corresponding overlay package is installed,
the target package's process is stopped and a new idmap is generated.
This is similar to how applications are stopped when their packages are
upgraded.


Creating overlay packages
-------------------------

Overlay packages should contain no code, define (some) resources with
the same type and name as in the original package, and be compiled with
the -o flag passed to aapt.

The aapt -o flag instructs aapt to create an overlay package.
Technically, this means the package will be assigned package id 0x00.

There are no restrictions on overlay packages names, though the naming
convention <original.package.name>.overlay.<name> is recommended.


Example overlay package
~~~~~~~~~~~~~~~~~~~~~~~

To overlay the resource bool/b in package com.foo.bar, to be applied
when the display is in landscape mode, create a new package with
no source code and a single .xml file under res/values-land, with
an entry for bool/b. Compile with aapt -o and place the results in
/system/overlay by adding the following to Android.mk:

LOCAL_AAPT_FLAGS := -o com.foo.bar
LOCAL_MODULE_PATH := $(TARGET_OUT)/overlay


The ID map (idmap) file format
------------------------------

The idmap format is designed for lookup performance. However, leading
and trailing undefined overlay values are discarded to reduce the memory
footprint.


idmap grammar
~~~~~~~~~~~~~
All atoms (names in square brackets) are uint32_t integers. The
idmap-magic constant spells "idmp" in ASCII. Offsets are given relative
to the data_header, not to the beginning of the file.

map          := header data
header       := idmap-magic <crc32-original-pkg> <crc32-overlay-pkg>
idmap-magic  := <0x706d6469>
data         := data_header type_block+
data_header  := <m> header_block{m}
header_block := <0> | <type_block_offset>
type_block   := <n> <id_offset> entry{n}
entry        := <resource_id_in_target_package>


idmap example
~~~~~~~~~~~~~
Given a pair of target and overlay packages with CRC sums 0x216a8fe2
and 0x6b9beaec, each defining the following resources

Name          Target package  Overlay package
string/str0   0x7f010000      -
string/str1   0x7f010001      0x7f010000
string/str2   0x7f010002      -
string/str3   0x7f010003      0x7f010001
string/str4   0x7f010004      -
bool/bool0    0x7f020000      -
integer/int0  0x7f030000      0x7f020000
integer/int1  0x7f030001      -

the corresponding resource map is

0x706d6469 0x216a8fe2 0x6b9beaec 0x00000003 \
0x00000004 0x00000000 0x00000009 0x00000003 \
0x00000001 0x7f010000 0x00000000 0x7f010001 \
0x00000001 0x00000000 0x7f020000

or, formatted differently

0x706d6469  # magic: all idmap files begin with this constant
0x216a8fe2  # CRC32 of the resources.arsc file in the original package
0x6b9beaec  # CRC32 of the resources.arsc file in the overlay package
0x00000003  # header; three types (string, bool, integer) in the target package
0x00000004  #   header_block for type 0 (string) is located at offset 4
0x00000000  #   no bool type exists in overlay package -> no header_block
0x00000009  #   header_block for type 2 (integer) is located at offset 9
0x00000003  # header_block for string; overlay IDs span 3 elements
0x00000001  #   the first string in target package is entry 1 == offset
0x7f010000  #   target 0x7f01001 -> overlay 0x7f010000
0x00000000  #   str2 not defined in overlay package
0x7f010001  #   target 0x7f010003 -> overlay 0x7f010001
0x00000001  # header_block for integer; overlay IDs span 1 element
0x00000000  #   offset == 0
0x7f020000  #   target 0x7f030000 -> overlay 0x7f020000

#+END_EXAMPLE

*** resources.arsc
resources.arsc 与 ResourceType.cpp 中的 ResTable 类有些对应关系: 一个 ResTable 包含多个
已经载入的 resources.arsc, 并通过 package 加以区分.

#+BEGIN_SRC ditaa :file 2.png

                                           +-------------+
                                           |   ResTable  |
                                           +------+------+
                                                  |
                                                  +--------------------+
                                                  |                    |
                                          +-------+------+     +-------+----------+
                                          | PackageGroup |     | PackageGroup ... |
                                          +-------+------+     +------------------+
                                                  |
                                                  |
                         +------------------------+
                         |                        |
                         |                        |
                 +-------+--------+        +------+------+
                 |   Package:...  |        |   Package:x |
                 +----------------+        +------+------+
                                                  |
                                    +-------------+--------+--------------------+
                                    |                      |                    |
                                    |                      |                    |
                              +-----+---------+       +----+-----------+    +---+--------+
                              |  Type String  |       |  Type Layout   |    | Type ...   |
                              +-----+---------+       +----------------+    +------------+
                                    |
                      +-------------+
                      |             |
               +------+---+     +---+------+
               | Config 1 |     | Config 2 |
               +----------+     +-----+----+
                                      | 
                                      |             
                     +---------+------+--+---------+
                     | Entry 1 | Entry 2 | Entry 3 |
                     +---------+---------+---------+
                      

#+END_SRC

#+RESULTS:
[[file:2.png]]

使用 ~aapt dump resources xxx.{apk,jar}~ 可以很直观的看到 ResTable 的树形结构:

#+BEGIN_EXAMPLE
  Package Groups (1)
  Package Group 0 id=127 packageCount=1 name=com.sunway.test
    Package 0 id=127 name=com.sunway.test typeCount=5
      type 0 configCount=0 entryCount=0
      type 1 configCount=3 entryCount=1
        spec resource 0x7f020000 com.sunway.test:drawable/ic_launcher: flags=0x00000100
        config 0 density=120 sdk=4
          resource 0x7f020000 com.sunway.test:drawable/ic_launcher: t=0x03 d=0x00000000 (s=0x0008 r=0x00)
        config 1 density=160 sdk=4
          resource 0x7f020000 com.sunway.test:drawable/ic_launcher: t=0x03 d=0x00000001 (s=0x0008 r=0x00)
        config 2 density=240 sdk=4
          resource 0x7f020000 com.sunway.test:drawable/ic_launcher: t=0x03 d=0x00000002 (s=0x0008 r=0x00)
      type 2 configCount=1 entryCount=2
        spec resource 0x7f030000 com.sunway.test:layout/main: flags=0x00000000
        spec resource 0x7f030001 com.sunway.test:layout/system_update_activity: flags=0x00000000
        config 0
          resource 0x7f030000 com.sunway.test:layout/main: t=0x03 d=0x00000003 (s=0x0008 r=0x00)
          resource 0x7f030001 com.sunway.test:layout/system_update_activity: t=0x03 d=0x00000004 (s=0x0008 r=0x00)
      type 3 configCount=2 entryCount=2
        spec resource 0x7f040000 com.sunway.test:string/app_name: flags=0x00000004
        spec resource 0x7f040001 com.sunway.test:string/test: flags=0x00000004
        config 0
          resource 0x7f040000 com.sunway.test:string/app_name: t=0x03 d=0x00000005 (s=0x0008 r=0x00)
          resource 0x7f040001 com.sunway.test:string/test: t=0x03 d=0x00000007 (s=0x0008 r=0x00)
        config 1 lang=zh cnt=CN
          resource 0x7f040000 com.sunway.test:string/app_name: t=0x03 d=0x00000006 (s=0x0008 r=0x00)
          resource 0x7f040001 com.sunway.test:string/test: t=0x03 d=0x00000008 (s=0x0008 r=0x00)
#+END_EXAMPLE

*** Preload Drawable
Preload Drawable 机制是 zygote 针对图片内存使用的一个优化. 
Zygote 进程是所有 java 进程的父进程, 在开机的早些阶段启动, 它启动后会
调用 preloadDrawable 预先加载一些系统图片, 这些图片会置于 zygote 的
AssetManager 的管理之下. 

AssetManager 不是一个集中式的 service, 相反, 对于每个进程, 都会有一个
AssetManager

每个进程都有 AssetManager, 会导致每个应用都需要各自加载各自的资源, 但这
种机制对于系统资源来说, 会造成内存的浪费, 因为所有系统资源对所有进程其
实都是一样的.

preloadDrawable 可以解决这种针对系统资源的浪费, 因为 zygote 是所有
java 进程的父进程, linux kernel 里的 COW (copy on write) 机制决定了
preloadDrawable 加载的资源是可以被所有 java 进程共享的. 

UUI 中将 preloadDrawable 禁用了, 是因为 drawable cache 的存在.
AssetManager 会维护一个 drawable cache, 通过 preloadDrawable 加载进来
的图片会一直放在 cache 中, 导致 UUI 无法在运行时替换到系统的图片. 

- UUI 若禁用 preloadDrawable, 会导致每个进程的 AssetManager 都去加载一
  份系统资源,浪费内存
- UUI 若不禁用 preloadDrawable, 会导致运行时系统图片无法被 UUI 替换. 

我们可以调整 zygote, 让它在启动预先加载 UUI 定义的图片, 而不是系统
默认的图片, 这样似乎是可以的, 但这样无法满足 UUI 的另一个 feature: 运
行时的主题切换. 

当运行时切换主题时, 必定要将所有进程的 AssetManager 中的系统资源替换掉,
而对每一个进程的`write`会触发 `copy-on-write` 中的 copy, 还是无法共享
资源.


综上, zygote 使用 `copy-on-write` 这种 trick 来共享系统资源, 但 UUI 的
动态切换主题功能使这种 trick 无法工作. 

解决方法

不使用 `copy-on-write' 这种 trick, 而是使用显式的 shared mmap 来共享系
统图片, 不过这种方式可能难以实现, 因为 dvm 是在 dalvik heap 中分配图片
内存的, 我们可能没有办法让它工作在其他的 vma. 

**** Resource drawable cache

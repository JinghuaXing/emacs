#+TITLE: Android Memory
* Android Memory
** tools
*** mat
*** valgrind
*** dumpsys meminfo
*** cat /proc/pid/smaps
*** procmem
*** procrank
** xss
- vss
  虚拟地址
- rss
  占用的物理内存, 包含和其他进程共享的 mmap 区域
- pss
  物理内存, 但共享的部分会按比例分配
- uss
  物理内在, 不包含共享的部分

所谓`共享'的部分, 不仅仅包含共享库,实际上,页表上所有物理页只要被多个进
行共享 (包含 cow 这种情况) 就不会被计入 uss.

例如:
#+BEGIN_SRC c
  int main(int argc, char *argv[]) {
      fork();
      sleep (1000);
      return 0;
  }
#+END_SRC

以上的代码, 

当没有 fork 时, procrank 显示为:
#+BEGIN_EXAMPLE
1905    1396K    1392K     582K     556K  test_sqlite
#+END_EXAMPLE

当有 fork 时, procrank 显示为:

#+BEGIN_EXAMPLE
1975    1328K    1324K     323K      24K  test_sqlite
1974    1404K    1400K     313K      12K  test_sqlite
#+END_EXAMPLE

注意看 uss 的差别. 

** allocation
** recycle
[[http://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/index.html][Android 操作系统的内存回收机制]]
*** oom adj
#+BEGIN_SRC java
  static int HIDDEN_APP_MAX_ADJ = 15;
  static int HIDDEN_APP_MIN_ADJ = 9;
  
  // The B list of SERVICE_ADJ -- these are the old and decrepit
  // services that aren't as shiny and interesting as the ones in the A list.
  static int SERVICE_B_ADJ = 8;
  
  // This is the process of the previous application that the user was in.
  // This process is kept above other things, because it is very common to
  // switch back to the previous app.  This is important both for recent
  // task switch (toggling between the two top recent apps) as well as normal
  // UI flow such as clicking on a URI in the e-mail app to view in the browser,
  // and then pressing back to return to e-mail.
  static int PREVIOUS_APP_ADJ = 7;
  
  // This is a process holding the home application -- we want to try
  // avoiding killing it, even if it would normally be in the background,
  // because the user interacts with it so much.
  static int HOME_APP_ADJ = 6;
  
  // This is a process holding an application service -- killing it will not
  // have much of an impact as far as the user is concerned.
  static int SERVICE_ADJ = 5;
  
  // This is a process currently hosting a backup operation.  Killing it
  // is not entirely fatal but is generally a bad idea.
  static int BACKUP_APP_ADJ = 4;
  
  // This is a process with a heavy-weight application.  It is in the
  // background, but we want to try to avoid killing it.  Value set in
  // system/rootdir/init.rc on startup.
  static int HEAVY_WEIGHT_APP_ADJ = 3;
  
  // This is a process only hosting components that are perceptible to the
  // user, and we really want to avoid killing them, but they are not
  // immediately visible. An example is background music playback.
  static int PERCEPTIBLE_APP_ADJ = 2;
  
  // This is a process only hosting activities that are visible to the
  // user, so we'd prefer they don't disappear.
  static int VISIBLE_APP_ADJ = 1;
  
  // This is the process running the current foreground app.  We'd really
  // rather not kill it!
  static int FOREGROUND_APP_ADJ = 0;
  
  // This is a system persistent process, such as telephony.  Definitely
  // don't want to kill it, but doing so is not completely fatal.
  static final int PERSISTENT_PROC_ADJ = -12;
  
  // The system process runs at the default adjustment.
  static final int SYSTEM_ADJ = -16;
  
#+END_SRC
java 层定义的 oom adj 和 low memory killer 及 oom killer 使用的 oom
adj 是对应的, framework 会通过 /proc 将上层设定的 oom adj 传递给
kernel.

low memory killer 会维护一个 oom adj 与 系统最低内存的 threshold 的关系,
当系统内存少于此 threshold 时, 所有高于该 oom adj 的进程都会成为可能
的 victim, low memory killer 会从这些 victim 中选择一个杀掉

#+BEGIN_SRC c
  static int lowmem_adj[6] = { 
      0, 
      1, 
      6, 
      12, 
  }; 
  static int lowmem_adj_size = 4; 
  static size_t lowmem_minfree[6] = { 
      3 * 512,      /* 6MB */ 
      2 * 1024,     /* 8MB */ 
      4 * 1024,     /* 16MB */ 
      16 * 1024,    /* 64MB */ 
  }; 
  static int lowmem_minfree_size = 4; 
#+END_SRC

可见, 进程的 oom adj 小于 0 的话, 是不可能被 lmk 杀掉的, 这类的 oom
adj 只有两种:

- PERSISTENT_PROC_ADJ = -12;
  对应 persist 进程

- SYSTEM_ADJ = -16;
  对应 system 进程

*** trimApplications
**** activityIdle
当 resumeActivity 完成后, 新启动的 activity 会在自己的 MessageQueue 上
注册一个 idler, 该 idler 会执行 ams.activityIdle, 以便 finish 之前的
activity, 并做一些清理的动作. 

#+BEGIN_SRC text
  activityIdleInternal()
    // 调用之前的 activity 的 onStop
    for (i=0; i<NS; i++):
        ActivityRecord r = (ActivityRecord)stops.get(i);
        stopActivityLocked(r);
    // 调用之前 activity 的 onDestroy      
    for (i=0; i<NF; i++):
        ActivityRecord r = (ActivityRecord)finishes.get(i);
        destroyActivityLocked(r, true, false, "finish-idle");
    mService.trimApplications();
      // First remove any unused application processes whose package 
      // has been removed. 
      for (i=mRemovedProcesses.size()-1; i>=0; i--):
        // kill process;
        // mRemovedProcesses 是之前通过 handleAppCrashLocked, 或者
        // killAllBackgroundProcesses, 或者 killPackageProcessesLocked
        // 等被标记为 kill 的进程.
        Process.killPackageProcessesLocked()
        cleanUpApplicationRecordLocked()
  
      // Now update the oom adj for all processes.
      // 最关键的代码, 包括计算 oom adj, trim memory, 关闭过多的后台
      // 进程等 ...
      updateOomAdjLocked();
       foreach process:
         updateOomAdjLocked();
           computeOomAdjLocked();
         if (!app.killedBackground):
           // 若当前进程的 adj 为后台, 则台台进程过多, 则 kill 该进程
           // 其中 MAX_HIDDEN_APPS 定义为 15
            if (app.curAdj >= ProcessList.HIDDEN_APP_MIN_ADJ) {
                numHidden++;
                if (numHidden > MAX_HIDDEN_APPS):
             app.killedBackground = true;
             Process.killProcessQuiet(app.pid);
         // fi app.killedBackground  
        // foreach end
        // 然后根据 numHidden 计算一个 trim level, 然后根据 adj, trim level
        // 等决定向哪些 app 发送 onTrimMemory(level) 调用.
        // TODO: how to calculate trim level
#+END_SRC
**** To summaries
在适当的时候, updateOomAdj 会被调用, 主要作用是:
1. 修改所有进程的 adj, 并通知 kernel
2. 根据 MAX_HIDDEN_APPS kill 某些后台应用
3. 对剩下来的某些应用调用 onTrimMemory, 并指定不同的 trim level
*** low memory killer

** misc
*** bionic optimization for malloc ?
#+BEGIN_SRC c
  char * buffer = (char *) malloc(1024*1024*50);
  int i=0;
  for (i=0;i<1024*1024*50; ++i) {
      buffer[i]=1;
  }
#+END_SRC

above code in linux will consume 50MB rss as expected, but under
androd, rss is not consumed at all? Seems there is a kind of
optimization ? 

#+BEGIN_SRC c
  char * buffer = (char *) malloc(1024*1024*50);
  int i=0;
  for (i=0;i<1024*1024*50; ++i) {
      buffer[i]=random();
  }
#+END_SRC

But if we fill the memory will `random', both linux and android will
consume 50MB rss.

** Reference
- [[http://stackoverflow.com/questions/2298208/how-to-discover-memory-usage-of-my-application-in-android][how-to-discover-memory-usage-of-my-application-in-android]]
- [[http://stackoverflow.com/questions/131303/linux-how-to-measure-actual-memory-usage-of-an-application-or-process][linux-how-to-measure-actual-memory-usage-of-an-application-or-process]]

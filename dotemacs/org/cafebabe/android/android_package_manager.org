#+TITLE: Android PackageManager
* PackageManagerService
** PMS
** MountService
** Vold
** Installd
installd is a system binary running as `root` and listening on
`installd` socket. see [[@dalvik-cache]]

- when installing and uninstalling package, PMS need to mkdir/rmdir
  /data/data/xxx, but those data dirs is not accessable by PMS (PMS
  running with `system` uid, while data dirs is owned by package uids
  like `app_1`), so PMS need to use `installd` to access those data
  dir.
- after package is installed / deleted, PMS need invoke dex_opt /
  rm_dex to do the dirty work like optimize dex to dalvik-cache or
  remove dalvik-cache, those works are also delegated to installd.

** ASEC
** Topics
*** scanPackage
**** internal package
**** external package
1. MountService init NativeDaemonConnector to connect to the vold
#+BEGIN_SRC text
  MountService.init
    mConnector = new NativeDaemonConnector(this, "vold", ...)
#+END_SRC
2. mConnector.onDaemonConnected()
#+BEGIN_SRC text
  onDaemonConnected())
    // PMS.java
    mPms.scanAvailableAsecs();
      updateExternalMediaStatusInner(true, false, false);
      list = PackageHelper.getSecureContainerList();
        getMountService().getSecureContainerList();
          // MountService.java
          mConnector.executeForList("asec", "list")
            // CommandListener.cpp
            listAsecsInDirectory(cli, Volume::SEC_ASECDIR_EXT);
            listAsecsInDirectory(cli, Volume::SEC_ASECDIR_INT);
      foreach (cid:list):
        // cid 格式为: com.xx.xx.xx-1, 其 package name 为 com.xx.xx.xx
        pkgName = getAsecPackageName(cid);
        ps = mSettings.mPackages.get(pkgName);
        if (ps == null):
          // mSettings 中没有登记这个 cid? 可以这个 sd 卡是从别处拿的吧
          removeCids.add(cid);
        AsecInstallArgs args = new AsecInstallArgs(cid,isForwardLocked(ps));
        processCids.put(args, ps.codePathString);
      // foreach ends here
      loadMediaPackages(processCids, uidArr, removeCids);
        for (AsecInstallArgs args : keys):
          args.doPreInstall();
            String newCachePath = PackageHelper.mountSdDir(cid, getEncryptKey(),Process.SYSTEM_UID);
              getMountService().mountSecureContainer(cid, key,ownerUid);
                mConnector.execute("asec", "mount", id, key, ownerUid);
            setCachePath(newCachePath);
          PackageParser.Package pkg = scanPackageLI(new File(codePath),  parseFlags);
          // 注意, scanPackageLI 对于 external
          //  package, 会负责在 data/data/xxx/ 下生成到
          //  /mnt/asec/xxx/lib 的 symlink
          args.doPostInstall()
        updatePermissionsLP()
        mSettings.writeLPr();

#+END_SRC

*** umount sdcard
#+BEGIN_SRC text
  MountService.onDaemonConnected();
    updatePublicVolumeState(path, state);
      mPms.updateExternalMediaStatus(false, false); // false for umount
        sendMsg (UPDATED_MEDIA_STATUS)
          mPms.unloadAllContainers(all_asecinstallargs);
            for (AsecInstallArgs arg : cidArgs):
              PackageHelper.unMountSdDir(cid);
          PackageHelper.getMountService().finishMediaUpdate();
          // MountService
            ucb.handleFinished();
              doUnmountVolume(path, true, removeEncryption);
                //vold: volumn unmount
        updateExternalMediaStatusInner();
          if (isMounted):
              loadMediaPackages(processCids, uidArr, removeCids);
              startCleaningPackages();
          else:
              unloadMediaPackages(processCids, uidArr, reportStatus);
                for (AsecInstallArgs args : cids):
                  deletePackageLI(..., PackageManager.DONT_DELETE_DATA,...);
                  // DONT_DELETE_DATA !

#+END_SRC

**** To summaries

1. umount 消息最初由 MountService 从 vold 获取
2. MountService 通过 PMS 先 umount 所有的 ASEC 设备, 并在完成后通知 MountService
3. 同时 MountService 会通过 deletePackageLI 删除 ASEC 上的程序, 但保留
   数据.
4. MountService 获得通知后调用 vold 的 `volume unmount`, 真正 umount
   sdcard.
   1) vold 的 volumn umount 也不是简单的 umount sdcard, 它会 umount
      /mnt/secure, /mnt/sdcard/.android_secure 等. 并 kill 打开 sdcard 的
      进程.

*** usb mass storage mode (UMS 模式)
sdcard 除了 mounted, umounted 状态外, 还有一个状态是 shared,  当 usb
切换为 mass storage mode 时, sdcard 卡变为 shared 状态, 此时对于 PMS
来说, 相当于 umounted 状态.

*** 进入 UMS 模式

进入 UMS 模式只有一种方法: 通过 MountService.setUsbMassStorageEnabled()

#+BEGIN_SRC text
  MountService.setUsbMassStorageEnabled()
    if (enable
        && (vs.equals(Environment.MEDIA_MOUNTED))):
      setUmsEnabling(enable);
      // 调用 vold: volumne ums 命令
      UmsEnableCallBack umscb = new UmsEnableCallBack(path, method, true);
      // umscb 在 updateExternalMediaStatus 在 finish 阶段 (asec umount 完成)
      // 会调用 doShareUnshareVolume(path, method, true); 以 setup UMS
      mHandler.sendMessage(mHandler.obtainMessage(H_UNMOUNT_PM_UPDATE, umscb));
        mPms.updateExternalMediaStatus(false, true); // false 指 umount
      setUmsEnabling(false); // setUmsEnabling 表示 UMS enabling 状态
    if (!enable): // UMS 模式取消
      doShareUnshareVolume(path, method, false);
      // false 指调用 vold: volume unshare 命令
      doMountVolume(path);
      // 重新 mount
#+END_SRC

*** 退出 UMS 模式

退出 UMS 模式有两种方法,
1. 主动调用上面提到的 setUsbMassStorageEnabled,
2. 拔下 USB 线 ... :(

当 USB 线拔掉时, UsbManager 会发相应的 intent, PMS 负责重新 mount
sdcard, 然后 mount 动作会间接导致 vold 上报 mounted 消息, 从而导致
updatePublicVolumeState 等, 最终 setup ASEC.

#+BEGIN_SRC text
  Intent.UsbManager.ACTION_USB_STATE // from UsbManager
    available = (intent.getBooleanExtra(UsbManager.USB_CONNECTED, false) &&
                intent.getBooleanExtra(UsbManager.USB_FUNCTION_MASS_STORAGE, false));
    notifyShareAvailabilityChange(available);
      // 若 USB 断开, 或者 USB 接着, 但当前 USB 并不是 UMS 模式,
      // 例如连接 USB 为充电模式
      if (avail == false
          && getVolumeState(path).equals(Environment.MEDIA_SHARED)):
        doShareUnshareVolume(path, "ums", false);
        doMountVolume(path);
#+END_SRC

*** installPackage

- there are 2 ways to install package:
   1. push xxx.apk to any folder of /data/app, /system/app, /system/framework
   2. use PackageInstaller or adb install (which will invoke PM.installPackage())

- `system` application & 3rd application
  `system` is a property of ApplicationInfo after installation.
  `system` application are applications not listed in `downloaded` category in Settings, while 3rd applications are applications listed in `downloaded`
  category.

  PackageManager will decide whether a newly installed application is a `system` application:
  - if apk is pushed to /system/app & /system/framework, then it is `system` application
  - if apk is replacing an existing old system application, then it is.
  - ...

**** internal package
***** adb push
#+BEGIN_SRC java
  FileObserver.onEvent()
    isApk=isPackageFilename():
      name.endsWith(".apk");
    if !isApk:return;
    if ignoreCodePath(fullPathStr):   ;; if apk name is like "xxx-1.apk", it will be ignored!
                                      ;; this is because PM.installPackage will also put installed package to /data/app, PM.installPackage use the
                                      ;; special naming rule to prevent FileObserver from installing the apk again.
      return
    if ADD_EVENTS:
      scanPackageLI(mIsRom?PARSE_IS_SYSTEM:0) ;; if apk is in /system/app or /system/framework, mIsRom is true
                                              ;; package with PARSE_IS_SYSTEM flag will be marked as `system` application
      updatePermissionsLP()
    if REMOVE_EVENTS:
      removePackageLI()
    if addedPackage!=null:
      sendPackageBroadcast(ACTION_PACKAGE_ADDED)
    if removedPackage!=null:
      sendPackageBroadcast(ACTION_PACKAGE_REMOVED)
#+END_SRC
***** installPackage
****** install location (src & dest)
******* src apk location
 - from DownloadManager through ContentProvider
 - from file though MediaContainerService
******* app install location
the apk's install location can be internal flash / sdcard.
1. The apk's manifest may declares it's `install location`, including:
  - auto
  - internalOnly
  - preferExternal
2. PackageHelper.recommendAppInstallLocation() make the ultimate decision:
  - if `install location` is not set in manifest, internal will always be selected
  - auto
    if apk's code size>1MB, location will be set to external, unless external storage is slow (<10% free space..
  - internalOnly
    internal will be selected
  - preferExternal
    always selected external unless storage is unavailable or inefficient.
  - system setting for default installation location is also considered
To summurize:
   - manifest's `install location`
   - system setting for `default install location`
   - internal/external storage status

****** MediaContainerService / DefaultContainerService
see [[@MountService]]
see [[@secure_container]]

MediaContainerService is mainly used by app with `system' uid to
access sdcard, because `system' process can't access sdcard, because:

******* `system` process can't access sdcard

#+BEGIN_SRC fundamental
$ ls sdcard
d---rwxr-x system sdcard_rw 2010-07-26 12:56 sdcard
#+END_SRC

#+BEGIN_QUOTE

http://stackoverflow.com/questions/5617797/android-shared-user-id-and-reading-writing-a-file

The system user can not access the SD card, because if the SD card
gets unmounted it may need to kill any processes that have files open
on it and we don't want system processes being killed like that. If
you want to access the SD card, you need to not use the system shared
user ID.

#+END_QUOTE

即, 因为 sdcard 的权限对 `system` 用户是 000, 所以 `system` 用户无法访
问.即 sharedUserId 为 `system` 的 java 进行无法访问. 而 sdcard 对
system 权限之所以为 000, 是 vold 在 mount 时使用了如下命令:

#+BEGIN_SRC java
  Fat::doMount(devicePath, getMountpoint(), false, false, false,AID_SYSTEM, gid, 0702, true)
#+END_SRC

即使用702做掩码, 使 system 无法访问 sdcard.


之所以这样做, 是因为 sharedUserId 为 `system` 的 app 可以将其 process
设置为 `system`, 这样的话一旦该 app 访问了 sdcard, 当 sdcard 被
umount 时, vold (可能)会将该进程 (也就是 system 进程) kill

#+BEGIN_SRC text
  VolumeManager::unmountLoopImage
    for (i = 1; i <= UNMOUNT_RETRIES; i++):
      rc = umount(mountPoint);
      if succ:
        break;
      else:
        int action = 0; // default is to just complain
        if (i > (UNMOUNT_RETRIES - 2))
            action = 2; // SIGKILL
        else if (i > (UNMOUNT_RETRIES - 3))
            action = 1; // SIGHUP
        Process::killProcessesWithOpenFiles(path, action);
        usleep(UNMOUNT_SLEEP_BETWEEN_RETRY_MS); // 1s
#+END_SRC

可见, 在 umount 时系统会尝试多次, 若一直失败, 则 kill 相关的进程, 否则
只是 complain 一下, 并不会 kill 进程. 而 umount 失败的条件是 umount
时有文件正在被读写 (或者 page cache 被刷新?), 而不是有 fd 被打开...

**** external package
*** replacePackage
*** uninstallPackage
**** Intent.ACTION_PACKAGE_REMOVED
*** resolveActivity
as shown in [[IntentFilter matching][IntentFilter matching]], startActivity will call
PM.resolveIntent to resolve the intent, and get one best ResolveInfo;

PM.resolveActivity() will also call PM.resolveIntent() to resolve the
intent, but there is ONE difference, PM.resolveActivity will not force
the DEFAULT_ONLY flag set when calling resolveIntent(). but
startActivity will.
*** forward_lock

adb install -l xxx.apk ( -l means `forward_lock` install )

when xxx.apk is `forward_lock` installed

- it's orig .apk is deleted
- it's res/, manifest.xml is put to /data/app/xxx.zip (note that .dex
  is cached in dalvik-cache)

*** uid & gid
see also [[Java Process Creation]], [[Zygote]], [[System Init]] to distinguish
`process uid' against `file uid'

UID (including sharedUserId) is maintained by pm.Settings

**** pre-defined UID
see system/core/include/private/android_filesystem_config.h

#+BEGIN_SRC c
  static const struct android_id_info android_ids[] = {
      { "root",      AID_ROOT, },
      { "system",    AID_SYSTEM, },
      { "radio",     AID_RADIO, },
      { "bluetooth", AID_BLUETOOTH, },
      { "graphics",  AID_GRAPHICS, },
      { "input",     AID_INPUT, },
      { "audio",     AID_AUDIO, },
      { "camera",    AID_CAMERA, },
      { "log",       AID_LOG, },
      { "mount",     AID_MOUNT, },
      { "wifi",      AID_WIFI, },
      { "dhcp",      AID_DHCP, },
      { "adb",       AID_ADB, },
      { "install",   AID_INSTALL, },
      { "media",     AID_MEDIA, },
      { "sdcard_r",  AID_SDCARD_R, },
      { "sdcard_rw", AID_SDCARD_RW, },
      { "media_rw",  AID_MEDIA_RW, },
      // ...
      { "vpn",       AID_VPN, },
      { "keystore",  AID_KEYSTORE, },
      { "usb",       AID_USB, },
      { "mtp",       AID_MTP, },
      { "gps",       AID_GPS, },
      { "inet",      AID_INET, },
      { "net_raw",   AID_NET_RAW, },
      { "net_admin", AID_NET_ADMIN, },
      { "net_bw_stats", AID_NET_BW_STATS, },
      { "net_bw_acct", AID_NET_BW_ACCT, },
      { "misc",      AID_MISC, },
      { "nobody",    AID_NOBODY, },
  };
#+END_SRC

**** uid generation
during scanPackageLI, but before mInstaller.install(), app UID is
generate by the mSettings.
#+BEGIN_SRC text
  scanPackageLI
    // Just create the setting, don't add it yet. For already existing packages
    // the PkgSetting exists already and doesn't have to be created.
    pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile,
                      destResourceFile, pkg.applicationInfo.nativeLibraryDir,
                      pkg.applicationInfo.flags, true, false);
      p.appId = newUserIdLPw(p);
        final int N = mUserIds.size();
          for (int i = 0; i < N; i++) {
              if (mUserIds.get(i) == null) {
                  mUserIds.set(i, obj);
                  return Process.FIRST_APPLICATION_UID + i;
              }
          }
          // None left?
          if (N > (Process.LAST_APPLICATION_UID-Process.FIRST_APPLICATION_UID)) {
              return -1;
          }
          mUserIds.add(obj);
          return Process.FIRST_APPLICATION_UID + N;
    pkg.applicationInfo.uid = pkgSetting.appId;
#+END_SRC
**** sharedUserId
***** sharedUserId pre-defined by the PMS
#+BEGIN_SRC java
PackageManagerService.<init>
  mSettings.addSharedUserLPw("android.uid.system", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw("android.uid.phone", RADIO_UID, ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw("android.uid.log", LOG_UID, ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw("android.uid.nfc", NFC_UID, ApplicationInfo.FLAG_SYSTEM);
#+END_SRC

That is,
- android.uid.system
- android.uid.phone
- android.uid.log
- android.uid.nfc

these 4 sharedUserId is defined statically in PMS, and they
corresponds to the static UID (SYSTEM_UID, RADIO_UID, ...)

***** sharedUserId defined by app
App can define `sharedUserId' freely, PMS will use `Setings' to
maintain the dynamic `sharedUserId' -> `uid' mapping during `scanPackageLI'

The most well-known app `sharedUserId' is `android.uid.shared', which
is defined by `Contacts' and `ContactsProvider'

*** multi-user

android 4.1 use UserManager to support multi-user, in-short, uid
stored in pm.Setting is encoded as a mixer of multi-user-id and
app_id, e.g. u0_a33, or u1_a33.

As against android pre 4.1, app_id is taken as uid.

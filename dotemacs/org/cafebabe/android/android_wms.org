#+TITLE: Android WindowManager
* WindowManager
** Client side
*** View
**** padding vs. margin
padding = 内边距
margin =  外边距
内,外是相对于容器(盒子)的边界而言, 以Button为例,Button可以看作一个盒子,设置button.padding会影响Button里的文字或图片与Button边界的距离,例如:

Button
#+BEGIN_EXAMPLE
       -+---------------+
       	|[padding] click|
       -+---------------+
#+END_EXAMPLE

而button.margin会影响button与其更外层盒子(如layout)的边界

LinearLayout
#+BEGIN_EXAMPLE
       -+-------------------+
       	| [top margin] 	    |
       	|+-------------+    |
       	|| button      |    |
       	|+-------------+    |
       -+-------------------+
#+END_EXAMPLE

需要注意的一点是,android中view是没有margin属性的,只有 ViewGroup 才有margin属性, 所以,如果想达到上图的效果,不可能直接设置button的margin,而是需在将button
放在一个 ViewGroup 中,然后设置该 ViewGroup 的margin.

**** DecorView
**** drawing cache
*** ViewGroup
*** Window
对于ViewRoot来说,顶层的`Window`就是一个普通的View, 但有些和`Window`有关
的操作,如:

 - panel 的处理
 - 处理 window title, window icon ...
 - 从WMS来的一些事件如何通知给Activity,Dialog, 例如onBackPressed()

因为, 提供了一个Window类, 用来处理这些和`Window`有关的操作, 但从WMS及
ViewRoot的角度看,并没有`Window`的概念.

只有DecorView能和Window关联,来处理`Window`相关操作 (因为DecorView是
Window的inner class), 所以只有Activity,Dialog有window的概念

在 WMS 一侧也有一个 `window` 的概念, 因为它是 `WindowManager` 嘛, 不
过 WMS 的 `window` 是叫 WindowState, 而不是 PhoneWindow, 它侧重的是
Window 的管理, 例如:

1. LayoutParams
   1. Window 的类型: 应用的 window, 系统的 window, 输入法的, statusbar 的, ....
   2. x,y,heigth,width,...
   3. 一些特殊的 flag, 例如 FLAG_KEEP_SCREEN_ON, FLAG_FULLSCREEN
2. window 的 z-order
3. window 所属的 Activity (AppWindowToken)
4. window 对应的 ViewRoot (WindowToken)

对 WMS 来说, 每个 Window 对应一个 ViewRoot 以及一个 Surface, 有
z-order 的区别, 但对于 ViewRoot 来说, 其管理的 View 都画在一个
Surface 上, 没有 z-order 的区别.

**** PhoneWindow
*** ViewRoot

ViewRoot 的几点功能:

1. 通过 IWindowSession 与 WMS 联系
2. WMS 通过 ViewrRoot 提共的 IWindow 与 ViewRoot 通信.
3. ViewRoot 维护了一个 Surface, 可以供各个 view 进行 draw
4. ViewRoot 维护一个 InputChannel, 进行 event dispatching.

总之, ViewRoot 是应用进程中除 ActivityThread 外最重要的一个东西, 它负
责与 WMS 交互, 并维护 Surface 和 InputChannel.

*** WindowManagerImpl
*** To summarize
**** ViewRoot, View (DecorView) and Window
- 与WMS直接打交道的是ViewRoot,WMS能直接看到的只有ViewRoot (通过ViewRoot注册到WMS的IWindow mClient)

- ViewRoot直接管理其顶层View (对于Actity,Dialog, 即DecorView. 对于

  PopupWindow及手动通过WindowManagerImpl.addView添加的view, 其顶层view只是普
  通的view), 所以一个进程可以有多个ViewRoot

- Window是和DecorView一一对应的.

  因为Activity, Dialog项层view是DecorView, 所以有window的概念, 可以通
  过Window来控制ContextMenu, 调用Window.Callback等;

- Window与Activity,Dialog对应

  通过Window.Callback, 可以和Activity和Dialog联系起来,因为它们都实际了
  Window.Callback接口.而PopupWindow顶层只是普通view,所以没有Window的概念

综上:
  - WMS<-->ViewRoot
  - ViewRoot<-->DecorView
  - DecorView<-->Window<-->Activity,Dialog
** Server side
*** WindowManagerService
**** WindowState
***** mClient
IWindow as the mClient
***** WindowToken
***** AppWindowToken

AppWindowToken 由 WMS 初始化, 并维护在一个 mTokenMap 中, mTokenMap 的
key 是 AMS 生成的 Token 对象, 这个 Token 对象是由 AMS 在启动 Activity
时初始化, 保存在 WMS.ActivityRecord 中, 然后传递给 ActivityThread, 并保
存在 ActivityThread.ActivityClientRecord 中.

即: AMS.Token 由 AMS 生成, AppWindowToken 由 WMS 生成.

#+BEGIN_EXAMPLE

 +----------------------------------------+               +----+-----+           +-------------------------------------+
 | WMS.mTokenMap <Token, AppWindowToken > +---------------+   Token  +-----------+ ActivityThread.ActivityClientRecord |
 +------------------------------+---------+               +----+-----+           +-------------------------------------+
                                |                              |
                                |                              |
                          +-----+-------+             +--------+-----------+
                          | WindowState |             | AMS.ActivityThread |
                          +-------------+             +--------------------+
                          | WindowState |
                          +-------------+
                          | ...         |
                          +-------------+

#+END_EXAMPLE

*** WindowManagerPolicy
**** PhoneWindowManager
** Topics
*** View
**** init (addView)
window.addView() will firstly gen (viewRoot,view,layout_param) tuple,
then call ViewRoot.setView() to ask WMS to add the view. since
ViewRoot has an IWindowSession, and it will send IWindow to WMS (as
mClient), it can communicate with WMS back and forth.

window.addView() will add [new viewroot,decorView] tuple to
WindowManagerImpl.

Activity and Dialog will generate decorView automatically, then call
WM.addView(decorView) to window.  but PopupWindow will not generate
decorView since PopupWindow need not to be `decorated`.
**** requestLayout
#+BEGIN_SRC text
  View.requestLayout()
    mParent.requestLayout() ;; for a view, mParent is the upper ViewGroup
      mParent.requestLayout() ;; ViewGroup implements View, thus recursive again to the parent
        ...
          top_view.requestLayout()
            ViewRoot.requestLayout() ;; top view's mParent is the ViewRoot
#+END_SRC

#+BEGIN_SRC text
  ViewRoot.requestLayout()
    ViewRoot.scheduleTraversals()
      ViewRoot.performTraversals() handles the msg
        mView.dispatchAttachedToWindow() ;; mView is the ViewRoot's top view
          ViewGroup.dispatchAttachedToWindow()
            view.dispatchAttachedToWindow() for every child view of the ViewGroup
              view.onAttachedToWindow() ;;  see [[onAttachedToWindow][onAttachedToWindow]]
        mView.measure()
          mView.onMeasure()
            layout.onMeasure() ;; e.g. LinearLayout, FrameLayout
              view.measure() ;; for every child view of the layout, including margin
                view.onMeasure() ;; see [[onMeasure][onMeasure]]
        mView.layout()
          layout.layout() ;; e.g. LinearLayout
            view.layout() ;; it seems that view.layout && view.onLayout doesn't do something meaningful?  it mainly stores the child's x,y,width,height
                          ;; so that we can, when touch the screen, tell which view is touched
              view.onLayout() ;; see [[onLayout][onLayout]],
#+END_SRC
**** invalidate

invalidate 不会导致 measure 和 layout, 虽然它也会导致
performTraversals, 但在 traversal 过程中因为 layoutRequested 为false,
导致 measure, layout 都不执行, 只执行最后一步 draw 操作.

另外, invalidate 可以指定一个 dirty rect (不指定时 dirty rect 为整个
window), 这样 canvas 在 draw 的过程中可以忽略那个不在这个 dirty rect
中的那些 view (通过 canvas.quickReject), 实现局部刷新.

- invalidate 与 requestLayout 的不同
  invalidate 只会导致 draw (可能只是 dirty 部分的 draw), 但
  requestLayout 会导致整个 windows 的 measure, layout, draw

**** measure
**** layout
***** android:layout_gravity & android:gravity
during onMeasure, view's size is fixed, after-wards, ViewGroup.onLayout will re-position children views and invoke child.onLayout to notify children
for their position.

- similar with android:height, only a few views or ViewGroup has the android:gravity property.
  e.g. TextView has the android:gravity property, so that the inner text can be positioned to top/bottom/left/right
  LinearLayout also has the android:gravity, which control Linear Layout's children's gravity as a whole.
******* How does LinearLayout make use of gravity.
- for *Vertical* LinearLayout with layout_height= *fill_parent* :
  vertical LinearLayout can only set it's android:gravity to `top,bottom,center_vertical`, which can move the children as a whole in
  vertical direction.
  vertical LinearLayout's child can set their android:layout_gravity to `left,right,center_horizontal`,which can move a single child view
  in the horizontal direction.

  that is, if u want to position a view in vertical LinearLayout to right-bottom, u can:
  - set LinearLayout.android:gravity to bottom
  - set view.android:layout_gravity to right

#+BEGIN_EXAMPLE
	    vertical LinearLayout      	       	      set android:gravity to bottom   		& set view1.layout_gravity to right
	   -+-----------------------+                -+-----------------------+                -+--------------------------+
	    |-+-------------+	    |		      |			      |		       	|		 	   |
	    | |	 view1	    |	    |		      |			      |		       	|		 	   |
	    | |	      	    |	    |		      |			      |		       	|		 	   |
	    |-+-------------+	    |		      |			      |		       	|		 	   |
	    | |	 view2	    |	    |		      | 		      |		       	|		 	   |
	    | |		    |	    |		      | 		      |		       	|		 	   |
	    |-+-------------+	    |		      |-+--------------+      |		       	|  	    -+-----------+ |
	    |			    |		      |	|  view1       |      |		       	|  	     |	view1	 | |
	    |			    |		      |	|  	       |      |		       	|      	     | 	     	 | |
	    |			    |		      |-+--------------+      |		       	| -+---------+--+--------+ |
	    |			    |		      |	|  view2       |      |		       	|  |  view2    	|    	   |
	    |			    |		      |	|      	       |      |		       	|  |		|    	   |
	    |			    |		      |-+--------------+      |		       	| -+------------+  	   |
	   -+-----------------------+		     -+-----------------------+		       -+--------------------------+
#+END_EXAMPLE

- for horizontal LinearLayout:
	  vice-versa

**** draw
see also [[android graphics]]
**** focus switching
when press 'left' key, how the focus is changed?

1. when viewRoot got the key event, it will firstly call
   'dispatchKeyEventToViewHierachy' to dispatch the key event to it's
   correspondingg top level viw (i.e. DecorView)
2. If the key event is not handled by the view hierachy, viewRoot will
   call 'findFocus' to find next focus in 'handleFinishedEvent'
3. If the current focused view has set 'focus:right...' properties,
   viewRoot will call view.findViewById to find the next focus, or
   find the nearest focusable view in a specified rectangle area.

*** ViewRoot
**** init
*** WindowToken, AppWindowToken and WindowState
[[http://blog.csdn.net/luoshengyang/article/details/8498908][Android窗口管理服务WindowManagerService对窗口的组织方式分析]]

**** addWindow
Activity, Service, IME 等都可以 addWindow, 但有时 addWindow 会出错, 这
是为何?

1. 对于 sevice 来说, 为何可以显示 toast, 却不可以显示 dialog?
2. service 如何显示一个 window ?
3. activity 挂掉后再显示一个 window 为何报错?
4. IME, wallpaper 的 window 是怎么个情况? 是否受 activity 的生命期的控
   制?

***** Activity
#+BEGIN_SRC text
  startActivityLocked()
    mService.mWindowManager.addAppToken(addPos, r.appToken,...)
      mTokenMap.put(token.asBinder(), wtoken);
#+END_SRC

即 Activity 启动后, WMS.mTokenMap 中会新增一项对应于该 Activity 的
WindowToken (实际上为 AppWindowToken)

***** Service
Service 启动时不会于 PMS 添加任何 token

***** IME
#+BEGIN_SRC text
  InputBindResult startInputInnerLocked()
    mCurToken = new Binder();
    mIWindowManager.addWindowToken(mCurToken,WindowManager.LayoutParams.TYPE_INPUT_METHOD);
#+END_SRC

***** addWindow
#+BEGIN_SRC text
  WMS.addWindow(Session session, IWindow client, ...)
    WindowToken token = mTokenMap.get(attrs.token);
    // 对于 Activity 来说, token 肯定不为 null, 并且 token 应该是
    // 一个 AppWindowToken

    // 对于 Service 来说, token 可能为 null (因为 service 启动时没有注册
    // 任何 token), 也可能不为 null (例如之前 show 过 toast, 详见
    // addToToken 变量)

    // 对于 IME 来说, token 应该不为 null, 因为 startInputInnerLocked 会
    // 注册一个 WindowToken (非 AppWindowToken)

    if (token == null):
      if (attrs.type >= FIRST_APPLICATION_WINDOW
        && attrs.type <= LAST_APPLICATION_WINDOW):
        error;
        // 要显示一个应用 window 但 token 为 null? 意味着 activity 已经 destroy
      if (attrs.type == TYPE_INPUT_METHOD):
        error;
        // 不可能的情况, 因为 startInputInnerLocked 会注册一个 WindowToken
      else:
        token = new WindowToken(this, attrs.token, -1, false);
        addToToken = true;
        // 其他类型的 window type ? 例如 toast, 或系统 dialog
        // 添加一个新 token
    elseif attrs.type >= FIRST_APPLICATION_WINDOW
           && attrs.type <= LAST_APPLICATION_WINDOW):
      // token 不为 null, 或 type 为应用
      AppWindowToken atoken = token.appWindowToken;
      if (atoken == null):
        // token 不是一个 AppWindowToken 却要显于一个 app window, 报错
        error;
    elseif (attrs.type == TYPE_INPUT_METHOD):
      if (token.windowType != TYPE_INPUT_METHOD):
        // token 不是 null, token 的类型不符, 报错
        error;
     win = new WindowState(this, session, client, token,..)
     if (addToToken):
       mTokenMap.put(attrs.token, token);

#+END_SRC

*** Activity window size
http://blog.csdn.net/luoshengyang/article/details/8479101
*** window z-order
[[http://blog.csdn.net/luoshengyang/article/details/8570428][Android窗口管理服务WindowManagerService计算窗口Z轴位置的过程分析]]
*** App Transition
**** overridePendingTransition
*** Starting Window
WMS.setAppStartingWindow
*** Event Dispatching
see also [[Android Event Dispatching]]
*** 从 startActivity 到显示的过程

#+BEGIN_SRC plantuml :file start_activity.png
box "app 1"
participant  previouse_activity as prev_act
end box

box "system_server"
participant  ActivityManagerService as ams
participant  WindowManagerService as wms
end box

box "app 2"
participant  ActivityThread as at
participant  WindowManagerImpl as wmi
participant  ViewRootImpl as vri
participant  Activity as act
end box

prev_act -> ams : startActivity
ams -> wms : setAppStartingWindow
activate wms
wms -> wms : addStartingWindow
deactivate wms

ams -> ams : resumeTopActivityLocked
activate ams
ams -> prev_act : pauseActivity
deactivate ams
activate prev_act
prev_act -> ams : activityPaused
deactivate prev_act
ams -> at : startProcessLocked
activate at
at -> ams : attachApplication
deactivate at
activate ams
ams -> at : bindApplication
ams -> at : scheduleLaunchActivity
deactivate ams
at -> act : onCreate
at -> act : onStart
at -> act : onResume
act -> act : inflating views
act -> wmi : addView
wmi -> vri : performTraversals
activate vri
vri -> vri : dispatchAttachedToWindow
vri -> wms : requestLayout
activate wms
wms --> vri : return windows size
deactivate wms
vri -> vri : onMeasure
vri -> vri : onLayout
vri -> vri : onDraw
vri -> wms: finishDrawing
deactivate vri
activate wms
wms -> wms : performShowLocked
wms -> wms : removeStartingWindow
activate wms
deactivate wms
deactivate wms
#+END_SRC

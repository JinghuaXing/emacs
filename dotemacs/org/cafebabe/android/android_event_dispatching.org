* Android Event Dispatching
** Upper Level (above ViewRoot)
*** KeyEvent dispatch

WMS first found the focused WindowState, then dispatch event to
WindowState.mClient (this is a IWindow), IWindow , as an AIDL register
by viewRoot, will call viewRoot's dispatch() directory

#+BEGIN_EXAMPLE
  WindowInputEventReceiver.onInputEvent();
    ViewRoot.deliverKeyEvent()
      ViewRoot.deliverKeyEventToViewHierarchy()
        Decorview.dispatchKeyEvent() ;; mView is the decorView
          if (is volume key)
            adjust volume
          if (has Window.Callback) ;; Activity, Dialog implents Window.Callback
            callback.dispatchKeyEvent()
              DecorView.superDispatchKeyEvent()
                ViewGroup.dispatchKeyEvent() ;; dispatch key event to view hierachy
                  Travers the focus path, call every ViewGroup's dispatchKeyEvent, then finally,calls:
                  focusView.dispatchKeyEvent()
                    mOnKeyListener.onKey()
                    if (not handled)
                      event.dispatch(view) ;; view also implents Event.Callback
              if (not handled)
                  event.dispatch(activity) ;; Activity implents Event.Callback, which implents onKeyUp, onKeyDown ...
          else
            super.dispatchKeyEvent() ;; view.dispatchKeyEvent, PopupWindow falls into this condition, since PopupWindow
                                     ;; does not implents Window.Callback
          if (still not handled):
            Window.onKeyDown() or onKeyUp()
              // cope with MENU,CAMERA,VOLUME,MEDIA,CALL,SEARCH...
        if (not handled)
          changeFocus()
          if not (focus changed)
            playSoundEffect
        sWindowSession.finishKey(mWindow) to tell AMS that key
#+END_EXAMPLE

    note that:
    Activity and Dialog implements Window.Callback and KeyEvent.Callback, so you can override Activity or Dialog's dispatchKeyEvent (implemented in
    Window.Callback), and you can override onKeyUp, onKeyDown ...( implemented in KeyEvent.Callback)
    But PopupWindow implements neither Window.Callback nor KeyEvent.Callback.

*** TouchEvent dispatch
     SCHEDULED: <2011-01-27 Thu> CLOSED: [2011-01-27 Thu 11:35]
     - State "DONE"       [2011-01-27 Thu 11:35]

#+BEGIN_EXAMPLE
     ViewRoot.dispatchPointer()
       decorView.dispatchTouchEvent() ;; mView is typically a DecorView
         if DecorView has callbacks like Activity or Dialog
	   activity.dispatchTouchEvent()
	     mDecor.superDispatchTouchEvent()
	     .... ;; same as the `else` branch
	     activity.onTouchEvent() if not handled before
	 else
	   mDecor.superDispatchTouchEvent()
	     ViewGroup.dispatchTouchEvent() ; DecorView is a FrameLayout
               if (action == MotionEvent.ACTION_DOWN):
                 if (disallowIntercept || !onInterceptTouchEvent(Ev)):
                   foreach mView of ViewGroup: ;; for each child of the ViewGroup whose rect contains pointer(x,y), note that view's rect is set during view.layout()
                     if (mView.dispatchTouchEvent()):
                       mMotionTarget=mView;
                       return true;
               if mMotionTarget==null: // DOWN is not handled by any child; or event is up/move, but there is no mMotionTarget,
                                       // which means last DOWN is handled by ourselves.
                 return super.dispatchTouchEvent()
	           mView.onTouchListener().on Touch()
	           mView.onTouchEvent() ;; if not handled before
	             mView.onClickListener()
               // ACTION is up/move, and mMotionTarget is not null, which means we should delegate the up/move to the mMotionTarget,
               // There is no need to go through child hierarchy to handle it.
               if (!disallowIntercept && onInterceptTouchEvent(ev)): // touchEvent is intercepted
                 ev.setAction(MotionEvent.ACTION_CANCEL);
                 mMotionTarget.dispatchTouchEvent(ev)
                 return true;
               // touchEvent is not intercepted
               return mMotionTarget.dispatchTouchEvent(ev);
#+END_EXAMPLE
     To summarize:
     1. TouchEvent dispatching 的过程和 KeyEvent *相反*:
	- KeyEvent: 先调用 ViewGroup.superDispatchKeyEvent(), 若没处理,再调用 mFocused.dispatchKeyEvent()
	- TouchEvent: 先调用 child.dispatchTouchEvent(),若没处理, 再调用 super.dispatchTouchEvent()
     2. dispatchTouchEvent -> onTouchListener -> onTouchEvent -> onClickListener
     3. onInterceptTouchEvent and mMotionTarget and requestDisallowInterceptTouchEvent
**** DONE ListView TouchEvent dispatch
      SCHEDULED: <2011-02-16 Wed> CLOSED: [2011-02-16 Wed 15:04]
      - State "DONE"       [2011-02-16 Wed 15:04]
      ListView 首先是一个 ViewGroup, 它使用了
#+BEGIN_EXAMPLE
	 ViewGroup.dispatchTouchEvent()
	   ask_child_to_handle_it()
	   if not handled:
	     super(view).dispatchTouchEvent()
	       AbsListView.onTouchEvent()
	         if child(list item).hasFocusable(): ;; if the liste_item have any view that is focusable
		   do_nothing;
		 else:
		   onItemClickedListener();
#+END_EXAMPLE

      To summarize:
      ListView is just like a common ViewGroup, but:
      1. ListView's onTouchEvent will not invoke `onClickListener`, but `onItemClickedListener`
      2. before invoke onItemClickedListener, onTouchEvent will make sure that child.hasFocusable() is false

**** DONE ViewGroup.onInterceptTouchEvent & mMotionTarget & requestDisallowInterceptTouchEvent
      SCHEDULED: <2011-07-19 Tue> CLOSED: [2011-07-19 Tue 16:55]
      - State "DONE"       from "DOING"      [2011-07-19 Tue 16:55]

** Lower Level (below ViewRoot)

有最重要的几点需要明确:

1. InputReader 使用 epoll 监听 EventHub 维护的多个输入设备.

2. InputDispatcher, InputChannel 都使用了 Looper 进行高效的事件驱动.

   1. C++ Looper 的实现十分高效 (通过 epoll, pipe, ..., 而不是通过线程同
      步原语)

3. InputEvent 是通过 ViewRoot 提供的 InputChannel 直接由 InputDispatcher 传
   递给当前有焦点的进程的 ViewRoot, 并没有通过 WMS 中转, 以便提高效率.
   不过 WMS 会负责通知 InputDispatcher 当前哪个 InputChannel 获得焦点.

4. 在 dispatch 给 ViewRoot 之前, PhoneWindowManager 有机会通过.
   InputDispatcher.interceptKeyBeforeQueueing/Dispatching 来处理系统硬
   键, 如 HOME, POWERKEY, MENU, VOLUME, SEARCH, ...

#+BEGIN_EXAMPLE

                           +--------------+    +--------------+   +--------------+
                           | /dev/input/1 |    | /dev/input/2 |   | /dev/input/3 |
                           +-----------+--+    +------+-------+   +-------+------+
                                       |              |                   |
                                       |       +------+---+               |
                                       +-------+ EventHub +---------------+
                                               +-----+----+
                                                     |   +---------------+
                                                     |   v     epoll     |
              +--------------------+        +--------+---+--------+      |
              | ViewRoot.addWindow |        |  InputReaderThread  +------+
              +------+-------------+        +--------+------------+
                     |                               |   +----------------+
                     v                               |   v looper.poll    |
         +-----------+--------------+       +--------+---+-----------+    |
         | WMS.registerInputChannel +-------+  InputDispatcherThread +----+
         +--------------------------+       +--------+---------------+
                                                     |
                                                     |
                                             +-------+---------------------------------------------------+
                                             | PhoneWindowManager.interceptKeyBeforeQueueing/Dispatching |
                                             +-------+---------------------------------------------------+
                                                     | 1. find the InputChannel that has focus.
                                                     | 2. wake up the related looper
                                                     | 3. Looper.handleEvent will notify the InputEventReceiver
                                            +--------+------------------------+
                                            | InputEventReceiver.onInputEvent |
                                            +---------------------------------+

#+END_EXAMPLE
*** C++
**** EventHub
**** InputReader
**** InputDispatcher
- Looper
- interceptKeyBeforeQueueing
- interceptKeyBeforeDispatching
**** InputManagerService
**** InputEventReceiver
- Looper
*** Java
**** InputManagerService
**** InputEventReceiver
**** InputMonitor
**** InputChannel
**** InputFilter
** Event Dispatching ANR
** 再看 Looper
*** Java looper vs. C++ looper

#+BEGIN_EXAMPLE
                                                                 |
                                                       Java      |    C++
       +---------+                                               |
       | Handler +--------+                                      |
       +---------+        |                                      |
                          |                                      |
       +---------+        |   +--------+    +--------------+     |     +--------------------+  +--------+
       | Handler +--------+---+ Looper +----+ MessageQueue +-----+-----+ NativeMessageQueue +--+ Looper |
       +---------+        |   +--------+    +--------------+     |     +--------------------+  +--------+
                          |                                      |
       +---------+        |                                      |
       | Handler +--------+                                      |
       +---------+                                               |
                                                                 |
                                                                 |

#+END_EXAMPLE


- Java Looper (及其 Handler, Message) 与 C++ Looper (及其 Message,
  MessageHandler) 并没有直接的关系, 而且,令人不解的是, Java looper 和
  C++ looper 的许多代码, 例如, Java looper 的 enqueueMessage vs. C++
  looper 的 sendMessage, 以及 Java looper 的 MessageQueue.next
  vs. C++ looper 的 pollOnce 等, 都是很类似的....即 Java looper 与
  C++ looper 对消息的收,发,处理都是独立的代码....Java looper 并不是对
  C++ looper 的封装.

- Java looper 与 C++ looper 的唯一联系, 是 MessageQueue <--->
  NativeMessageQueue, 但 Java MessageQueue 与 NativeMessageQueue 的功
  能也很有限, 只是借用了 C++ looper 高效的 pollOnce 和 wake 机制. 

*** Looper.sendMessage
*** Looper.pollOnce & wake

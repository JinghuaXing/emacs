* Android Event Dispatching
** Upper Level (above ViewRoot)
*** KeyEvent dispatch

WMS first found the focused WindowState, then dispatch event to
WindowState.mClient (this is a IWindow), IWindow , as an AIDL register
by viewRoot, will call viewRoot's dispatch() directory

#+BEGIN_EXAMPLE
     WMS get mClient, and call mClient.dispatch() through binder
       ViewRoot.dispatchKey()
         ViewRoot.sendEmptyMessage(DISPATCH_KEY)
	   message handler: ViewRoot.deliverKeyEvent()
	     ViewRoot.deliverKeyEventToViewHierarchy()
	       Decorview.dispatchKeyEvent() ;; mView is the decorView
	         if (is volume key)
		   adjust volume
		 if (has Window.Callback) ;; Activity, Dialog implents Window.Callback
		   callback.dispatchKeyEvent()
		     DecorView.superDispatchKeyEvent()
		       ViewGroup.dispatchKeyEvent() ;; dispatch key event to view hierachy
		         Travers the focus path, call every ViewGroup's dispatchKeyEvent, then finally,calls:
			 focusView.dispatchKeyEvent()
			   mOnKeyListener.onKey()
			   if (not handled)
			     event.dispatch(view) ;; view also implents Event.Callback
		     if (not handled)
		         event.dispatch(activity) ;; Activity implents Event.Callback, which implents onKeyUp, onKeyDown ...
		 else
		   super.dispatchKeyEvent() ;; view.dispatchKeyEvent, PopupWindow falls into this condition, since PopupWindow
		                            ;; does not implents Window.Callback
                 if (still not handled):
                   Window.onKeyDown() or onKeyUp()
                     // cope with MENU,CAMERA,VOLUME,MEDIA,CALL,SEARCH...
               if (not handled)
	         changeFocus()
		 if not (focus changed)
		   playSoundEffect
	       sWindowSession.finishKey(mWindow) to tell AMS that key
#+END_EXAMPLE

    note that:
    Activity and Dialog implements Window.Callback and KeyEvent.Callback, so you can override Activity or Dialog's dispatchKeyEvent (implemented in
    Window.Callback), and you can override onKeyUp, onKeyDown ...( implemented in KeyEvent.Callback)
    But PopupWindow implements neither Window.Callback nor KeyEvent.Callback.

*** TouchEvent dispatch
     SCHEDULED: <2011-01-27 Thu> CLOSED: [2011-01-27 Thu 11:35]
     - State "DONE"       [2011-01-27 Thu 11:35]

#+BEGIN_EXAMPLE
     ViewRoot.dispatchPointer()
       decorView.dispatchTouchEvent() ;; mView is typically a DecorView
         if DecorView has callbacks like Activity or Dialog
	   activity.dispatchTouchEvent()
	     mDecor.superDispatchTouchEvent()
	     .... ;; same as the `else` branch
	     activity.onTouchEvent() if not handled before
	 else
	   mDecor.superDispatchTouchEvent()
	     ViewGroup.dispatchTouchEvent() ; DecorView is a FrameLayout
               if (action == MotionEvent.ACTION_DOWN):
                 if (disallowIntercept || !onInterceptTouchEvent(Ev)):
                   foreach mView of ViewGroup: ;; for each child of the ViewGroup whose rect contains pointer(x,y), note that view's rect is set during view.layout()
                     if (mView.dispatchTouchEvent()):
                       mMotionTarget=mView;
                       return true;
               if mMotionTarget==null: // DOWN is not handled by any child; or event is up/move, but there is no mMotionTarget,
                                       // which means last DOWN is handled by ourselves.
                 return super.dispatchTouchEvent()
	           mView.onTouchListener().on Touch()
	           mView.onTouchEvent() ;; if not handled before
	             mView.onClickListener()
               // ACTION is up/move, and mMotionTarget is not null, which means we should delegate the up/move to the mMotionTarget,
               // There is no need to go through child hierarchy to handle it.
               if (!disallowIntercept && onInterceptTouchEvent(ev)): // touchEvent is intercepted
                 ev.setAction(MotionEvent.ACTION_CANCEL);
                 mMotionTarget.dispatchTouchEvent(ev)
                 return true;
               // touchEvent is not intercepted
               return mMotionTarget.dispatchTouchEvent(ev);
#+END_EXAMPLE
     To summarize:
     1. TouchEvent dispatching 的过程和 KeyEvent *相反*:
	- KeyEvent: 先调用 ViewGroup.superDispatchKeyEvent(), 若没处理,再调用 mFocused.dispatchKeyEvent()
	- TouchEvent: 先调用 child.dispatchTouchEvent(),若没处理, 再调用 super.dispatchTouchEvent()
     2. dispatchTouchEvent -> onTouchListener -> onTouchEvent -> onClickListener
     3. onInterceptTouchEvent and mMotionTarget and requestDisallowInterceptTouchEvent
**** DONE ListView TouchEvent dispatch
      SCHEDULED: <2011-02-16 Wed> CLOSED: [2011-02-16 Wed 15:04]
      - State "DONE"       [2011-02-16 Wed 15:04]
      ListView 首先是一个 ViewGroup, 它使用了
#+BEGIN_EXAMPLE
	 ViewGroup.dispatchTouchEvent()
	   ask_child_to_handle_it()
	   if not handled:
	     super(view).dispatchTouchEvent()
	       AbsListView.onTouchEvent()
	         if child(list item).hasFocusable(): ;; if the liste_item have any view that is focusable
		   do_nothing;
		 else:
		   onItemClickedListener();
#+END_EXAMPLE

      To summarize:
      ListView is just like a common ViewGroup, but:
      1. ListView's onTouchEvent will not invoke `onClickListener`, but `onItemClickedListener`
      2. before invoke onItemClickedListener, onTouchEvent will make sure that child.hasFocusable() is false

**** DONE ViewGroup.onInterceptTouchEvent & mMotionTarget & requestDisallowInterceptTouchEvent
      SCHEDULED: <2011-07-19 Tue> CLOSED: [2011-07-19 Tue 16:55]
      - State "DONE"       from "DOING"      [2011-07-19 Tue 16:55]


** Lower Level (below ViewRoot)
*** EventHub
*** InputReader
*** InputDispatcher
*** InputMonitor
*** InputFilter

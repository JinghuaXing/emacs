#+TITLE: Android Connectivity
* Android Connectivity
** Overview
                                                                                                                 -+-------------+
  -+------------------------+                         -+---------------------+     -+------------------+          | WifiService |
   | ActivityManagerService |                          | ConnectivityService |<--+--| WifiStateTracker |<---------+             |
  -+---+--------------------+                         -+-------------+-------+   | -+------------------+         -+------------->
       ^  for `backgroud` uid detection                              |           | -+-----------------------+       -+------------+
      -+-----------------                                            |          -+--+ MobileDataStateTracker|<-------+ Telephony  |
       | -+----------------------------------------------------------+           | -+-----------------------+       -+------------+
       |  |          for quota and uid_rule        for route and dns |           | -+--------+
       |  |         -----------------+        -+---------------------+          -+--+ ...    |
       |  v                          |         v                                   -+o-------+
   -+--+--+-----------------------+  |   -+----+---------------------+
    | NetworkPolicyManagerService-+--+--->| NetworkManagementService |
   -+-----------------------------+      -+------------+-------------+
                                                       |
                                                       |
                                                   -+--+---+
                                                    | netd |
                                                   -+------+


ConnectivityService generally will:
  - handle connectivity change
    - supply connectivity info and send notification
    - check whether the connectivity could be established (priority, ...)
    - connectivity fail-over
  - after connectivity changes, change dns and route
  - manage the `global` proxy
  - supply policy info (quota and uid_rule)

** ConnectivityService
*** Component
**** NetworkStateTracker
- WifiStateTracker
- MobileDataStateTracker
- DummyDataStateTracker
- EthernetDataTracker
- BluetoothTetheringDataTracker
- ...

NetworkStateTracker is the `very beginning` of ConnectivityService, it feed the
connectivity events to ConnectivityService, e.g.
- NetworkStateTracker.EVENT_STATE_CHANGED
- ..
**** NetworkInfo
**** LinkProperties
**** NetworkConfig
NetworkConfig is generated from : frameworks/base/core/res/res/values/config.xml
#+BEGIN_SRC xml
  <string-array translatable="false" name="networkAttributes">
    <item>"wifi,1,1,2,-1,true"</item>
    <item>"mobile,0,0,1,-1,false"</item>
    <item>"mobile_mms,2,0,2,60000,false"</item>
    <item>"mobile_supl,3,0,2,60000,false"</item>
    <item>"mobile_dun,4,0,5,60000,false"</item>
    <item>"mobile_hipri,5,0,3,60000,false"</item>
    <item>"bluetooth,7,7,0,-1,true"</item>
    <item>"mobile_fota,10,0,2,60000,true"</item>
    <item>"mobile_ims,11,0,2,-1,true"</item>
    <item>"mobile_cbs,12,0,2,60000,false"</item>
    <item>"wifi_p2p,13,1,0,-1,true"</item>
  </string-array>
#+END_SRC
**** FeatureUser / FeatureMana
**** RouteInfo
**** ProxyProperties
*** Source code analysis
**** NetworkStateTracker
**** ConnectivityService
***** handleConnect
#+BEGIN_SRC fundamental
  handleConnect(NetworkInfo info)
    int type=info.type;
    // wifi, mobile, bluetooth, wimax, ethernet ...
    NetworkStateTracker thisNet = mNetTrackers[type];
    // since handleConnect is triggered by NetworkStateTracker, it is assured
    // that mNetTrackers has the tracker
    if mNetConfigs[type].isDefault():
    // the new network is default? means it should be default routeable, and only one
    // default network could be established. for example, wifi and mobile are default
    // networks. but mobile_mms, mobile_wap ... is not default, thus, they can
    // co-exist with default network
      if mActiveDefaultNetwork != type:
        // try tear down this net
        // mNetworkPreference, typically, is wifi
        if type!= mNetworkPreference
           && mNetConfigs[mActiveDefaultNetwork].priority > mNetConfigs[type].priority
           || mNetworkPreference == mActiveDefaultNetwork
           tearDown(thisNet); return;
        else:
        // try tear down mActiveDefaultNetwork
          NetworkStateTracker otherNet = mNetTrackers[mActiveDefaultNetwork];
          tearDown(otherNet); return;
        // `type!= mNetworkPreference` ends here
      // `mActiveDefaultNetwork` ends here
      mActiveDefaultNetwork = type;
    // `isDefault()` ends here
    updateNetworkSettings(thisNet);
    /**
       * Reads the network specific TCP buffer sizes from SystemProperties
       * net.tcp.buffersize.[default|wifi|umts|edge|gprs] and set them for system
       * wide use by put the value into `/sys/kernel/ipv4/tcp_xxx`
    */
    handleConnectivityChange(thisNet);
    sendConnectedBroadcastDelayed(info, getConnectivityChangeDelay());
#+END_SRC
***** handleConnectivityChange
/**
 * After a change in the connectivity state of a network. We're mainly
 * concerned with making sure that the list of DNS servers is set up
 * according to which networks are connected, and ensuring that the
 * right routing table entries exist.
 */
#+BEGIN_SRC fundamental
  handleConnectivityChange(netType)
    handleDnsConfigurationChange(netType);
      NetworkStateTracker nt = mNetTrackers[netType];
      if nt.getNetworkInfo().isConnected():
        LinkProperties lp = nt.getLinkProperties();
        Collection<InetAddress> dnses = lp.getDnses();
        if mNetConfigs[netType].isDefault():
        // if the netType is default, set the global dns
          changed=updateDns(network, lp.getInterfaceName(), dnses, "");
          // dns is updated globally by setting the `net.dns.xxx` prop
        else:
        // not default network? set the dns to individual interface and pid
          mNetd.setDnsServersForInterface(p.getInterfaceName(),
            NetworkUtils.makeStrings(dnses));
          List pids = mNetRequestersPids[netType];
          foreach pid in pids:
            changed = writePidDns(dnses, pid.intValue());
      // `isConnected` ends here
      if changed:
        bumpDns();
        // notify name resolver lib by set `net.dnschange` sys prop
        // and notify vms by sending `Intent.ACTION_CLEAR_DNS_CACHE`
        // to clear dns cache
    // DNS is set
    if mNetTrackers[netType].getNetworkInfo().isConnected():
      newLp = mNetTrackers[netType].getLinkProperties();
      curLp = mCurrentLinkProperties[netType];
      // if the interface name is changed, or some addr is removed by newLp,
      // set `resetMask` which is used later to reset the connection
      if mNetConfigs[netType].isDefault():
        handleApplyDefaultProxy(newLp.getHttpProxy());
        // send the global proxy changed broadcast
    // `isConnected` ends here
    mCurrentLinkProperties[netType] = newLp;
    updateRoutes(newLp, curLp, mNetConfigs[netType].isDefault());
      routeDiff = curLp.compareRoutes(newLp);
      dnsDiff = curLp.compareDnses(newLp);
      linkDiff = curLp.compareAddresses(newLp);
      // for route removed by the newLp from oldLp:
      //
      for (RouteInfo r : routeDiff.removed):
        if (isLinkDefault || ! r.isDefaultRoute()):
        // if new link is default, remove the old route in default table
          removeRoute(curLp, r, TO_DEFAULT_TABLE);
        if (isLinkDefault == false):
        // if new link is not default, remove old route in secondary table,
        // since route for the new link will be queried using the secondary table.
          removeRoute(curLp, r, TO_SECONDARY_TABLE);
      for (RouteInfo r :  routeDiff.added) {
        if isLinkDefault || ! r.isDefaultRoute():
          addRoute(newLp, r, TO_DEFAULT_TABLE);
        else:
          addRoute(newLp, r, TO_SECONDARY_TABLE);
      if !isLinkDefault:
      // add/remove specificial route for dns, since they are not default route-able
      // is link is default, there is a default route entry for link, so there is
      // not need to add dns entry, but if the link is not default, e.g. mobile_mms,
      // since there is no route info for the mms gateway or mms recipient
      // in the default route table, the MMS app must first query it's own dns
      // to determine the ip address, and then it could using `requestRouteToHost`
      // to manually add a route entry to the default route table.
        for (InetAddress oldDns : dnsDiff.removed):
          removeRouteToAddress(curLp, oldDns);
        for (InetAddress newDns : dnsDiff.added):
          addRouteToAddress(newLp, newDns);
    // `updateRoutes` ends here
#+END_SRC
***** handleApplyDefaultProxy
#+BEGIN_SRC text
  handleApplyDefaultProxy
    sendproxybroadcast(proxy)
      sendStickyBroadcast(new Intent(Proxy.PROXY_CHANGE_ACTION))
      // 接收该 broadcast 的只有 AMS 和 webview, 为不同网络库设置代理:
      // 1. 通过 AMS 给 UrlConnection 配置代理
      // 2. 通过 webview 给 android webkit 使用的 chromium 配置代理
      // 显然, apache HttpClient 没有考虑. 所以, 使用 UrlConnection 的
      // android 应用和使用 webview 的应用如 browser 不需要应用自己配置
      // 代理, 但使用 HttpClient 的应用需要自己配置代理.
  
  AMS::UPDATE_HTTP_PROXY
    r.thread.setHttpProxy(host, port, exclList);
      Proxy.setHttpProxySystemProperty(host, port, exclList);
        System.setProperty("http.proxyHost", host);
        System.setProperty("http.proxyPort", port);
#+END_SRC
***** handleDisconnect
***** startUsingNetworkFeature / stopUsingNetworkFeature
`startUsingNetworkFeature` is a request from the client of connecting to a
`non-default` network, e.g. mobile_mms, but in addition to setting up the
connection:
- the requested pid is also recorded to the `mNetRequestersPids`, for per-pid dns manipulation.
- there is DeathRecipient parameter for death notification. e.g. when the
  requesting client died, the connection should be tear-down.
****** startUsingNetworkFeature
#+BEGIN_SRC fundamental

#+END_SRC
****** stopUsingNetworkFeature
#+BEGIN_SRC fundamental

#+END_SRC
***** requestRouteToHostAddress
***** To summaries:
****** handleConnect
- `handleConnect` will first check:
  1. whether the connecting network is default;
  2. whether it's preferred and it's property
  if there is more than one default network, `thisNet` or `thatNet` will be
  tear down, according to previous check.
- then invoke `handleConnectivityChange` to change route, dns, and maybe proxy
- send broadcast
****** handleConnectivityChange
- updateDns
  1. if the networking is default, dns is updated by setting the
     `net.dns1{2}.xxx` sysprop
  2. if it is not default, set the pid dns by setting the `net.dns-pid.xxx` sysprop,
     bionic libc will take care of using the sysprop
- updateRoute
  1. if the networking is default, the `default` (or `main`) route table is updated
  2. if not, the `secondary` route table is updated (the `secondary` table is
     identified by a table number, e.g. 60, which is relevant with the iface)
  3. if the networking is not default, it's dns will also be added to the
     `default` route map. (see also `Mms.ensureRouteToHost`)
- update route
  if the networking is default, the global proxy is also set the `newLp.getHttpProxy`
****** handleDisconnect
per-pid dns is cleared
****** What's more:
- isDefault, priority, preferred networking.
- per-pid dns, `net.dns1.xxx`
- global proxy
- addition route of dns for `non-default` network
- startUsingNetworkFeature
** NetworkManagementService
** NetworkPolicyManagerService
** WifiService
** netd



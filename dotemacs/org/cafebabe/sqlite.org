#+TITLE: SQLite
* SQLite
** Android API
*** SQLiteDatabase & SQLiteDatabase (c)
**** addCustomFunction
*** SQLiteStatement (c)
Note that `SQLiteStatement' has nothing to do with the native
`prepared statement', it nothing but a `helper class' to store:
- sql string
- bind args
- db connection (session)

In fact, there is ONE class named `PreparedStatement', defined in the
`SQLiteConnection', which corresponds to the `native prepared
statement', and also there is `PreparedStatementCache' in
SQLiteConnection to avoid redundant statement preparations. So, cache
`SQLiteStatement' manually may make no sense? so I really doubt that
`android providers should use DatabaseUtils.InsertHelper to cache
SQLiteStatement', as mentioned in:

[[http://www.outofwhatbox.com/blog/2010/12/android-using-databaseutils-inserthelper-for-faster-insertions-into-sqlite-database/#comment-2685][android-using-databaseutils-inserthelper-for-faster-insertions-into-sqlite-database/]]

*** SQLiteSession
*** SQLiteConnection & SQLiteConnectionPool
**** Yield
**** WAL (Write-ahead Logging)
http://sqlite.org/wal.html
*** SQLiteProgram & SQLiteQuery & SQLiteQueryBuilder
*** Cursor & CursorWindow
**** SQLiteCursorDriver
**** CursorFactory
**** Cursor
***** Cursor Class Hierarchy

#+BEGIN_EXAMPLE
                                    -+----------+
                                     | Cursor/I |
                                    -+----+-----+
                                          |
                                          |
                               -+---------+-----------+
                                | CrossProcessCursor/I|
                               -+----+----+-----------+
                                          |
                                          |
                                -+-----+--+---------+
                                 | AbstractCursor/A |
                                -+--------+---------+
                                          |
                      -+------------------+---------------+----------------------+
                       |                                  |                      |
          -+-----------+--------------+          -+-------+------+       -+------+------+
           | AbstractWindowedCursor/A |           | MatrixCursor |        | MergeCursor |
          -+-----------+--------------+          -+--------------+       -+-------------+
                       |
                      -+----------------------------+
                       |                            |
              -+-------+------+      -+-------------+-------------+
               | SqliteCursor |       | BulkCursorToCursorAdaptor |
              -+--------------+      -+---------------------------+
#+END_EXAMPLE
****** Cursor across process

When Cursor in the remote process need to be returned to local process, the
remote Cursor will be wrapped into a binder object named
`CursorToBulkCursorAdaptor`, which is not a cursor, but implements methods like
`onMove`, `getWindow`, etc.

When the local process received the `CursorToBulkCursorAdaptor` binder, it
again will be wrapped into a local cursor object named
`BulkCursorToCursorAdaptor`, which is a `AbstractWindowedCursor`


#+BEGIN_EXAMPLE
               -+------------------------+
                | AbstractWindowedCursor |
               -+----------+-------------+
                           |
                           |
             -+------------+--------------+
              | BulkCursorToCursorAdaptor |
             -+------------+--------------+
                           |
                           |
                  -+-------+------+        local process (e.g. app)
   --------------- |  BulkCursor  | -------------------
                  -+-------+------+        remote process (e.g. provider)
                           |
                           |
             -+------------+--------------+
              | CursorToBulkCursorAdaptor |
             -+------------+--------------+
                           |
                           |
                    -+----------+
                     |  Cursor  |
                    -+----------+
#+END_EXAMPLE

***** Code Snippet
****** moveToFirst
#+BEGIN_SRC text
  AbstractCursor.moveToFirst
    AbstractCursor.moveToPosition(0)
      ret=SqliteCursor.onMove(origPos,0)
        if mWindow==null || newPosition < mWindow.getStartPosition()
           || newPosition >= mWindow.getStartPosition()+ mWindow.getNumRows():
           SqliteCursor.fillWindow(newPosition)
             mWindow.setStartPosition(newPosition)
             getQuery().fillWindow(newPosition)
               SQLiteQuery.nativeFillWindow(nHandle, nStatement, window.mWindowPtr,
                          startPos, mOffsetIndex);
                 // Bind the offset parameter, telling the program which row to start with
                 sqlite3_bind_int(statement, offsetParam, startPos);
                 while (!windowFull):
                   sqlite3_step(statement);
                   window->allocRow();
                   for (int i = 0; i < numColumns; i++):
                     int type = sqlite3_column_type(statement, i);
                     if (type == SQLITE_TEXT):
                       const char* text = reinterpret_cast<const char*>(sqlite3_column_text(statement, i));
                       window->putString(addedRows, i, text, sizeIncludingNull);
                     elif: // other type
                   // end for
                 // end while
                 sqlite3_reset(statement);      
      if ret:
        mPos=newPos;
#+END_SRC
****** getString
#+BEGIN_SRC text
  Cursor.getString(pos)
    AbstractWindowedCursor.getString(pos)
      mWindow.getString(pos)
        nativeGetString(pos)
#+END_SRC
***** SQLiteCursor
- SQLiteCursorDriver
  used to create the SqliteCursor
- SQLiteQuery
  used to invoke `nativefillWindow`
***** To summarize
1. Cursor by itself is not `CrossProcess`, but with the help of `BulkCursor`
   ,`BulkCursorToCursorAdaptor` and `CursorToBulkCursorAdaptor`, Cursor can be
   `CrossProcess`
2. The most important methods of the `Cursor` object:
   1) fillWindow

      `nativefillWindow` will execute the real query, and fill the result set to
      the `CursorWindow`.  ps. `getCount` will invoke `fillWindow` implicitly.

   2) onMove

      `fillWindow` is during `onMove`, e.g. `moveToFirst`, `moveToNext`, ...
      
**** CursorWindow
`CursorWindow` is parcelable, it represents a `window` of sqlite query data.

The underlying data of a Java CursorWindow object is managed by CursorWindow
c++ object, in both of the server side and the client side.
***** init
#+BEGIN_SRC text
  onMove
    fillWindow
      clearOrCreateWindow
        mWindow = new CursorWindow(name);
          // sCursorWindowSize specifies the window size in kb, e.g. 2048 Kb
          mWindowPtr = CursorWindow.nativeCreate(name, sCursorWindowSize);
#+END_SRC

***** how CursorWindow is passed across process

Because `CursorWindow` is only a parcelable (not a binder), so the remote
`CursorWindow` need to be fetched by the local process again and again,
e.g. during local `onMove`

#+BEGIN_SRC text
  BulkCursorToCursorAdaptor.onMove
    if (mWindow == null
        || newPosition < mWindow.getStartPosition()
        || newPosition >= mWindow.getStartPosition() + mWindow.getNumRows()):
      setWindow(mBulkCursor.getWindow(newPosition));
        // remote process
        CursorToBulkCursorAdaptor.getWindow(newPosition)
          mCursor.moveToPosition(startPos)
          return mCursor.getWindow()
#+END_SRC

** C API
** sqlite
*** sqlite3_analyzer
*** sqlite command
**** .output
**** .mode 
list|column|insert|line|tabs|tcl|csv
**** .dump
**** .read
**** .tables
**** .separator
**** .schema

**** .headers [on|off]
**** explain query plan
see also [[http://www.sqlite.org/queryplanner.html][queryplanner]]
#+BEGIN_SRC sql
explain query plan select * from foo;
#+END_SRC
**** vacuum
*** sqlite SQL
**** create table
***** storage class
- integer
- real
- text
- blob
***** constrains
****** column-level constrains
- not null
- unique
- primary key
- foreign key
- check
#+BEGIN_SRC sql
  create temp table foo(
  x integer,
  y integer check (y>x),
  z integer check (z>abs(y)),
  );
#+END_SRC
see also `trigger`
- collate
- default
- autoincrement
****** table-level constrains
- primary key
#+BEGIN_SRC sql
  CREATE TABLE xxx (
  data1 text,
  data2 text,
  primary key (data1, data2)
  );
#+END_SRC
- unique
#+BEGIN_SRC sql
  CREATE TABLE xxx (
  _id integer primary key,
  data1 text,
  data2 text,
  unique (data1, data2)
  );
#+END_SRC
- check
**** trigger
#+BEGIN_SRC sql
  create [temp|temporary] trigger name 
  [before|after|instead of] [insert|delete|update|update of columns] on table 
  [for each row] [when expr]
  begin
  action
  end;
#+END_SRC
- using trigger to update view
#+BEGIN_SRC sql
  create trigger on_update_foods_view 
  instead of update on foods_view 
  for each row 
  begin 
     update foods set name=new.fname where id=new.fid; 
     update food_types set name=new.tname where id=new.tid; 
  end; 
#+END_SRC
**** transaction
- begin
- commit
- rollback
- savepoint
**** confict resolution
- replace
- ignore
- fail
- abort
- rollback

confict resolution can be specified in
- table or view defination
#+BEGIN_SRC sql
create temp table cast(name text unique on conflict rollback); 
#+END_SRC
- in `insert`, `update`
#+BEGIN_SRC sql
insert or replace into table values (xxx);
#+END_SRC
- trigger
**** join
- inner join 
join
- left outer join
left out join
- right outer join
not supported
- full outer join
not supported
- cross
select from tbl1, tbl2
**** index
refers [[explain query plan]] to delete whether index is used for optimization
- index
- unique index
- covering index
**** view
- using trigger to update view
**** insert
**** update
**** select
***** group by
***** order by
***** having
***** limit
***** aggregation
- avg
- sum
- max
- min
- count
***** sub-query
- for `select`
- for `from`
- for `order by`
***** compound query
****** union [all]
a | b
****** intercept
a & b
****** except
a - b
***** conditional result
used to transform column values
#+BEGIN_SRC sql
  case value
    when x then value_x
    when y then value_y
    when z then value_z
    else default_value
  end
#+END_SRC
#+BEGIN_SRC sql
  select name,(select
                case
                when count(*) > 4 then 'Very High'
                when count(*) = 4 then 'High'
                when count(*) in (2,3) then 'Moderate'
                else 'Low'
                end
                from foods_episodes
                where food_id=f.id) as frequency
  from foods f
  where frequency like '%High'
  
#+END_SRC
**** functions
***** LAST_INSERT_ROWID()
***** ifnull(x,y)
如果 x 为 null, 返回 y
***** substr
***** quote
***** length
***** lower
***** upper
***** abs
***** max
***** min
***** random
***** round
***** date
**** fts
*** sqlite internal
**** concurrent & lock
***** lock
- shared
- reserved
  shared 想升级为 reserved, 必须保证当前没有任何 reserved 及 exclusive lock
- exclusive
  - pending
    reserved 升级为 exclusive 时会先暂时的升级为 pending, pending lock 会禁止任
    何新的 lock 的获取, 包括 shared, 否则可以会因为不停的有新的 shared lock 进入
    而导致 reserved 永远无法升级为 exclusive.

  reserved要想升级为 exclusive, 必须保证当前没有任何其他的 lock, 包含 shared
***** dead lock example
| A connection                             | B connection                              |
|------------------------------------------+-------------------------------------------|
| BEGIN;                                   |                                           |
|                                          | BEGIN;                                    |
|                                          | # acquiring `reserved` lock ok            |
|                                          | INSERT INTO foo values("bar")             |
| # acquiring `shared` lock ok             |                                           |
| SELECT * from foo                        |                                           |
|                                          | # acquiring `exclusive` lock failed[fn:1] |
|                                          | COMMIT;                                   |
|                                          | SQL error: database is locked             |
| # acquiring `reserved` lock failed[fn:2] |                                           |
| INSERT INTO foo values ("bar")           |                                           |
| SQL error: database is locked            |                                           |

***** transaction
- begin [deferred]
- begin immediate
- begin exclusive

**** *** SQLite and Multiple Threads
**** SQLite and Multiple Threads
http://www.sqlite.org/threadsafe.html

SQLite support three different threading modes:

- Single-thread. In this mode, all mutexes are disabled and SQLite is
  unsafe to use in more than a single thread at once.

- Multi-thread. In this mode, SQLite can be safely used by multiple
  threads provided that no single database connection is used
  simultaneously in two or more threads.

- Serialized. In serialized mode, SQLite can be safely used by
  multiple threads with no restriction.

The threading mode can be selected at compile-time (when the SQLite
library is being compiled from source code) or at start-time (when the
application that intends to use SQLite is initializing) or at run-time
(when a new SQLite database connection is being created). Generally
speaking, run-time overrides start-time and start-time overrides
compile-time. Except, single-thread mode cannot be overridden once
selected.

The default mode is serialized.

***** Compile-time selection of threading mode

Use the SQLITE_THREADSAFE compile-time parameter to selected the
threading mode. If no SQLITE_THREADSAFE compile-time parameter is
present, then serialized mode is used. This can be made explicit with
-DSQLITE_THREADSAFE=1. With -DSQLITE_THREADSAFE=0 the threading mode
is single-thread. With -DSQLITE_THREADSAFE=2 the threading mode is
multi-thread.

The return value of the sqlite3_threadsafe() interface is determined
by the compile-time threading mode selection. If single-thread mode is
selected at compile-time, then sqlite3_threadsafe() returns false. If
either the multi-thread or serialized modes are selected, then
sqlite3_threadsafe() returns true. The sqlite3_threadsafe() interface
predates the multi-thread mode and start-time and run-time mode
selection and so is unable to distinguish between multi-thread and
serialized mode nor is it able to report start-time or run-time mode
changes.

If single-thread mode is selected at compile-time, then critical
mutexing logic is omitted from the build and it is impossible to
enable either multi-thread or serialized modes at start-time or
run-time.

***** Start-time selection of threading mode

Assuming that the compile-time threading mode is not single-thread,
then the threading mode can be changed during initialization using the
sqlite3_config() interface. The SQLITE_CONFIG_SINGLETHREAD verb puts
SQLite into single-thread mode, the SQLITE_CONFIG_MULTITHREAD verb
sets multi-thread mode, and the SQLITE_CONFIG_SERIALIZED verb sets
serialized mode.

***** Run-time selection of threading mode

If single-thread mode has not been selected at compile-time or
start-time, then individual database connections can be created as
either multi-thread or serialized. It is not possible to downgrade an
individual database connection to single-thread mode. Nor is it
possible to escalate an individual database connection if the
compile-time or start-time mode is single-thread.

The threading mode for an individual database connection is determined
by flags given as the third argument to sqlite3_open_v2(). The
SQLITE_OPEN_NOMUTEX flag causes the database connection to be in the
multi-thread mode and the SQLITE_OPEN_FULLMUTEX flag causes the
connection to be in serialized mode. If neither flag is specified or
if sqlite3_open() or sqlite3_open16() are used instead of
sqlite3_open_v2(), then the default mode determined by the
compile-time and start-time settings is used.

**** Can multiple applications or multiple instances of the same application access a single database file at the same time?
http://www.sqlite.org/faq.html#q5

Multiple processes can have the same database open at the same
time. Multiple processes can be doing a SELECT at the same time. But
only one process can be making changes to the database at any moment
in time, however.

SQLite uses reader/writer locks to control access to the
database. (Under Win95/98/ME which lacks support for reader/writer
locks, a probabilistic simulation is used instead.) But use caution:
this locking mechanism might not work correctly if the database file
is kept on an NFS filesystem. This is because fcntl() file locking is
broken on many NFS implementations. You should avoid putting SQLite
database files on NFS if multiple processes might try to access the
file at the same time. On Windows, Microsoft's documentation says that
locking may not work under FAT filesystems if you are not running the
Share.exe daemon. People who have a lot of experience with Windows
tell me that file locking of network files is very buggy and is not
dependable. If what they say is true, sharing an SQLite database
between two or more Windows machines might cause unexpected problems.

We are aware of no other embedded SQL database engine that supports as
much concurrency as SQLite. SQLite allows multiple processes to have
the database file open at once, and for multiple processes to read the
database at once. When any process wants to write, it must lock the
entire database file for the duration of its update. But that normally
only takes a few milliseconds. Other processes just wait on the writer
to finish then continue about their business. Other embedded SQL
database engines typically only allow a single process to connect to
the database at once.

However, client/server database engines (such as PostgreSQL, MySQL, or
Oracle) usually support a higher level of concurrency and allow
multiple processes to be writing to the same database at the same
time. This is possible in a client/server database because there is
always a single well-controlled server process available to coordinate
access. If your application has a need for a lot of concurrency, then
you should consider using a client/server database. But experience
suggests that most applications need much less concurrency than their
designers imagine.

When SQLite tries to access a file that is locked by another process,
the default behavior is to return SQLITE_BUSY. You can adjust this
behavior from C code using the sqlite3_busy_handler() or
sqlite3_busy_timeout() API functions.

**** Is SQLite threadsafe?
http://www.sqlite.org/faq.html#q6

Threads are evil. Avoid them.

SQLite is threadsafe. We make this concession since many users choose
to ignore the advice given in the previous paragraph. But in order to
be thread-safe, SQLite must be compiled with the SQLITE_THREADSAFE
preprocessor macro set to 1. Both the Windows and Linux precompiled
binaries in the distribution are compiled this way. If you are unsure
if the SQLite library you are linking against is compiled to be
threadsafe you can call the sqlite3_threadsafe() interface to find
out.

Prior to version 3.3.1, an sqlite3 structure could only be used in the
same thread that called sqlite3_open() to create it. You could not
open a database in one thread then pass the handle off to another
thread for it to use. This was due to limitations (bugs?) in many
common threading implementations such as on RedHat9. Specifically, an
fcntl() lock created by one thread cannot be removed or modified by a
different thread on the troublesome systems. And since SQLite uses
fcntl() locks heavily for concurrency control, serious problems arose
if you start moving database connections across threads.

The restriction on moving database connections across threads was
relaxed somewhat in version 3.3.1. With that and subsequent versions,
it is safe to move a connection handle across threads as long as the
connection is not holding any fcntl() locks. You can safely assume
that no locks are being held if no transaction is pending and all
statements have been finalized.

Under Unix, you should not carry an open SQLite database across a
fork() system call into the child process. Problems will result if you
do.

*** sqlite limitation
- right and full outer join
- complete ALTER TABLE support
- completing TRIGGER support
- writing to VIEWs
- GRAND and REVOKE
*** sqlite pragma
**** auto_vacuum = 0/1
**** cache_size = Number-of-pages
**** default_cache_size
**** case_sensitive_like = 0/1
**** count_change = 0/1
**** encoding = "UTF-8"
**** page_size = bytes
**** synchronous = FULL/NORMAL/OFF
*** references
[[http://www.sqlite.org/syntaxdiagrams.html][Syntax Diagrams For SQLite]]
** Other
*** WAL
*** FTS
FTS (Full Text Search), 即全文检索,主要有以下几个方面:

- stemming (词根)
- tokenizer &  word segregation (分词)
- inverted index (倒排索引)

**** stemming
http://en.wikipedia.org/wiki/Stemming

A stemmer for English, for example, should identify the string "cats" (and
possibly "catlike", "catty" etc.) as based on the root "cat".and "stemmer",
"stemming", "stemmed" as based on "stem". 

A stemming algorithm reduces the words "fishing", "fished", "fish", and "fisher"
to the root word, "fish". On the other hand, "argue", "argued", "argues",
"arguing", and "argus" reduce to the stem "argu"

android contacts provider 就是使用的一种叫做 porter 的 stemmer 算法, 所以用 cat
可以查找到名为 catty 的人也是正常的.
**** tokenizer and word segregation (分词)
全文检索是基于`关键字`匹配的检索, 与传统的 grep 等检索方法不同, 全文检索需要先建
立索引文件, 建立索引文件的第一步就是将全文分解为一系列的关键字. 例如:

"A stemmer for English, for example, should identify the string "cats" (and
possibly "catlike", "catty" etc.) as based on the root "cat""

这句话可能会被分解为以下的关键字:

stem, english, example, identify, string, cat, possible, base, root

tokenize 的过程主要分为三步:
1. 分词, 对英文来说, 基本就是以空格来分词
2. 抛弃一些 stop words, 如 a, for, should, and ,etc, as, on 等
3. 对剩下的非 stop words 使用 stemming 算法, 例如 cats->cat, stemmer->stem

***** 分词
英文分词比较简单,就是以空格来分词, 对于中文或其他一些语言就麻烦的多, 以中文为例,
主要有以下几种分词方法:

1. N元分词
   就是简单的每N个字算一个词, 
   - 1元分词:
   英/文/分/词/比/较/简/单

   - 2元交叉为例:
   英文/文分/分词/词比/比较/较简/简单

2. 基于词典匹配的分词
   - 正向最大匹配
     "市场/中国/有/企业/才能/发展"
   - 逆向最大匹配
     "市场/中/国有/企业/才能/发展"
   - 双向最大匹配
3. 基于统计的分词


从目前存在的项目看, 综合N元分词与基于词典匹配的分词是主流的方法, 以 Apache
Lucene 为例: 它包含以下几种中文分词算法:
http://blog.csdn.net/chaocy/article/details/5938741

- StandardAnalyzer & ChineseAnalyzer (一元分词)

2008/年/8/月/8/日/晚/举/世/瞩/目/的/北/京/第/二/十/九/届/奥/林/匹/克/运/动/会/开
/幕/式/在/国/家/体/育/场/隆/重/举/行

- CJKAnalyzer (交叉二元分词)

2008/年/8/月/8/日晚/举世/世瞩/瞩目/目的/的北/北京/京第/第二/二十/十九/九届/届奥/
奥林/林匹/匹克/克运/运动/动会/会开/开幕/幕式/式在/在国/国家/家体/体育/育场/场隆/
隆重/重举/举行/

- MIK_CAnalyzer  (最大匹配+二元交叉)

2008年/8月/8日/晚/举世瞩目/目的/北京/第二十九届/奥林匹克运动会/开
幕式/在国/国家/体育场/隆重举行/

- etc
  
sqlite3 中因为支持 FTS, 所以也支持几种分词算法:
- simple 
  针对英文, 根据空格分词
- porter
  针对英文, 使用 port stemmer
- icu
  使用 icu 库进行简单分词, 没有看懂 fts_icu 的源码, 从分词结果看类似于一元分词
  (待确定)

**** inverted index (倒排索引)
通过分词算法确定关键词后, FTS 会使用倒排索引建立索引, 例如全文有两句话:

`今天天气怎么样.
今天天气不错. `

- 分词的结果

  今天/天气/怎么样/今天/天气/不错

- 倒排索引结果

  今天->1,0;2,0
  天气->1,2;2,2
  怎么样->1,4
  不错->2,4

倒排索引的结果通常会以一种高效的利于查找的形式保存到索引文件中, 例如根据关键字排
序, 或使用 B 树
**** 查找过程
根据索引文件格式的不同, 查找的过程有所区别, 以 B 树为例, 查找过程就是以查找字符
串为KEY在B树中查找该关键字,查到的VALUE就是该关键字在文档中的行列位置.

全文查找速度很快,但有一个明显的缺点: 检索的效果依赖于关键字的选择.

例如, 
- 使用 "tty" 无法检索到 " hello kitty "这句话
- 使用 "天天" 可能无法检索到 "今天天气不错"

**** FTS in sqlite3
- create virtual table search_index using fts3(content TEXT, tokenize=porter);
  tokenize 可以为 simple, porter, icu, 但默认情况下 icu tokenizer 功能没有被编译
  到 sqlite3 中
- select * from search_index where content match "token1 token2"
- select * from search_index where content match "tok*"

* Footnotes

[fn:1] because A is holding a `shared` lock

[fn:2] because B is holding a `reserved` lock

#+TITLE: Android PackageManager
* PackageManager
** installd
installd is a system binary running as `root` and listening on `installd` socket.
see [[@dalvik-cache]]
- when installing and uninstalling package, PMS need to mkdir/rmdir /data/data/xxx, but those data dirs is not accessable by PMS (PMS running with
  `system` uid, while data dirs is owned by package uids like `app_1`), so PMS need to use `installd` to access those data dir.
- after package is installed / deleted, PMS need invoke dex_opt / rm_dex to do the dirty work like optimize dex to dalvik-cache or remove dalvik-cache,
  those works are also delegated to installd.
** forward_lock
    adb install -l xxx.apk ( -l means `forward_lock` install )

    when xxx.apk is `forward_lock` installed
    - it's orig .apk is deleted
    - it's res/, manifest.xml is put to /data/app/xxx.zip
      (note that .dex is cached in dalvik-cache)
** install Package
- there are 2 ways to install package:
   1. push xxx.apk to any folder of /data/app, /system/app, /system/framework
   2. use PackageInstaller or adb install (which will invoke PM.installPackage())
          
- `system` application & 3rd application
  `system` is a property of ApplicationInfo after installation.
  `system` application are applications not listed in `downloaded` category in Settings, while 3rd applications are applications listed in `downloaded`
  category.
      
  PackageManager will decide whether a newly installed application is a `system` application:
  - if apk is pushed to /system/app & /system/framework, then it is `system` application
  - if apk is replacing an existing old system application, then it is.
  - ...
*** adb push
#+BEGIN_SRC java
     FileObserver.onEvent()
       isApk=isPackageFilename():
         name.endsWith(".apk");
       if !isApk:return;
       if ignoreCodePath(fullPathStr):   ;; if apk name is like "xxx-1.apk", it will be ignored!
                                         ;; this is because PM.installPackage will also put installed package to /data/app, PM.installPackage use the
					 ;; special naming rule to prevent FileObserver from installing the apk again.
         return
       if ADD_EVENTS:
         scanPackageLI(mIsRom?PARSE_IS_SYSTEM:0) ;; if apk is in /system/app or /system/framework, mIsRom is true
	                                         ;; package with PARSE_IS_SYSTEM flag will be marked as `system` application
	 updatePermissionsLP()
       if REMOVE_EVENTS:
         removePackageLI()
       if addedPackage!=null:
         sendPackageBroadcast(ACTION_PACKAGE_ADDED)
       if removedPackage!=null:
         sendPackageBroadcast(ACTION_PACKAGE_REMOVED)
#+END_SRC
*** PM.installPackage
**** PackageInstaller
**** install location (src & dest)
***** src apk location
 - from DownloadManager through ContentProvider
 - from file though MediaContainerService
***** app install location
the apk's install location can be internal flash / sdcard.
1. The apk's manifest may declares it's `install location`, including:
  - auto
  - internalOnly
  - preferExternal
2. PackageHelper.recommendAppInstallLocation() make the ultimate decision:
  - if `install location` is not set in manifest, internal will always be selected
  - auto
    if apk's code size>1MB, location will be set to external, unless external storage is slow (<10% free space..
  - internalOnly
    internal will be selected
  - preferExternal
    always selected external unless storage is unavailable or inefficient.
  - system setting for default installation location is also considered
To summurize:
   - manifest's `install location`
   - system setting for `default install location`
   - internal/external storage status
         
**** MediaContainerService / DefaultContainerService
SCHEDULED: <2011-03-02 Wed> CLOSED: [2011-03-02 Wed 16:42]
- State "DONE"       [2011-03-02 Wed 16:42]
  see [[@MountService]]
  see [[@secure_container]]
MediaContainerService is mainly used by app with `system' uid to access sdcard,
because `system' process can't access sdcard, because:

#+BEGIN_SRC fundamental
$ ls sdcard
d---rwxr-x system sdcard_rw 2010-07-26 12:56 sdcard
#+END_SRC

#+BEGIN_QUOTE

http://stackoverflow.com/questions/5617797/android-shared-user-id-and-reading-writing-a-file

The system user can not access the SD card, because if the SD card gets
unmounted it may need to kill any processes that have files open on it and we
don't want system processes being killed like that. If you want to access the SD
card, you need to not use the system shared user ID.

#+END_QUOTE
**** calling stack
** Replace Package
** Uninstall package
*** Intent.ACTION_PACKAGE_REMOVED
** resolveActivity
as shown in [[IntentFilter matching][IntentFilter matching]], startActivity will call
PM.resolveIntent to resolve the intent, and get one best ResolveInfo;

PM.resolveActivity() will also call PM.resolveIntent() to resolve the
intent, but there is ONE difference, PM.resolveActivity will not force
the DEFAULT_ONLY flag set when calling resolveIntent(). but
startActivity will.

** android package vs. java package vs. android application
** UID & GID
see also [[Java Process Creation]], [[Zygote]], [[System Init]] to distinguish
`process uid' against `file uid'

UID (including sharedUserId) is maintained by pm.Settings

*** pre-defined UID
see system/core/include/private/android_filesystem_config.h

#+BEGIN_SRC c
  static const struct android_id_info android_ids[] = {
      { "root",      AID_ROOT, },
      { "system",    AID_SYSTEM, },
      { "radio",     AID_RADIO, },
      { "bluetooth", AID_BLUETOOTH, },
      { "graphics",  AID_GRAPHICS, },
      { "input",     AID_INPUT, },
      { "audio",     AID_AUDIO, },
      { "camera",    AID_CAMERA, },
      { "log",       AID_LOG, },
      { "mount",     AID_MOUNT, },
      { "wifi",      AID_WIFI, },
      { "dhcp",      AID_DHCP, },
      { "adb",       AID_ADB, },
      { "install",   AID_INSTALL, },
      { "media",     AID_MEDIA, },
      { "sdcard_r",  AID_SDCARD_R, },
      { "sdcard_rw", AID_SDCARD_RW, },
      { "media_rw",  AID_MEDIA_RW, },
      // ...
      { "vpn",       AID_VPN, },
      { "keystore",  AID_KEYSTORE, },
      { "usb",       AID_USB, },
      { "mtp",       AID_MTP, },
      { "gps",       AID_GPS, },
      { "inet",      AID_INET, },
      { "net_raw",   AID_NET_RAW, },
      { "net_admin", AID_NET_ADMIN, },
      { "net_bw_stats", AID_NET_BW_STATS, },
      { "net_bw_acct", AID_NET_BW_ACCT, },
      { "misc",      AID_MISC, },
      { "nobody",    AID_NOBODY, },
  };
#+END_SRC

*** app UID
during scanPackageLI, but before mInstaller.install(), app UID is
generate by the mSettings.
#+BEGIN_SRC text
  scanPackageLI
    // Just create the setting, don't add it yet. For already existing packages
    // the PkgSetting exists already and doesn't have to be created.
    pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile,
                      destResourceFile, pkg.applicationInfo.nativeLibraryDir,
                      pkg.applicationInfo.flags, true, false);
      p.appId = newUserIdLPw(p);
        final int N = mUserIds.size();
          for (int i = 0; i < N; i++) {
              if (mUserIds.get(i) == null) {
                  mUserIds.set(i, obj);
                  return Process.FIRST_APPLICATION_UID + i;
              }
          }
          // None left?
          if (N > (Process.LAST_APPLICATION_UID-Process.FIRST_APPLICATION_UID)) {
              return -1;
          }
          mUserIds.add(obj);
          return Process.FIRST_APPLICATION_UID + N;
    pkg.applicationInfo.uid = pkgSetting.appId;
#+END_SRC
*** sharedUserId
**** sharedUserId pre-defined by the PMS
#+BEGIN_SRC java
PackageManagerService.<init>
  mSettings.addSharedUserLPw("android.uid.system", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw("android.uid.phone", RADIO_UID, ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw("android.uid.log", LOG_UID, ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw("android.uid.nfc", NFC_UID, ApplicationInfo.FLAG_SYSTEM);
#+END_SRC

That is, 
- android.uid.system
- android.uid.phone
- android.uid.log
- android.uid.nfc

these 4 sharedUserId is defined statically in PMS, and they
  corresponds to the static UID (SYSTEM_UID, RADIO_UID, ...)

**** sharedUserId defined by app
App can define `sharedUserId' freely, PMS will use `Setings' to
maintain the dynamic `sharedUserId' -> `uid' mapping during `scanPackageLI'

The most well-known app `sharedUserId' is `android.uid.shared', which
is defined by `Contacts' and `ContactsProvider'




** Multi-User support
android 4.1 use UserManager to support multi-user, in-short, uid
stored in pm.Setting is encoded as a mixer of multi-user-id and app_id,
e.g. u0_a33, or u1_a33. 

As against android pre 4.1, app_id is taken as uid.

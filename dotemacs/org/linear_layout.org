* LinearLayout
** onMeasure
LinearLayout 的 measure 过程用于确定整个 LinearLayout 及其 child view 的大小,
这个过程可能是一个多次迭代,不断协商的过程,因为每个 child view 的大小经常无法通过
一次遍历就确定, 例如:
   - Horienzontal LinearLayout 带有 baselineAlligned 属性的
   - 某个 child view 包含 layout_weight 属性的, 要求第一次 measure 完成后根据
     layout_weight 重新分配剩余空间
   - wrap_content

#+begin_src java
  if mOrientation == VERTICAL:
      measureVertical(widthMeasureSpec, heightMeasureSpec);

  else
      measureHorizontal(widthMeasureSpec, heightMeasureSpec);
#+end_src

measureVertical 相对 measureHorizontal 简单一些, 因为它不涉及 baseline
alignment.

*** measureVertical:

#+BEGIN_EXAMPLE
  int largestChildHeight = Integer.MIN_VALUE;
  int mTotalLength;
  // mTotalLenght 为第一次 measure 时总的高度(不考虑 weight)
  // 包含各个 child view 的高度的和, 加上 padding, divider,这个值
  // 是第二次 measure 时计算`空闲空间`的依据.                                o
  int totalWeight;
  // totalWeight 为第一次 measure 时计算的各个 child view 的 layout_weight 的总和

  for (int i = 0; i < child_view_count; ++i):
    if child.getVisibility() == View.GONE:
       // visibility 为 GONE 的 child view 的高度不会被计算
       // 显然, INVISIBLE 的 child view 高度是会被计算的
       // 这就是 INVISIBLE 与 GONE 的区别
       continue;
    if hasDividerBeforeChildAt(i):
         // LinearLayout 可以通过 setShowDividers(int how) 来影响 hasDividerBeforeChildAt 的结果:
         hasDividerBeforeChildAt:
           if (childIndex == 0):
              return (mShowDividers & SHOW_DIVIDER_BEGINNING) != 0;
           else if childIndex == getChildCount():
              return (mShowDividers & SHOW_DIVIDER_END) != 0;
           else if (mShowDividers & SHOW_DIVIDER_MIDDLE) != 0:
              ...
         mTotalLength += mDividerHeight;

     LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
     totalWeight += lp.weight;
     if heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0:
       // 这是一个优化, 即:
       // 若某个 child view 的 layout_height 为 0, 并且其 layout_weight 不为0,
       // 表示该 child view 并不知道自己需要多高, 只是希望 LinearLayout 在第二次 measure
       // 时能根据 child view 指定的 layout_weight 值分配一点剩余空间给它. 这时 LinearLayout
       // 在第一次 measure 时没有必要去 measure 它.

       // 为什么不直接写成:
       // mTotalLength = totalLength + lp.topMargin + lp.bottomMargin; ?
       // 因为 child view 的 top, bottom margin 可能为负值 ...
       mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
     else:
       // 进行第一次 measure
       measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec,
                     totalWeight == 0 ? mTotalLength : 0);
         // 注意上面的 totalWeight == 0 的条件: 若 totalWeight 不为0, 则说明至少有一个 child view 指定了 layout_weight 值, 然后下面的函数的 totalHeight 会为 0
         measureChildWithMargins(child, widthMeasureSpec, totalWidth,
                                        heightMeasureSpec, totalHeight);
         // totalHeight 是 当前measure过的其他 child view 已经占用的 height, 所以当前 child view
         // 可用的 height 基本相当于 heightMeasureSpec.getHeight-totolHeight. 但若 totalHeight为0, 说明在measure这个child view 时, 其他 child view
         // 已经占用的 height 根据没有考虑!
         // android orig comment like this:
         //         "when determine how big next child would like to be, If this or previous children have given a weight, then we allow it to
         //   use all available space (and we will shrink things later if needed)."

           childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin+ heightUsed,
                                  lp.height);
           // 第一个参数是 spec 是 LinearLayout 的 measurespec, child view 不可能突破 parent view 的 mearsure spec, 比如请求一个比 parent view 更大的高度
           // 第二个参数是 padding, 即 需要在 parent view 上需要预留这部分空间,不能分配给 child view
           // 第三个参数是 childDimension, child view 期望分配的高度
           // layout_height 的 FILL_PARENT, MATCH_PARENT 这些属性主要在 getChildMeasureSpec 中处理.
             if spec==EXACTLY:
             // Parent has imposed an exact size on us
               if childDimension>=0:
                 resultSize=childDimension;
                 resultMode=EXACTLY;
               elif childDimension==MATCH_PARENT:
                 resultSize=spec-padding;
                 resultMode=EXACTLY;
               elif childDimension==WRAP_CONTENT:
                 resultSize=spec-padding;
                 resultMode=AT_MOST;
             elif ..
               ..
           child.measure(..,childHeightMeasureSpec);
       int childHeight = child.getMeasuredHeight();
       mTotalLength  += childHeight + lp.topMargin + lp.bottomMargin;
       // if heightMode.. ends here
       mTotalLength += mPaddingTop + mPaddingBottom;
       // for ... ends here

  int heightSize = mTotalLength;
  // considure android:minHeight
  heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
  int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
  heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
  // heightSize 取决于 measure spec 及 mTotalLength, 例如, 若 spec mode 为AT_MOST, 则 heightSize 有可能和 mTotalLength 相同, 导致后面的代码不起作用
  int delta = heightSize - mTotalLength;
  // heightSize 是总的高度, mTotoalLength 是经常第一次 measure 后各个 child view 加上 margin, padding 后要求的高度的总和
  // 注意, 由于 weight 的存在, 在第一次 measure 后, 经常导致 mTotalLength > heightSize
  if (delta != 0 && totalWeight > 0.0f):
  // 第二次 measure 开始
    float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
    mTotalLength = 0;
    // 参考android:weightSum属性
    for (int i = 0; i < count; ++i):
      if (child.getVisibility() == View.GONE):
        continue;
      weight = lp.weight;
      if weight > 0:
        share = (int) (weight * delta / weightSum);
        weightSum -= weight;
        delta -= share;
        if (lp.height != 0) || (heightMode != MeasureSpec.EXACTLY):
          childHeight = child.getMeasuredHeight() + share;
          child.measure(childWidthMeasureSpec,MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
        else:
          child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share,MeasureSpec.EXACTLY));
      mTotalLength +=  child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
    // for .. ends here
    mTotalLength += mPaddingTop + mPaddingBottom;
  else:
    // We have no limit, so make all weighted views as tall as the largest child.
    // Children will have already been measured once.
  setMeasuredDimension(...,heightSize);
  // 向LinearLayout parent view 通告自己的大小.
#+END_EXAMPLE

*** measureHorizontal
measureHorizontal 与 measureVertical 类似, 不同的是多了对 baseline alignment 的
考虑.

#+CAPTION: baseline
[[file:/home/apuser/.elisp/dotemacs/org/attachment/baseline.png]]

当 horienzontal LinearLayout 包含多个 textview, button 等控件时, 若这些控件的高
度大小不一, baseline alignment 可以使这些控件按 baseline 对齐, 前提是每个控件提
供了一个 getBaseline 方法告诉 LinearLayout 它的 baseline 离控件的顶端有多远. 
TextView, Button 都实现了 getBaseline 方法. 

而现在又有一个问题:若 LinearLayout 是 baseline alignment, 而各个 child view 指定
了不同的 layout gravity 怎么办? 根本不可能对的齐... android 的做法是:
属于同一个 layout gravity 的 child view 是 baseline aligned 就可以了. 

由于 baseline alignment 属于 layout 的范畴, 所以在 measure 阶段系统需要做的只是
顺便将各个 child view 的 getBaseline 的返回值保存在一个名为 mMaxAscent 的
int[VERTICAL_GRAVITY_COUNT] 数组中, 其意义为:
若 mMaxAscent[GRAVITY_CENTER_VERTICAL] 为 10, 则表示在 center_vertical gravity
的位置 baseline 最大的一个控件的 baseline 为10, 其它的小控件需要与其 baseline alignment

** onLayout
onMeasure 结束后, LinearLayout 及其 child view 的大小就确定了, 对 LinearLayout
来说, 下面需要做的是确定各个 child view 的位置, 这个过程就是 layout 的过程.

总的来说, LinearLayout 对 child view 的 layout 过程比 RelativeLayout 简单的多,因
为它的名字就决定了 layout 的过程基本上就是从上到下,从左到右顺序摆放. 但比起
FrameLayout 和 AbsoluteLayout 还是要复杂一些.

还是先以 vertical LinearLayout 为例:
*** layoutVertical
#+BEGIN_EXAMPLE
  int childTop;
  // child view 的 top, 通常这个值是 LinearLayout 最上面的位置加上 LinearLayout 的 padding,
  // 但 LinearLayout 的 gravity 属性会让一切有所变化
  
  majorGravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  minorGravity = mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
  
  // Q: majorGravity vs. minorGravity?
  // A: 对 vertical LinearLayout 来说, 和 vertical 有关的 gravity 是 majorGravity, 和 horienzontal
  //    有关的 gravity 是 minorGravity
  
  if majorGravity==BOTTOM:
    childTop = mPaddingTop + mBottom - mTop - mTotalLength;
    // childTop 此时离 bottom 的距离为 mTotalLength..效果就是所有 child view 整体下移了
  elif majorGravity==CENTER_VERTICAL:
    childTop = mPaddingTop + (mBottom - mTop - mTotalLength) / 2;
  else:
    childTop = mPaddingTop;
  for (int i = 0; i < count; i++):
    if child.getVisibility==GONE:
      continue;
    gravity = lp.gravity;
    // 获取 child view 的 layout_gravity 属性, 若没有设置, 则使 LinearLayout 的 gravity 对应的
    // minorGravity
  
    if gravity==CENTER_HORIZONTAL:
      childLeft = paddingLeft + ((childSpace - childWidth) / 2)
                                  + lp.leftMargin - lp.rightMargin;
    elif gravity==RIGHT:
      childLeft = childRight - childWidth - lp.rightMargin;
    else:
      childLeft = paddingLeft + lp.leftMargin;
    childTop += lp.topMargin;
    setChildFrame(child, childLeft, childTop + getLocationOffset(child),childWidth, childHeight);
    // setChildFrame 会真正确定 child view 的上下左右位置. 这个 frame 会和后面的 key event dispatching
    // 直接相关
    childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);
  // for ... ends here
#+END_EXAMPLE
可见, LinearLayout 的 layout 过程是相关简单的, 对于 vertical LinearLayout, 只需
要考虑 LinearLayout 的 gravity 属性和 child view 的 layout_gravity 属性. 
*** layoutHorizontal
layoutHorizontal 与 layoutVertical 类似, 唯一不同的就是需要根据 child view 的
gravity 获得 mMaxAscent 里对应的 baseline 的值, layout 时考虑这个值就可以了. 
** onDraw
** To summarize
- measure 过程
  - layout_weight
    1. LinearLayout 会 measure 两次
    2. 第一次 measure 时会有些优化和特殊处理, 例如: 
    3. layout_height 为 0 时可能会省略一次 measure;
    4. 若 measure 某个 child view 时, 这个 child view 或之前的 child view 有
       layout_weight 属性, 则 LinearLayout 尝试给该 child view 更大的空间.
    5. 第二次 measure 时会通过第一次 measure 计算的 mTotalHeight 与 heightSize 计
       算一个 delta 值 (可正可负), 然后按 weight 做权值分配到各个 child view 上.
- layout 过程
  - graivty && layout_gravity
  - baselineAlligned 
- 区分 layout_xxx 与 xxx 属性, 例如: 
  - layout_gravity 与 gravity
  - layout_height 与 height
  - margin 与 padding

